import { PopupLevel, Pose, RequestValueType, URVariable, ZUpRotationVectorRadians, ControllerPose } from '../types/nodes';
/**
 *
 * ScriptBuilder provides methods to easily generate well indented UR script programmatically.
 * This class manages indentation automatically as the script is built step by step.
 * But,it does not guarantee perfect formatting as there is a possibility to pass badly formatted expressions, statements or scripts.
 *
 */
export declare class ScriptBuilder {
    static readonly SINGLE_INDENT = "  ";
    static readonly SINGLE_INDENT_LEVEL = 1;
    readonly type = "$$ScriptBuilder";
    private script;
    private currentIndent;
    /**
     * Creates a new ScriptBuilder
     *
     * @param script If a script is specified, the new ScriptBuilder will be preloaded with that script
     * @param initialIndent If an indent is specified, the ScriptBuilder will be initialized with that indent
     */
    constructor(script?: string, initialIndent?: number);
    /**
     * Generate the String representation of a boolean.
     *
     * @param b The input boolean
     * @return The String representation of the input
     */
    static getBooleanAsString(b: boolean): string;
    /**
     * Return a String representing the URScript for negating an expression.
     * @param expression The expression to be negated
     * @return String representation of the negated expression.
     */
    /**
     *
     * @param expression The expression to be negated
     */
    static negate(expression: string): string;
    /**
     * Return a String representation of the input array.
     * @param input the input array.
     * @return String representation of the input array.
     */
    static formatArray(input: number[] | string[] | boolean[]): string;
    /**
     * Converts a variable's value to a URScript-compatible literal string based on its declared type.
     *
     * Handles proper formatting for POSE, BOOLEAN, ARRAY, and STRING types to ensure valid URScript syntax.
     * - Strings like "true"/"false" are parsed to booleans when the variable type is BOOLEAN.
     * - Arrays passed as comma-separated strings or raw arrays are parsed and validated for homogeneity.
     * - POSE values are returned as-is within a `p[...]` wrapper, assuming correct formatting.
     * - Returns an empty string `''` for invalid or mixed-type array inputs, or if the variable type is missing.
     *
     * @param variable The URVariable object containing the variable's metadata.
     * @param value The value to be converted. Typically a string, but may also be a boolean, number, or array.
     * @returns The value formatted as a URScript-compatible literal string.
     */
    static formatVariableToURScriptLiteral(variable: URVariable, value: string | number | boolean | string[] | number[] | boolean[] | number[][]): string;
    /**
     * Create a ScriptBuilder preloaded with the incognito program definition.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} before
     * calling {@link #getScript()}.
     *
     * @return new ScriptBuilder.
     */
    static CreateInkognitoProgram(): ScriptBuilder;
    /**
     * Create a ScriptBuilder preloaded with a secondary program definition.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} before
     * calling {@link #getScript()}.
     *
     * @param name The name of the secondary program.
     * @return new ScriptBuilder.
     */
    static CreateSecondaryProgram(name: string): ScriptBuilder;
    /**
     * Add a block of statements to the builder.
     *
     * @param statements A block of statements as a String.
     * @return this object.
     */
    addStatements(statements: string): ScriptBuilder;
    /**
     * Add raw script code.
     * As this method takes raw script code that may not be indented and appends it without indenting it,
     * it may violate the overall indentation.
     *
     * @param script The script to be appended
     * @return this object.
     */
    addRaw(script: string): ScriptBuilder;
    /**
     * Add a while statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param expression The string representation of an expression.
     * @return this object.
     */
    beginWhile(expression: string): ScriptBuilder;
    /**
     * Add a while not statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param expression The string representation of an expression.
     * @return this object.
     */
    beginWhileNot(expression: string): ScriptBuilder;
    /**
     * Add a while statement that loops forever.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @return this object.
     */
    beginWhileTrue(): ScriptBuilder;
    /**
     * Add the end keyword that balances/terminates the declaration of functions, branch and loop statements.
     *
     * @return this object.
     */
    end(): ScriptBuilder;
    /**
     * End a block, without an end statement
     * Used by if and elseif
     * @return this object.
     */
    endBlock(): ScriptBuilder;
    /**
     * Add a return statement.
     *
     * @return this object.
     */
    returnMethod(): ScriptBuilder;
    /**
     * Add a statement that declares a global variable and assigns it an initial value.
     *
     * @param name  The name of the global variable.
     * @param value An expression which is the initial value of the global variable.
     * @return this object.
     */
    globalVariable(name: string, value: string): ScriptBuilder;
    /**
     * Add a statement that declares a local variable and assigns it an initial value.
     *
     * @param name  The name of the local variable.
     * @param value An expression which is the initial value of the local variable.
     * @return this object.
     */
    localVariable(name: string, value: string): ScriptBuilder;
    /**
     * Declares or updates a persistent (shared) variable in URScript with the given name and value.
     * Shared variables retain their values between program runs and are accessible globally.
     *
     * @param name  The name of the persistent variable.
     * @param value The initial value or expression to assign to the persistent variable.
     * @returns This ScriptBuilder instance for chaining.
     */
    setPersistentVariable(name: string, value: string): ScriptBuilder;
    /**
     * Add a statement that increments a variable with the given name.
     *
     * @param name The name of the variable.
     * @return this object.
     */
    incrementVariable(name: string): ScriptBuilder;
    /**
     * Add a statement that assigns an expression to a variable.
     *
     * @param name       The name of the variable.
     * @param expression The expression to be assigned to the variable.
     * @return this object.
     */
    assign(name: string, expression: string): ScriptBuilder;
    /**
     * Add an if statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #elseIfCondition(String)} or
     * {@link #else()} or {@link #end()} at the appropriate time.
     *
     * @param expression The expression that the if statement branches on.
     * @return this object.
     */
    ifCondition(expression: string): ScriptBuilder;
    /**
     * Add an else if statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #elseIfCondition(String)} or
     * {@link #elseIfCondition(Script)} or {@link #else()} or {@link #end()} at the appropriate time.
     *
     * @param expression The expression that the else if statement branches on.
     * @return this object.
     */
    elseIfCondition(expression: string): ScriptBuilder;
    /**
     * Add an else statement.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @return this object.
     */
    else(): ScriptBuilder;
    /**
     * Add a thread definition with given the threadName.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param threadName The threadName of the thread.
     * @return this object.
     */
    defineThread(threadName: string): ScriptBuilder;
    /**
     * Add a statement to run a thread with the given name and assign the thread handle to a variable.
     *
     * @param threadHandle The variable that gets assigned the thread handle .
     * @param threadName   The name of the thread to be started.
     * @return this object.
     */
    runThread(threadHandle: string, threadName: string): ScriptBuilder;
    /**
     * Add a statement to kill a thread.
     *
     * @param threadHandle The thread threadHandle.
     * @return this object.
     */
    killThread(threadHandle: string): ScriptBuilder;
    /**
     * Add a function definition with the given name and parameters.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param name   The name of the function.
     * @param params The parameters of the function.
     * @return this object.
     */
    defineFunction(name: string, ...params: string[]): ScriptBuilder;
    /**
     * Add a comment in the script.
     *
     * @param text The comment text.
     * @return this object.
     */
    comment(text: string): ScriptBuilder;
    /**
     * Add a frame with the name 'name' initialized at the specified pose expressed in the refFrame coordinate frame.
     * This command only adds a frame to the world, it does not attach it to the ref_frame coordinate frame.
     * Use attach_frame() to attach the newly added frame to ref_frame if desired.
     * @param name name of the frame to be added.  The name must not be the same as any existing world model object (frame, axis, or axis group), otherwise an exception is thrown
     * @param pose initial pose of the new object or string expression
     * @param refFrame name of the world model object whose coordinate frame the pose is expressed in.  If nothing is provided here, the default is the robot "base" frame.
     */
    addFrame(name: string, pose: ControllerPose): ScriptBuilder;
    /**
     * Add a frame with the name 'name' initialized at the specified pose expressed in the refFrame coordinate frame.
     */
    addFrame(name: string, poseOrExpression: Pose | string, refFrame?: string): ScriptBuilder;
    /**
     * Delete the frame named frame from the world model.
     * The "world", "base", and "tcp" frames cannot be deleted.
     * Any frames that are attached to the deleted frame will be attached to the "world" frame with new frame offsets set
     * such that the detached frame does not move in the world.
     * This command will fail if the frame does not exist.
     * @param name name of the frame to be deleted
     */
    deleteFrame(name: string): ScriptBuilder;
    /**
     * Changes the placement of the coordinate frame named name to the new placement given by pose that is defined in the refFrame coordinate frame.
     * This will fail if name is “world”, "tcp", or if the frame does not exist. Note: to move the "tcp" frame, use the set_tcp() command instead.
     * If being used with the part positioner product, the ref_name argument can be the name of an external axis or axis group.
     * @param name the name of the frame to move
     * @param pose the new placement
     * @param refFrame the coordinate frame that pose is expressed in.  The default value is the robot's "base" frame.
     */
    moveFrame(name: string, pose: ControllerPose): ScriptBuilder;
    /**
     * Changes the placement of the coordinate frame named name to the new placement given by pose that is defined in the refFrame coordinate frame.
     */
    moveFrame(name: string, pose: Pose, refFrame?: string): ScriptBuilder;
    /**
     * Attaches the child frame to the parent world model object. The relative transform between the parent and child will be set such that
     * the child does not move in the world when the attachment occurs.
     * The child cannot be "world", "tcp", or the same as parent.
     * This will fail if child or parent is not an existing frame, or this makes the attachments form a closed chain.
     * @param child name of the frame to be attached.  The name must not be "world" or "tcp".
     * @param parent name of the object that the child frame will be attached to.
     */
    attachFrame(child: string, parent: string): ScriptBuilder;
    /**
     * Changes the orientation of the frame @p name to the given @p orientation.
     */
    setFrameOrientation(name: string, orientation: ZUpRotationVectorRadians): ScriptBuilder;
    /**
     * @deprecated Use the overload that accepts zUpRotationVectorRadians directly instead
     */
    setFrameOrientation(name: string, orientation: [number, number, number]): ScriptBuilder;
    /**
     * Add a popup with the given parameters.
     *
     * @param message    The popup message.
     * @param title      The popup title.
     * @param level      The popup level.
     * @param isBlocking true if its a blocking popup and false otherwise.
     * @return this object.
     */
    popup(message: string, title: string, level: PopupLevel, isBlocking: boolean): ScriptBuilder;
    /**
     * Request a value with the given parameters.
     *
     * @param variableName  The variable name to assign the value to
     * @param message       The request message.
     * @param valueType     The type: integer, float, boolean, or string
     * @return this object.
     */
    requestValue(variableName: string, message: string, valueType: RequestValueType): ScriptBuilder;
    /**
     * Add a halt statement.
     *
     * @return this object.
     */
    halt(): ScriptBuilder;
    /**
     * @deprecated Use {@link break}
     * @description Insert a break statement.
     * @return this object.
     */
    insertBreak(): ScriptBuilder;
    /**
     * @description Insert a break statement.
     * @return this object.
     */
    break(): ScriptBuilder;
    /**
     * Add a sync command that uses up the remaining "physical" time a thread has in the current frame.
     *
     * @return this object.
     */
    sync(): ScriptBuilder;
    /**
     * Add a sleep command.
     *
     * @param seconds The amount of time in seconds.
     * @return this object.
     */
    sleep(seconds: number | string): ScriptBuilder;
    /**
     * Add a stopl command. It decelerates tool speed to zero.
     *
     * @param toolAcceleration The tool acceleration in <i>m/</i><i>s</i><sup>2</sup>.
     * @return this object.
     */
    stopl(toolAcceleration: number | string): ScriptBuilder;
    /**
     * Add a stopj command. It decelerates joint speeds to zero.
     *
     * @param jointAcceleration The joint acceleration in <i>rad/</i><i>s</i><sup>2</sup>.
     * @return this object.
     */
    stopj(jointAcceleration: number | string): ScriptBuilder;
    /**
     * Add a call to the function that will accelerate linearly in Cartesian space and continue with constant tool
     * speed.
     *
     * @param xd                    array of tool speeds in m/s (spatial vector).
     * @param cartesianAcceleration tool position acceleration <i>m/</i><i>s</i><sup>2</sup>.
     * @param time                  time in seconds before the function returns.
     * @param refFrameName          name of reference frame
     * @return this object.
     */
    speedl(xd: number[] | string[], cartesianAcceleration: number | string, time: number | string, refFrameName?: string): ScriptBuilder;
    /**
     * Add a call to the function that will accelerate linearly in joint space and continue with constant joint
     * speed.
     *
     * @param qd                array of joint speeds in rad/s.
     * @param jointAcceleration joint acceleration in <i>rad/</i><i>s</i><sup>2</sup> (of leading axis)
     * @param time              time in seconds before the function returns.
     * @return this object.
     */
    speedj(qd: number[] | string[], jointAcceleration: number | string, time: number | string): ScriptBuilder;
    /**
     * Add a call to the function that will Move to position (linear in joint-space).
     * @param q joint positions (q can also be specified as a pose, then
     * inverse kinematics is used to calculate the corresponding
     * joint positions) as a string or number array.
     * @param acc joint acceleration of leading axis in <i>rad/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed joint speed of leading axis in rad/s as a string or number (optional).
     * @param time time in seconds as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    movej(q: string | number[], acc?: string | number, speed?: string | number, time?: string | number, blendRadius?: string | number): ScriptBuilder;
    /**
     * Add a call to the function that will Move to position (linear in tool-space).
     * @param pose target pose (pose can also be specified as joint
     * positions, then forward kinematics is used to
     * calculate the corresponding pose) as a string.
     * @param acc tool acceleration <i>m/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed tool speed in m/s as a string or number (optional).
     * @param time time in seconds as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    movel(pose: string, acc?: string | number, speed?: string | number, time?: string | number, blendRadius?: string | number): ScriptBuilder;
    /**
     * Blend circular (in tool-space) and move linear (in tool-space) to position. Accelerates to and moves
     * with constant tool speed v.
     * @param q joint positions (q can also be specified as a pose, then
     * inverse kinematics is used to calculate the corresponding
     * joint positions) as a string or number array.
     * @param acc joint acceleration of leading axis in <i>rad/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed joint speed of leading axis in rad/s as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    movep(q: string | number[], acc?: string | number, speed?: string | number, blendRadius?: string | number): ScriptBuilder;
    /**
     * TCP moves on the circular arc segment from current pose, through pose_via to pose_to.
     * Accelerates to and moves with constant tool speed v. Use the mode parameter to define the
     * orientation interpolation.
     * @param pose_via path point (note: only position is used). Pose_via can also be specified as joint
     * positions, then forward kinematics is used to calculate the corresponding pose as a string or number array.
     * @param pose_to target pose (note: only position is used in Fixed orientation mode). Pose_to can also
     * be specified as joint positions, then forward kinematics is used to calculate the corresponding
     * pose as a string or number array.
     * @param acc tool acceleration <i>rad/</i><i>s</i><sup>2</sup> as a string or number (optional).
     * @param speed tool speed in m/s as a string or number (optional).
     * @param blendRadius blend radius (of target pose) in m as a string or number (optional).
     * @param mode mode of circular arc move as a string or number (optional).
     * 0: Unconstrained mode. Interpolate orientation from current pose to target pose (pose_to)
     * 1: Fixed mode. Keep orientation constant relative to the tangent of the circular arc (starting
     * from current pose)
     * @return this object.
     */
    movec(pose_via: string | number[], pose_to: string | number[], acc?: string | number, speed?: string | number, blendRadius?: string | number, mode?: string | number): ScriptBuilder;
    /**
     * Add a call to the function that will Move to position (linear in joint-space), using OptiMove
     * @param q joint positions (q can also be specified as a pose, then
     * inverse kinematics is used to calculate the corresponding
     * joint positions) as a string or number array.
     * @param acc Joint acceleration as a fraction of what the joints are able to perform - a (0.0, 1.0] (optional).
     * @param speed Joint speed as a fraction of how fast the joints can move during the motion - v (0.0, 1.0] (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    optimovej(q: string | number[], acc?: string | number, speed?: string | number, blendRadius?: string | number): ScriptBuilder;
    /**
     * Add a call to the function that will Move to position (linear in tool-space), using OptiMove
     * @param pose target pose (pose can also be specified as joint
     * positions, then forward kinematics is used to
     * calculate the corresponding pose) as a string.
     * @param acc tool acceleration <i>m/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed tool speed in m/s as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    optimovel(pose: string, acc: string | number, speed?: string | number, blendRadius?: string | number): ScriptBuilder;
    /**
     * @deprecated use {@link setTargetPayload}
     * @description Add a call to the function that sets the mass.
     * @param mass mass in kilograms as a Script.
     * @return this object.
     */
    setPayloadMass(mass: string | number): ScriptBuilder;
    /**
     * @deprecated use {@link setTargetPayload}
     * @description Add a call to the function that sets the mass and CoG.
     * @param mass mass in kilograms as a Script.
     * @param cx CoG x offset in meters
     * @param cy CoG y offset in meters
     * @param cz CoG z offset in meters
     * @param inertia The payload inertia matrix in kg*m^2, elements lxx,lyy
     * lzz, lxy, lxz, lyz
     * @return this object.
     */
    setPayloadMassAndCoG(mass: string | number, cx: string | number, cy: string | number, cz: string | number, inertia?: [number, number, number, number, number, number]): ScriptBuilder;
    /**
     * @description Add a call to the function that sets the mass and CoG.
     * @param mass mass in kilograms as a Script.
     * @param cx CoG x offset in meters
     * @param cy CoG y offset in meters
     * @param cz CoG z offset in meters
     * @param inertia The payload inertia matrix in kg*m^2, elements lxx,lyy
     * lzz, lxy, lxz, lyz
     * @return this object.
     */
    setTargetPayload(mass: string | number, cx: string | number, cy: string | number, cz: string | number, inertia?: [number, number, number, number, number, number]): ScriptBuilder;
    /**
     * Set the direction of the acceleration experienced by the robot.
     *
     * @param x x m/s^2
     * @param y y m/s^2
     * @param z z m/s^2
     */
    setGravity(x: string | number, y: string | number, z: string | number): ScriptBuilder;
    /**
     * @description Add a call function which specifies the desired TCP
     * @param x x length
     * @param y y length
     * @param z z length
     * @param rx rx angle
     * @param ry ry angle
     * @param rz rz angle
     * @param name Name of the TCP
     */
    setTcp(x: number | string, y: number | string, z: number | string, rx: number | string, ry: number | string, rz: number | string, name?: string): ScriptBuilder;
    /**
     * Append the content of another script builder to
     * this script builder
     *
     * @param scriptBuilder
     */
    append(scriptBuilder: ScriptBuilder): ScriptBuilder;
    /**
     * The terminal operation that generates the as string containing the UR Script.
     *
     * @return the string that contains the UR Script.
     */
    getScript(): string;
    /**
     * Get the current indention level of this ScriptBuilder.
     *
     * @return the indention level as a number.
     */
    getIndention(): number;
    /**
     * Increase the indent.
     */
    private increaseIndent;
    /**
     * Decrease the indent.
     */
    private decreaseIndent;
}
