import { floatOperator, Frame, MovementType, NodeType, ProgramNode, registerOperator, TCPName, URFunction, URVariable } from '../..';
import { TabInputModel } from '../../../common';
import { SignalValueTypeEnum } from '../../../sources';
import { Acceleration, Current, Length, Speed, Value, Voltage } from '../../../values';
export type DirectionSignalValue = Current | Voltage | number;
export interface DirectionNode extends ProgramNode {
    type: NodeType.DIRECTION;
    parameters: {
        name: TabInputModel<URVariable | undefined>;
        motionProfile: string | undefined;
        frame: Frame;
        axis: DirectionalAxis;
        advanced: DirectionAdvancedSettings;
    };
}
export interface DirectionAdvancedSettings {
    movement: DirectionMovementSettings;
    reference: DirectionReferenceSettings;
    until: DirectionUntilSettings;
}
export interface DirectionMovementSettings {
    speedType: MovementType;
    speed: TabInputModel<Speed>;
    acceleration: TabInputModel<Acceleration>;
    optiMoveSpeed: TabInputModel<Value>;
    optiMoveAcceleration: TabInputModel<Value>;
}
export interface DirectionReferenceSettings {
    tcp?: TCPName;
}
export interface DirectionUntilSettings {
    conditions: UntilCondition<ConditionParams>[];
}
export interface UntilCondition<T extends ConditionParams> {
    index: number;
    type?: UntilConditionType;
    parameters: T;
    moduleFunction?: DirectionModuleFunc;
}
export interface DirectionNodeSignalInput {
    groupId?: string;
    sourceID?: string;
    signalID?: string;
    floatOperator?: floatOperator;
    registerOperator?: registerOperator;
    digitalValue?: boolean;
    analogValue?: TabInputModel<DirectionSignalValue>;
    registerValue?: number;
    signalValueType?: SignalValueTypeEnum;
}
export declare enum UntilConditionType {
    EXPRESSION = "expression",
    CONTACT = "contact",
    DISTANCE = "distance",
    SIGNAL = "signal"
}
export interface ExpressionParameters {
    value: string;
}
export interface ContactParameters {
    retract: TabInputModel<Length>;
    decelerate: TabInputModel<Acceleration>;
    moveToContactPoint: boolean;
}
export interface DistanceParameters {
    distance: TabInputModel<Length>;
}
export interface SignalParameters {
    signalInput: DirectionNodeSignalInput;
}
export interface DirectionModuleFunc {
    module: string;
    function: URFunction;
}
export type ConditionParams = ExpressionParameters | ContactParameters | DistanceParameters | SignalParameters;
export declare const DirectionalPositionAxes: readonly ["Y+", "Y-", "X+", "X-", "Z+", "Z-"];
export type DirectionalAxis = (typeof DirectionalPositionAxes)[number];
export declare function getDirectionalVector(axis: DirectionalAxis): string;
