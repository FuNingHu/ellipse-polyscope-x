import { ScriptBuilder } from '../../scriptBuilder';
import { LifeCycleEvent, ProgramLabel } from '../common';
import { ValidationResponse } from '../common/validation-response';
import { ApplicationContext, InsertionContext, ScriptContext, SubtreeNode, ValidationContext } from '../context';
import { BranchNode, ProgramNode } from '../nodes';
import { OptionalPromise } from './optional.promise';
/**
 * NodeFactory is a function that returns an instance of the node type
 */
export type NodeFactory<T> = () => OptionalPromise<T | BranchNode>;
/**
 * CodeGenerator is a function that generates the code for the node
 *
 * @param node The ProgramNode to generate code for
 * @param context The Context object providing access to other nodes
 * @param applicationContext Provides access to application specific configuration
 * @returns A ScriptBuilder containing the generated script code
 */
export type CodeGenerator<T> = (node: T, context: ScriptContext, applicationContext: ApplicationContext) => OptionalPromise<ScriptBuilder>;
/**
 * Validator function that takes a ProgramNode and validates it
 * @param node A ProgramNode to validate
 * @param context Context for tree traversing
 * @param applicationContext Provides access to application specific configuration
 * @returns
 */
export type Validator<T> = (node: T, context: ValidationContext, applicationContext: ApplicationContext) => OptionalPromise<ValidationResponse>;
/**
 * ProgramNodeLabel function that takes a ProgramNode and returns a label for the tree
 * @param node The node to generate the label for
 * @returns the label for the node
 */
export type ProgramNodeLabel<T> = (node: T) => OptionalPromise<ProgramLabel>;
/**
 * ChildInsertionRule function defines if a given parent can have a child of the given type
 * @param parent The programNode that becomes parent, for the newly inserted child, if the operation is allowed
 * @param childType Type of node to insert.
 * @returns true if the insertion operation succeeded
 */
export type ChildInsertionRule = (parent: ProgramNode, childType: string) => OptionalPromise<boolean>;
/**
 * ContextInsertionRule function defines if a program node can be inserted in the given context
 * @param context InsertionContext providing access to surrounding tree nodes, where the node would be inserted
 * @returns whether the node is allowed to be inserted
 */
export type ContextInsertionRule = (context: InsertionContext) => OptionalPromise<boolean>;
/**
 * A function that can be used to move between versions of a program node
 */
export type ProgramVersionController<T> = (loadedNode: T) => OptionalPromise<T>;
/**
 * ProgramNodeLifeCycleEventType is a string that describes the lifecycle event that is being triggered
 */
export type ProgramNodeLifeCycleEventType = 'delete' | 'paste' | 'suppress' | 'unsuppress' | 'copy';
/**
 * ProgramBehaviors describes the possible behaviors defined by program node.
 * The object will be registered by calling {@link registerProgramBehavior}
 *
 */
export type ProgramBehaviors<ProgramNodeSubtype extends ProgramNode = ProgramNode> = {
    factory: NodeFactory<ProgramNodeSubtype>;
    programNodeLabel: ProgramNodeLabel<ProgramNodeSubtype>;
    generateCodeBeforeChildren?: CodeGenerator<ProgramNodeSubtype>;
    generateCodeAfterChildren?: CodeGenerator<ProgramNodeSubtype>;
    generateCodePreamble?: CodeGenerator<ProgramNodeSubtype>;
    validator?: Validator<ProgramNodeSubtype>;
    allowsChild?: ChildInsertionRule;
    allowedInContext?: ContextInsertionRule;
    upgradeNode?: ProgramVersionController<ProgramNodeSubtype>;
    onLifeCycleHook?: LifeCycleEvent<ProgramNodeLifeCycleEventType, SubtreeNode>;
};
