import { Observable } from 'rxjs';
import { ScriptBuilder } from '../../scriptBuilder';
import { SignalFilter } from '../../services';
import { ValidationResponse } from '../common';
import { SignalValue, SourcesNode } from '../nodes';
import { Signal, SignalEvent, Source } from '../sources';
import { ValueRange } from '../values';
import { OptionalPromise } from './optional.promise';
/**
 * A function which returns a new instance of a SourcesNode
 */
export type SourcesNodeFactory = () => OptionalPromise<SourcesNode>;
/**
 * A function which generates the script code required to get
 * the value of a signal.
 */
export type GetSignalCodeGenerator = (source: Source, signal: Signal) => OptionalPromise<ScriptBuilder>;
/**
 * A function which generates the script code require to set
 * the value of a signal.
 */
export type SetSignalCodeGenerator = (source: Source, signal: Signal, value: SignalValue) => OptionalPromise<ScriptBuilder>;
/**
 * A function called whenever an application containing the node is loaded
 */
export type OnSourceLoadHook = (node: SourcesNode) => void;
/**
 * A function that can be used to create a script builder for source code
 */
export type SourceCodeGenerator = (node: SourcesNode) => OptionalPromise<ScriptBuilder>;
/**
 * A function for continuously publishing the values of signals
 * NB: Must send current state on subscribe
 */
export type ValuePublisher = (sourceID: string, signalFilter?: SignalFilter) => Observable<SignalEvent>;
/**
 * A function for setting the value of a given signal
 */
export type ValueSetter = (sourceID: string, signalID: string, value: SignalValue) => void;
/**
 * A function for moving between versions of a sources node
 */
export type SourcesVersionController = (loadedNode: SourcesNode) => OptionalPromise<SourcesNode>;
/**
 * Callback function for when the data model of a sources node changes
 */
export type SourcesNodeChange = (node: SourcesNode) => void;
/**
 * A function for adding/removing sources
 */
export type SourcesFactory = (sourceName: string) => OptionalPromise<Source>;
/**
 * Generates a label for a given SourcesNode.
 * @param node The SourcesNode for which the label is generated.
 * @returns A promise that resolves to the generated label.
 */
export type SourcesNodeLabel = (node: SourcesNode) => OptionalPromise<string>;
/**
 * Returns info about the signals for a given source
 * It is used by the set and wait node to give the units and range limits for
 * analog signals
 * @param node The SourcesNode for which the info will be generated
 * @param sourceID The ID of the source for the signals
 * @returns A map of signal ID to SignalDomainData
 */
export type SignalsDomainDataGenerator = (node: SourcesNode, sourceID: string) => OptionalPromise<Record<string, ValueRange>>;
/**
 *  Validates that the values will be okay for creating a set
 */
export type SetSignalValidator = (sourceID: string, signalID: string, value: SignalValue) => OptionalPromise<ValidationResponse>;
/**
 *  Validates that the values will be okay for creating a get
 */
export type GetSignalValidator = (sourceID: string, signalID: string, value: SignalValue, operator: string) => OptionalPromise<ValidationResponse>;
/**
 * SourceBehaviors describes the possible behaviors defined by the source.
 * The object will be registered by calling {@link registerSourceBehavior}
 */
export type SourceBehaviors = {
    factory?: SourcesNodeFactory;
    generateSetSignal?: SetSignalCodeGenerator;
    generateGetSignal?: GetSignalCodeGenerator;
    onLoad?: OnSourceLoadHook;
    generatePreamble?: SourceCodeGenerator;
    getSignalUpdates?: ValuePublisher;
    onSourcesChange?: SourcesNodeChange;
    upgradeNode?: SourcesVersionController;
    setSignalValue?: ValueSetter;
    generateLabel?: SourcesNodeLabel;
    generateSignalsDomainData?: SignalsDomainDataGenerator;
    validateSetSignal?: SetSignalValidator;
    validateGetSignal?: GetSignalValidator;
};
/**
 * Describing possible behaviours of a dynamic sources node
 */
export type DynamicSourceBehaviors = SourceBehaviors & {
    generateSource: SourcesFactory;
};
