import { Observable } from 'rxjs';
import { FunctionsMap, GlobalVariable, URFunction, URLogicProgram, URModule, URSymbolType, URVariable, VariableValueType } from '../../types/nodes';
import { EventTargetOrCommChannel, MessageInvokerService } from '../message-invoker';
export declare const SYMBOL_SERVICE_MESSAGE_TYPE_BASE = "ur.web.message.SymbolService.";
/**
 * Service for generating and getting reserved variable names
 */
export declare class SymbolService extends MessageInvokerService {
    readonly eventTarget: EventTargetOrCommChannel;
    /**
     * Create a service for the specific worker
     * @param eventTarget
     */
    constructor(eventTarget: EventTargetOrCommChannel);
    /**
     * Get a list of available variables
     * @returns
     */
    getVariables(): Promise<Array<URVariable>>;
    /**
     * Get an observable of available variables
     */
    variables(): Observable<Array<URVariable>>;
    /**
     * Returns a list of the global variables as a stream.
     * @returns {Observable<Array<GlobalVariable>>} Observable of global variables object
     */
    globalVariables(): Observable<Array<GlobalVariable>>;
    /**
     * Generates a new variable. The variable name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName The intended name for the variable, will be suffixed if the name is already taken
     * @param valueType The ValueType of the variable
     * @param blacklist Optional parameter to provide additional names which shouldn't be used.
     */
    generateVariable(suggestedName: string, valueType: VariableValueType, blacklist?: Array<string>): Promise<URVariable>;
    /**
     * Return true if the provided name is the name of a registered variable
     *
     * @param variableName
     */
    isRegisteredVariableName(variableName: string): Promise<boolean>;
    /**
     * Get a list of available functions for the given module name. If no name provided, functions for the global scope
     * @param moduleName
     * @returns
     */
    getFunctions(moduleName?: string): Promise<URFunction[]>;
    /**
     * Get functions map. Contains a list of functions for each module name. Note: Empty string is the global scope.
     * @param filter Filter on if the function is async or not
     * is async or not
     * @returns
     */
    getFunctionsMap(filter?: {
        filterAsync?: boolean;
    }): Promise<FunctionsMap>;
    /**
     * Generates a new function. The function name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName
     * @param moduleName
     */
    generateFunction(suggestedName: string, moduleName?: string): Promise<URFunction>;
    /**
     * Return true if the provided name is the name of a registered function
     *
     * @param functionName
     * @param moduleName
     */
    isRegisteredFunctionName(functionName: string, moduleName?: string): Promise<boolean>;
    /**
     * Get a list of available modules
     * @returns
     */
    getModuleNames(): Promise<Array<string>>;
    /**
     * Generates a new module. The module name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName
     */
    generateModule(suggestedName: string): Promise<URModule>;
    /**
     * Return true if the provided name is the name of a registered module
     *
     * @param moduleName
     */
    isRegisteredModuleName(moduleName: string): Promise<boolean>;
    /**
     * Get a list of available Logic Programs
     * @returns
     */
    getLogicProgramNames(): Promise<Array<string>>;
    /**
     * Generates a new Logic Program. The program name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName
     */
    generateLogicProgram(suggestedName: string): Promise<URLogicProgram>;
    /**
     * Return true if the provided name is the name of a registered Logic Program
     *
     * @param logicProgramName
     */
    isRegisteredLogicProgramName(logicProgramName: string): Promise<boolean>;
    /**
     *  Return true if the provided name is a registered name of the given type.
     * @param name
     * @param type
     * @param moduleName
     * @param unique
     * @returns
     */
    isRegisteredName(name: string, type: URSymbolType, moduleName?: string, unique?: boolean): Promise<boolean>;
    /**
     * Return true if the declaring program node is suppressed
     * @param name The name of the symbol
     * @param moduleName The module of the symbol if defined
     * @return Boolean describing if the declaring node is suppressed
     */
    isSuppressed(name: string, moduleName?: string): Promise<boolean>;
    /**
     * Get the URVariable with the given name
     * @return URVariable with the given name
     * @param name Name of the variable to get
     */
    getVariable(name: string): Promise<URVariable | undefined>;
    /**
     *
     * @param variableName name of the variable being validated
     * @param acceptedTypes an optional array of valid type strings, e.g., float.
     * @returns true if the variable is registered not suppressed, and is of a valid value type
     */
    isValidVariable(variableName: string, acceptedTypes?: string[]): Promise<boolean>;
    /**
     * Return true if the function is a thread
     * @param functionName The name of the function
     * @param moduleName The module of the symbol if defined
     * @return Boolean describing if the function is a thread
     */
    isAsyncFunction(functionName: string, moduleName?: string): Promise<boolean>;
}
