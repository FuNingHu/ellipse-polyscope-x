import { Guid } from 'guid-typescript';
import { Subject, firstValueFrom, map, merge, filter, take, throwError, of } from 'rxjs';
import { finalize, map as map$1, tap, switchMap } from 'rxjs/operators';
import { Md5 } from 'ts-md5';
import { Quaternion, Vector3, Euler, Matrix4 } from 'three';
import { expose } from 'threads/worker';
import { registerSerializer } from 'threads';
import { SelectedInput } from '@universal-robots/ui-models';
import { degreesCelsius, kgMSq, W, s, rad, ms, mm, mV, mA, m, deg, V, N, A, radPerSecSq, radPerSec, mmPerSecSq, mmPerSec, mPerSecSq, mPerSec, degPerSecSq, degPerSec, kgMPerSec, kgM, kg, g, FixedPointNumber, converter } from '@universal-robots/utilities-units';

const UNSUBSCRIBE_MESSAGE_TYPE = 'ur.web.message.unsubscribeUpdates';
/**
 *
 */
class UREventTarget extends EventTarget {
    /**
     *
     * @param name
     */
    constructor(options) {
        super();
        this.name = options?.name || Md5.hashStr(`${options?.values?.join('')}${options?.salt}`);
    }
}
/**
 * returns true if the item is a worker type
 * @param item
 */
function isWorkerScope(item) {
    return item.postMessage && typeof item.postMessage === 'function';
}
/**
 * Abstract interface for communication within PSX
 *
 * This class is an internal implementation detail used by higher-level contribution APIs.
 */
class CommunicationChannel {
    constructor() {
        this.requestResponders = new Map();
        this.observerResponders = new Map();
    }
    /**
     *
     */
    triggerRequestResponse(event, responder) {
        if (event.data.error) {
            responder.reject(event.data.error);
        }
        else {
            responder.resolve(event.data.data);
        }
    }
    /**
     *
     */
    triggerObserverResponse(event, responder) {
        if (event.data.error) {
            responder.error(event.data.error);
        }
        else {
            responder.next(event.data.data);
        }
    }
    /**
     *
     */
    handleMessage(event) {
        const responder = this.requestResponders.get(event.data.id);
        if (responder) {
            this.triggerRequestResponse(event, responder);
            this.requestResponders.delete(event.data.id);
            return;
        }
        const observerResponder = this.observerResponders.get(event.data.id);
        if (observerResponder) {
            this.triggerObserverResponse(event, observerResponder);
        }
    }
    /**
     *
     */
    requestInternal(sender, type, name, data = {}) {
        const id = Guid.raw();
        const promise = new Promise((resolve, reject) => {
            this.requestResponders.set(id, { resolve, reject });
        });
        const message = {
            type,
            data,
            id,
        };
        if (name) {
            message.name = name;
        }
        sender(message);
        return promise;
    }
    /**
     *
     */
    requestObserveInternal(sender, finalizeFunc, type, data = {}) {
        const id = Guid.raw();
        const response$ = new Subject();
        this.observerResponders.set(id, response$);
        const message = {
            type,
            data: {
                ...data,
            },
            id,
        };
        sender(message);
        return response$.pipe(finalize(() => finalizeFunc(id)));
    }
    /**
     *
     */
    unsubscribeFinalized(id) {
        this.observerResponders.delete(id);
    }
}
/**
 * Communication implementation for workers in PSX
 *
 * This class is an internal implementation detail used by higher-level contribution APIs.
 */
class WorkerCommunicationChannel extends CommunicationChannel {
    /**
     *
     */
    constructor(worker) {
        super();
        this.worker = worker;
        this.id = Guid.raw();
        this.messageChannel = new MessageChannel();
        this.portToMainThread = this.messageChannel.port1;
        this.portToMainThread.addEventListener('message', (event) => {
            this.handleMessage(event);
        });
        this.portToMainThread.start();
        worker.postMessage({ type: 'handshake' }, [this.messageChannel.port2]);
    }
    /**
     *
     */
    request(type, data = {}) {
        return this.requestInternal((message) => {
            this.dispatchWorkerEvent(message);
        }, type, this.worker.name, data);
    }
    /**
     *
     */
    dispatchWorkerEvent(message) {
        this.portToMainThread.postMessage(message);
    }
    /**
     *
     */
    unsubscribeOnFinalized(id) {
        this.unsubscribeFinalized(id);
        const unsubscribeMessage = {
            type: UNSUBSCRIBE_MESSAGE_TYPE,
            data: { id },
        };
        this.portToMainThread.postMessage(unsubscribeMessage);
    }
    /**
     * returns an observable that will emit any messages replied to the specified message
     *
     * @param type The type of message being sent
     * @param data The message data
     */
    requestObserve(type, data = {}) {
        return this.requestObserveInternal((message) => {
            this.dispatchWorkerEvent(message);
        }, (id) => this.unsubscribeOnFinalized(id), type, data);
    }
}
/**
 * Communication implementation for presenters in PSX
 *
 * This class is an internal implementation detail used by higher-level contribution APIs.
 */
class EventTargetCommunicationChannel extends CommunicationChannel {
    /**
     *
     */
    constructor(eventTarget) {
        super();
        this.eventTarget = eventTarget;
        if (isWorkerScope(this.eventTarget)) {
            throw new Error('Use WorkerCommunicationChannel for communication with workers');
        }
    }
    /**
     *
     */
    request(type, data = {}) {
        const id = Guid.raw();
        return new Promise((resolve, reject) => {
            this.eventTarget.addEventListener(`reply_${type}_${id}`, (event) => {
                resolve(event.data.data);
            }, { once: true, passive: true });
            const message = {
                type,
                data,
                id,
            };
            const name = this.eventTarget?.name || self.name;
            if (name) {
                message.name = name;
            }
            this.dispatchTargetEvent(message);
        });
    }
    /**
     *
     */
    dispatchTargetEvent(message) {
        this.eventTarget.dispatchEvent(new MessageEvent('message', { data: message }));
    }
    /**
     *
     */
    unsubscribeOnFinalized(type, id, callback) {
        this.eventTarget.removeEventListener(`reply_${type}_${id}`, callback);
        const unsubscribeMessage = {
            type: UNSUBSCRIBE_MESSAGE_TYPE,
            data: { id },
        };
        this.eventTarget.dispatchEvent(new MessageEvent('message', { data: unsubscribeMessage }));
    }
    /**
     * returns an observable that will emit any messages replied to the specified message
     *
     * @param type The type of message being sent
     * @param data The message data
     */
    requestObserve(type, data = {}) {
        const id = Guid.raw();
        const response$ = new Subject();
        /**
         *
         */
        const callback = (event) => {
            if (response$.observed) {
                response$.next(event.data.data);
            }
        };
        this.eventTarget.addEventListener(`reply_${type}_${id}`, callback, {
            passive: true,
        });
        const message = {
            type,
            data: {
                ...data,
            },
            id,
        };
        this.dispatchTargetEvent(message);
        return response$.pipe(finalize(() => this.unsubscribeOnFinalized(type, id, callback)));
    }
}
/**
 * returns true if the item is a CommunicationChannel type
 * @param item
 */
function isCommunicationChannel(item) {
    return item.request && typeof item.request === 'function';
}
/**
 * Creates a WorkerCommunicationChannel
 * @param target
 */
function createWorkerCommChannel(target) {
    let communicationChannel;
    if (isCommunicationChannel(target)) {
        communicationChannel = target;
    }
    else {
        communicationChannel = new WorkerCommunicationChannel(target);
    }
    return communicationChannel;
}
/**
 * Creates a EventTargetCommunicationChannel
 * @param target
 */
function createEventTargetCommChannel(target) {
    let communicationChannel;
    if (isCommunicationChannel(target)) {
        communicationChannel = target;
    }
    else {
        communicationChannel = new EventTargetCommunicationChannel(target);
    }
    return communicationChannel;
}
/**
 * Base class for invoking messages
 */
class MessageInvokerService {
    /**
     * @constructor
     * @param messageBase
     * @param eventTarget
     */
    constructor(messageBase, eventTarget) {
        this.messageBase = messageBase;
        this.eventTarget = eventTarget;
        if (isCommunicationChannel(eventTarget)) {
            this.communicationChannel = eventTarget;
        }
        else {
            if (isWorkerScope(eventTarget)) {
                this.communicationChannel = new WorkerCommunicationChannel(eventTarget);
            }
            else {
                this.communicationChannel = new EventTargetCommunicationChannel(eventTarget);
            }
        }
    }
    /**
     * returns a reply promise for the requested message
     *
     * @param type The type of message being sent
     * @param data The message data
     */
    request(type, data = {}) {
        return this.communicationChannel.request(this.messageBase + type, data);
    }
    /**
     * returns an observable that will emit any messages replied to the requested message
     *
     * @param type The type of message being sent
     * @param data The message data
     */
    requestObserve(type, data = {}) {
        return this.communicationChannel.requestObserve(this.messageBase + type, data);
    }
    /**
     * returns a reply promise to the specified message
     *
     * @param type The type of message being sent
     * @param data The message data
     */
    postAndAwait(type, data = {}) {
        return this.communicationChannel.request(this.messageBase + type, data);
    }
    /**
     * returns an observable that will emit any messages replied to the specified message
     *
     * @param type The type of message being sent
     * @param data The message data
     */
    postAndObserve(type, data = {}) {
        return this.communicationChannel.requestObserve(this.messageBase + type, data);
    }
}

const APPLICATION_NODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ApplicationNodeService.';
/**
 * Service that handles updating application nodes
 */
class ApplicationNodeService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(APPLICATION_NODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Update the program node
     * @param node New program node state
     */
    async updateNode(node) {
        return this.postAndAwait('updateNode', node);
    }
}

/**
 * Defines the types of URSymbols
 */
var URSymbolType;
(function (URSymbolType) {
    URSymbolType["Variable"] = "$$Variable";
    URSymbolType["Function"] = "$$Function";
    URSymbolType["Module"] = "$$Module";
    URSymbolType["LogicProgram"] = "$$LogicProgram";
})(URSymbolType || (URSymbolType = {}));
/**
 * Defines abstract symbol class used by URSymbolService
 */
class URSymbol {
    /**
     *  Create new URSymbol
     * @param name
     * @param reference
     */
    constructor(name, reference = false) {
        this.name = name;
        this.reference = reference;
    }
}
/**
 * Definition of variable used for discovering variables in the tree node parameters
 */
class URVariable extends URSymbol {
    /**
     *  Create new URVariable
     * @param name
     * @param valueType
     * @param reference
     */
    constructor(name, valueType, reference = false) {
        super(name, reference);
        this.type = URSymbolType.Variable;
        this.valueType = valueType;
    }
}
/**
 * Defines the ValueTypes that can be assigned to a variable.
 */
var VariableValueType;
(function (VariableValueType) {
    VariableValueType["BOOLEAN"] = "boolean";
    VariableValueType["FLOAT"] = "float";
    VariableValueType["INTEGER"] = "integer";
    VariableValueType["POSE"] = "pose";
    VariableValueType["STRING"] = "string";
    VariableValueType["MATRIX"] = "matrix";
    VariableValueType["ARRAY"] = "array";
    VariableValueType["WAYPOINT"] = "waypoint";
    VariableValueType["GRID"] = "grid";
    VariableValueType["FRAME"] = "frame";
    VariableValueType["TIMER"] = "timer";
    VariableValueType["PROFILE"] = "profile";
})(VariableValueType || (VariableValueType = {}));
/**
 * Definition of Logic Program
 */
class URLogicProgram extends URSymbol {
    constructor() {
        super(...arguments);
        this.type = URSymbolType.LogicProgram;
    }
}
/**
 * Definition of function
 */
class URFunction extends URSymbol {
    constructor() {
        super(...arguments);
        this.type = URSymbolType.Function;
    }
}
/**
 * Definition of Module
 */
class URModule extends URSymbol {
    constructor() {
        super(...arguments);
        this.type = URSymbolType.Module;
    }
}
/**
 * Check if item is a URSymbol
 * @param item
 * @returns
 */
function isURSymbol(item) {
    return (!!item &&
        Object.prototype.hasOwnProperty.call(item, 'name') &&
        Object.prototype.hasOwnProperty.call(item, 'type') &&
        Object.values(URSymbolType).includes(item.type));
}
/**
 * TypeGuard to verify whether a given object is a variable
 * @param item The item to be interrogated
 */
function isVariable(item) {
    return isURSymbol(item) && item.type === URSymbolType.Variable;
}
/**
 * TypeGuard to verify whether a given object is a function
 * @param item The item to be interrogated
 */
function isFunction(item) {
    return isURSymbol(item) && item.type === URSymbolType.Function;
}
/**
 * TypeGuard to verify whether a given object is a module
 * @param item The item to be interrogated
 */
function isModule(item) {
    return isURSymbol(item) && item.type === URSymbolType.Module;
}
/**
 * TypeGuard to verify whether a given object is a logic program
 * @param item The item to be interrogated
 */
function isLogicProgram(item) {
    return isURSymbol(item) && item.type === URSymbolType.LogicProgram;
}

/** Describes the various axes used to define poses in the application. */
/** Position */
/**  Constant array of the position axes. */
const PositionAxes = ['x', 'y', 'z'];
/** Orientation */
/** Constant array of the orientation axes. */
const OrientationAxes = ['rx', 'ry', 'rz'];
/** Center of Gravity */
/** Constant array of the center of gravity axes. */
const CenterOfGravityAxes = ['cx', 'cy', 'cz'];
/** Pose */
/** Constant array of the combination of a position and an orientation into a pose. */
const PoseAxes = [...PositionAxes, ...OrientationAxes];

/** Position */
/**  Constant array of the InertiaMatrixKeys. */
const InertiaMatrixKeys = ['Ixx', 'Iyy', 'Izz', 'Ixy', 'Ixz', 'Iyz'];

/**
 * Checks if the value implements ReferenceItem
 */
const isReferenceItem = (value) => {
    return value.type === 'Reference';
};
/**
 * Checks if the value implements ValueItem
 */
const isValueItem = (value) => {
    return value.type === 'Value';
};

/**
 * A type guard to check if an object is a JointPositions
 */
function isJointPositions(jp) {
    return (jp.base !== undefined &&
        jp.shoulder !== undefined &&
        jp.elbow !== undefined &&
        jp.wrist1 !== undefined &&
        jp.wrist2 !== undefined &&
        jp.wrist3 !== undefined);
}

/**
 * A type guard to check if an object is a KinematicPosition
 */
function iskinematicPosition(kinematicPosition) {
    return (kinematicPosition?.jointVector !== undefined &&
        kinematicPosition?.links !== undefined &&
        kinematicPosition?.tcp !== undefined);
}

/**
 * OperatorInputType enum
 */
var OperatorInputType;
(function (OperatorInputType) {
    OperatorInputType["INPUT"] = "input";
    OperatorInputType["MESSAGE"] = "message";
})(OperatorInputType || (OperatorInputType = {}));

/**
 * PopupLevel enum
 */
var PopupLevel;
(function (PopupLevel) {
    PopupLevel["ERROR"] = "error";
    PopupLevel["WARNING"] = "warning";
    PopupLevel["INFO"] = "info";
})(PopupLevel || (PopupLevel = {}));

/**
 * Implementation
 */
function zUpPositionMeters(value1, value2, value3) {
    if (value1 === undefined) {
        return { zUpPositionMeters: [0, 0, 0] };
    }
    else {
        return { zUpPositionMeters: [value1, value2, value3] };
    }
}
/**
 * Implementation
 */
function yUpPositionMeters(value1, value2, value3) {
    if (value1 === undefined) {
        return { yUpPositionMeters: [0, 0, 0] };
    }
    else {
        return { yUpPositionMeters: [value1, value2, value3] };
    }
}
const X_AXIS_90_DEG_ROTATION = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2);
const X_AXIS_NEG_90_DEG_ROTATION = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
/**
 * Transforms a Z-up quaternion to Y-up coordinate system.
 */
function transformZUpQuaternionToYUp(zUpQuaternion) {
    return new Quaternion().multiplyQuaternions(X_AXIS_NEG_90_DEG_ROTATION, zUpQuaternion);
}
/**
 * Transforms a Y-up quaternion to Z-up coordinate system.
 */
function transformYUpQuaternionToZUp(yUpQuaternion) {
    return new Quaternion().multiplyQuaternions(X_AXIS_90_DEG_ROTATION, yUpQuaternion);
}
// this code is copied from Quat4d in controller/general/math/Quat4d
/**
 * Converts a quaternion to rotation vector representation.
 */
function getRotationVectorRadiansFromQuaternion(x, y, z, w) {
    let norm = x * x + y * y + z * z;
    const axis = [0, 0, 0];
    if (norm > 1e-8) {
        norm = Math.sqrt(norm);
        const angle = 2 * Math.atan2(norm, w);
        const invnorm = 1 / norm;
        axis[0] = x * invnorm * angle;
        axis[1] = y * invnorm * angle;
        axis[2] = z * invnorm * angle;
    }
    return zUpRotationVectorRadians(...axis);
}
/**
 * Implementation
 */
function yUpEulerRotationRadians(value1, value2, value3) {
    if (value1 === undefined) {
        return { yUpEulerRotationRadians: [0, 0, 0] };
    }
    else {
        return { yUpEulerRotationRadians: [value1, value2, value3] };
    }
}
/**
 * Implementation
 */
function zUpEulerRotationRadians(value1, value2, value3) {
    if (value1 === undefined) {
        return { zUpEulerRotationRadians: [0, 0, 0] };
    }
    else {
        return { zUpEulerRotationRadians: [value1, value2, value3] };
    }
}
/**
 * Implementation
 */
function zUpRotationVectorRadians(value1, value2, value3) {
    if (value1 === undefined) {
        return { zUpRotationVectorRadians: [0, 0, 0] };
    }
    else {
        return { zUpRotationVectorRadians: [value1, value2, value3] };
    }
}
/**
 * Implementation
 */
function yUpQuaternion(value1, value2, value3, value4) {
    if (value1 === undefined) {
        return { yUpQuaternion: [0, 0, 0, 1] };
    }
    else {
        return { yUpQuaternion: [value1, value2, value3, value4] };
    }
}
/**
 * Converts rotation representation to raw Z-up rotation vector array.
 * Internal helper function for converting various rotation formats to Z-up rotation vector format.
 */
function asZUpRotationVectorRadiansRaw(value) {
    if ('zUpRotationVectorRadians' in value) {
        return value.zUpRotationVectorRadians;
    }
    else if ('zUpEulerRotationRadians' in value) {
        const q = new Quaternion().setFromEuler(new Euler(...value.zUpEulerRotationRadians));
        q.normalize();
        const a = Math.acos(q.w);
        let v = new Vector3(q.x, q.y, q.z);
        if (v.length() > 1.0e-7) {
            v.normalize();
        }
        else {
            v = new Vector3(0, 0, 0);
        }
        v.multiplyScalar(2 * a);
        return [v.x, v.y, v.z];
    }
    else if ('yUpQuaternion' in value) {
        return asZUpRotationVectorRadiansRaw(PoseUtils.asZUpEulerRotationRadians(value));
    }
    else if ('yUpEulerRotationRadians' in value) {
        return asZUpRotationVectorRadiansRaw(PoseUtils.asZUpEulerRotationRadians(value));
    }
    else if (isRosQuaternion(value)) {
        return getRotationVectorRadiansFromQuaternion(value.x, value.y, value.z, value.w).zUpRotationVectorRadians;
    }
    else {
        return [0, 0, 0];
    }
}
/**
 * Converts rotation representation to raw Z-up Euler rotation array.
 * Internal helper function for converting various rotation formats to Z-up Euler angles.
 */
function asZUpEulerRotationRadiansRaw(value) {
    if ('zUpEulerRotationRadians' in value) {
        return value.zUpEulerRotationRadians;
    }
    else if ('zUpRotationVectorRadians' in value) {
        const n = new Vector3(...value.zUpRotationVectorRadians);
        const ang = n.length();
        n.normalize();
        n.multiplyScalar(Math.sin(ang / 2));
        const euler = new Euler().setFromQuaternion(new Quaternion(n.x, n.y, n.z, Math.cos(ang / 2)));
        return [euler.x, euler.y, euler.z];
    }
    else if ('yUpQuaternion' in value) {
        return asZUpEulerRotationRadiansRaw(PoseUtils.asYUpEulerRotationRadians(value));
    }
    else if ('yUpEulerRotationRadians' in value) {
        const yUpQuaternion = new Quaternion().setFromEuler(new Euler(...value.yUpEulerRotationRadians));
        const zUpQuaternion = transformYUpQuaternionToZUp(yUpQuaternion);
        const zUpEuler = new Euler().setFromQuaternion(zUpQuaternion);
        return [zUpEuler.x, zUpEuler.y, zUpEuler.z];
    }
    else {
        return [0, 0, 0];
    }
}
/**
 * Converts rotation representation to raw Y-up Euler rotation array.
 * Internal helper function for converting various rotation formats to Y-up Euler angles.
 */
function asYUpEulerRotationRadiansRaw(value) {
    if ('yUpEulerRotationRadians' in value) {
        return value.yUpEulerRotationRadians;
    }
    else if ('zUpEulerRotationRadians' in value) {
        const zUpQuaternion = new Quaternion().setFromEuler(new Euler(...value.zUpEulerRotationRadians));
        const yUpQuaternion = transformZUpQuaternionToYUp(zUpQuaternion);
        const yUpEuler = new Euler().setFromQuaternion(yUpQuaternion);
        return [yUpEuler.x, yUpEuler.y, yUpEuler.z];
    }
    else if ('zUpRotationVectorRadians' in value) {
        return asYUpEulerRotationRadiansRaw(PoseUtils.asZUpEulerRotationRadians(value));
    }
    else if ('yUpQuaternion' in value) {
        const euler = new Euler().setFromQuaternion(new Quaternion(...value.yUpQuaternion));
        return [euler.x, euler.y, euler.z];
    }
    else {
        return [0, 0, 0];
    }
}
/**
 * Converts rotation representation to raw Y-up quaternion array.
 * Internal helper function for converting various rotation formats to Y-up quaternion format.
 */
function asYUpQuaternionRaw(value) {
    if ('yUpQuaternion' in value) {
        return value.yUpQuaternion;
    }
    else if ('zUpRotationVectorRadians' in value) {
        return asYUpQuaternionRaw(PoseUtils.asZUpEulerRotationRadians(value));
    }
    else if ('yUpEulerRotationRadians' in value) {
        const q = new Quaternion().setFromEuler(new Euler(...value.yUpEulerRotationRadians));
        q.normalize();
        return [q.x, q.y, q.z, q.w];
    }
    else if ('zUpEulerRotationRadians' in value) {
        return asYUpQuaternionRaw(PoseUtils.asYUpEulerRotationRadians(value));
    }
    else {
        return [0, 0, 0, 0];
    }
}
/**
 * Converts position representation to raw Z-up position array.
 * Internal helper function for converting various position formats to Z-up coordinate system.
 */
function asZUpPositionMetersRaw(value) {
    if ('zUpPositionMeters' in value) {
        return value.zUpPositionMeters;
    }
    else if ('yUpPositionMeters' in value) {
        return [value.yUpPositionMeters[0], -value.yUpPositionMeters[2], value.yUpPositionMeters[1]];
    }
    else if (isRosVector3(value)) {
        return [value.x, value.y, value.z];
    }
    else {
        return [0, 0, 0];
    }
}
/**
 * Converts position representation to raw Y-up position array.
 * Internal helper function for converting various position formats to Y-up coordinate system.
 */
function asYUpPositionMetersRaw(value) {
    if ('yUpPositionMeters' in value) {
        return value.yUpPositionMeters;
    }
    else if ('zUpPositionMeters' in value) {
        return [value.zUpPositionMeters[0], value.zUpPositionMeters[2], -value.zUpPositionMeters[1]];
    }
    else {
        return [0, 0, 0];
    }
}
/**
 * Utility class for converting between different pose and rotation representations.
 * Provides static methods to convert between coordinate systems (Z-up vs Y-up),
 * rotation formats (Euler, quaternion, rotation vector), and position formats.
 */
class PoseUtils {
    /**
     * Converts rotation representation to Z-up rotation vector format.
     * @param value - The rotation representation to convert
     * @returns Z-up rotation vector representation
     */
    static asZUpRotationVectorRadians(value) {
        return zUpRotationVectorRadians(...asZUpRotationVectorRadiansRaw(value));
    }
    /**
     * Converts rotation representation to Z-up Euler rotation format.
     * @param value - The rotation representation to convert
     * @returns Z-up Euler rotation representation
     */
    static asZUpEulerRotationRadians(value) {
        return zUpEulerRotationRadians(...asZUpEulerRotationRadiansRaw(value));
    }
    /**
     * Converts rotation representation to Y-up Euler rotation format.
     * @param value - The rotation representation to convert
     * @returns Y-up Euler rotation representation
     */
    static asYUpEulerRotationRadians(value) {
        return yUpEulerRotationRadians(...asYUpEulerRotationRadiansRaw(value));
    }
    /**
     * Converts rotation representation to Y-up quaternion format.
     * @param value - The rotation representation to convert
     * @returns Y-up quaternion representation
     */
    static asYUpQuaternion(value) {
        return yUpQuaternion(...asYUpQuaternionRaw(value));
    }
    /**
     * Converts position representation to Z-up position format.
     * @param value - The position representation to convert
     * @returns Z-up position representation
     */
    static asZUpPositionMeters(value) {
        return zUpPositionMeters(...asZUpPositionMetersRaw(value));
    }
    /**
     * Converts position representation to Y-up position format.
     * @param value - The position representation to convert
     * @returns Y-up position representation
     */
    static asYUpPositionMeters(value) {
        return yUpPositionMeters(...asYUpPositionMetersRaw(value));
    }
    /**
     * Converts pose representation to ThreeJS-compatible format (Y-up coordinate system).
     * @param value - The pose representation to convert
     * @returns ThreeJS pose representation with Y-up coordinates
     */
    static asThreeJsPose(value) {
        return {
            objectPosition: PoseUtils.asYUpPositionMeters(value.objectPosition),
            objectRotation: PoseUtils.asYUpEulerRotationRadians(value.objectRotation),
            referenceFrame: value.referenceFrame,
        };
    }
    /**
     * Converts pose representation to controller-compatible format (Z-up coordinate system).
     * @param value - The pose representation to convert
     * @returns Controller pose representation with Z-up coordinates
     */
    static asControllerPose(value) {
        return {
            objectPosition: PoseUtils.asZUpPositionMeters(value.objectPosition),
            objectRotation: PoseUtils.asZUpRotationVectorRadians(value.objectRotation),
            referenceFrame: value.referenceFrame,
        };
    }
    /**
     * Converts Y-up position to ThreeJS Vector3 object.
     * @param pos - Y-up position to convert
     * @returns ThreeJS Vector3 object
     */
    static asThreeJsVector3(pos) {
        return new Vector3().fromArray(pos.yUpPositionMeters);
    }
    /**
     * Converts rotation to ThreeJS Euler object.
     * @param rot - Rotation representation to convert
     * @returns ThreeJS Euler object with Y-up orientation
     */
    static asThreeJsEuler(rot) {
        return new Euler(...PoseUtils.asYUpEulerRotationRadians(rot).yUpEulerRotationRadians);
    }
    /**
     * Converts rotation to ThreeJS Quaternion object.
     * @param rot - Rotation representation to convert
     * @returns ThreeJS Quaternion object with Y-up orientation
     */
    static asThreeJsQuaternion(rot) {
        return new Quaternion(...PoseUtils.asYUpQuaternion(rot).yUpQuaternion);
    }
    /**
     * Create ControllerPose from Pose
     */
    static fromPose(pose, referenceFrame) {
        return controllerPose(zUpPositionMeters(...pose.position), zUpRotationVectorRadians(...pose.orientation), referenceFrame);
    }
    /**
     * Create Pose from ControllerPose
     */
    static asPose(pose) {
        return {
            position: [...pose.objectPosition.zUpPositionMeters],
            orientation: [...pose.objectRotation.zUpRotationVectorRadians],
        };
    }
    /**
     * Create ControllerPose from ROS transform or pose
     */
    static fromRos(transform, referenceFrame) {
        return {
            objectPosition: PoseUtils.asZUpPositionMeters(isRosPose(transform) ? transform.position : transform.translation),
            objectRotation: PoseUtils.asZUpRotationVectorRadians(isRosPose(transform) ? transform.orientation : transform.rotation),
            referenceFrame,
        };
    }
    /**
     * Create ThreeJsPose from Object3D in world frame
     */
    static fromObject3DInWorld(object) {
        const position = object.getWorldPosition(new Vector3());
        const euler = new Euler().setFromQuaternion(object.getWorldQuaternion(new Quaternion()));
        return threeJsPose(yUpPositionMeters(position.x, position.y, position.z), yUpEulerRotationRadians(euler.x, euler.y, euler.z), 'world');
    }
    /**
     * Create ControllerPose for identity pose in a given frame
     */
    static controllerPoseIdentityInFrame(referenceFrame) {
        return {
            objectPosition: zUpPositionMeters(),
            objectRotation: zUpRotationVectorRadians(),
            referenceFrame,
        };
    }
    /**
     * Create ThreeJsPose for identity pose in a given frame
     */
    static threeJsPoseIdentityInFrame(referenceFrame) {
        return {
            objectPosition: yUpPositionMeters(),
            objectRotation: yUpEulerRotationRadians(),
            referenceFrame,
        };
    }
}
/**
 * Type guard to distinguish between ROS pose and transform messages.
 */
function isRosPose(obj) {
    return 'position' in obj && 'orientation' in obj;
}
/**
 * Type guard to handle ROS point and vector3 messages.
 */
function isRosVector3(obj) {
    return 'x' in obj && 'y' in obj && 'z' in obj;
}
/**
 * Type guard to handle ROS point and vector3 messages.
 */
function isRosQuaternion(obj) {
    return 'x' in obj && 'y' in obj && 'z' in obj && 'w' in obj;
}
/**
 * Constructor for ControllerPose
 */
function controllerPose(objectPosition, objectRotation, referenceFrame) {
    return { objectPosition, objectRotation, referenceFrame };
}
/**
 * Constructor for ControllerPose
 */
function threeJsPose(objectPosition, objectRotation, referenceFrame) {
    return { objectPosition, objectRotation, referenceFrame };
}
/**
 * Internal utility for overload implementation detail.
 */
function isControllerPose(pose) {
    return 'objectPosition' in pose && 'objectRotation' in pose && 'referenceFrame' in pose;
}
/**
 * Gets the transformation matrix for this pose.
 */
function getZUpMatrix4(pose) {
    const euler = PoseUtils.asZUpEulerRotationRadians(pose.objectRotation);
    const q = new Quaternion().setFromEuler(new Euler(...euler.zUpEulerRotationRadians));
    q.normalize();
    return new Matrix4().compose(new Vector3(...pose.objectPosition.zUpPositionMeters), new Quaternion(q.x, q.y, q.z, q.w), new Vector3(1, 1, 1));
}
/**
 * Creates PoseUtils.asControllerPose a Z-up transformation matrix.
 */
function getControllerPoseFromZUpMatrix4(matrix, referenceFrame) {
    const position = new Vector3();
    const orientation = new Quaternion();
    const scale = new Vector3();
    matrix.decompose(position, orientation, scale);
    return controllerPose(zUpPositionMeters(position.x, position.y, position.z), getRotationVectorRadiansFromQuaternion(orientation.x, orientation.y, orientation.z, orientation.w), referenceFrame);
}
/**
 * Traverse a pose through a series of poses.
 */
function traversePoses(pose, fromPoses, toPoses, toFrame) {
    if (fromPoses.length === 0 && toPoses.length === 0) {
        return pose;
    }
    const fromTransforms = fromPoses.map((pose) => getZUpMatrix4(pose));
    const toTransforms = toPoses.map((pose) => getZUpMatrix4(pose).invert());
    const allTransforms = [...fromTransforms, ...toTransforms];
    const transformMatrix = allTransforms.reduce((matrix, transform) => transform.multiply(matrix), getZUpMatrix4(pose));
    return getControllerPoseFromZUpMatrix4(transformMatrix, toFrame);
}

/**
 * A type guard to check if an object is a Waypoint
 */
function isWaypoint(waypoint) {
    return (waypoint?.frame !== undefined &&
        waypoint?.pose !== undefined &&
        waypoint?.qNear !== undefined);
}

/**
 *
 */
function getPathToRoot(frameName, frameMap) {
    const path = [];
    let currentFrame = frameName;
    while (currentFrame) {
        path.push(currentFrame);
        const frame = frameMap.get(currentFrame);
        currentFrame = frame?.parent || '';
    }
    return path;
}
/**
 *
 */
function findCommonAncestor(path1, path2) {
    const set1 = new Set(path1);
    for (const frame of path2) {
        if (set1.has(frame)) {
            return frame;
        }
    }
    return path1[path1.length - 1];
}
/**
 * @param pose pose to be converted
 * @param toFrame name of reference frame at origin of new coordinate system
 *
 * @return Value of pose expressed in the coordinates of toFrame.
 */
function convertPose(pose, toFrame, frames) {
    if (pose.referenceFrame === toFrame) {
        return pose;
    }
    const frameMap = new Map();
    frames.forEach((frame) => frameMap.set(frame.name, frame));
    const fromFrameObj = frameMap.get(pose.referenceFrame);
    const toFrameObj = frameMap.get(toFrame);
    if (!fromFrameObj || !toFrameObj) {
        return pose;
    }
    const fromPath = getPathToRoot(pose.referenceFrame, frameMap);
    const toPath = getPathToRoot(toFrame, frameMap);
    const commonAncestor = findCommonAncestor(fromPath, toPath);
    const fromPoses = fromPath
        .slice(0, fromPath.indexOf(commonAncestor))
        .map((frameName) => frameMap.get(frameName))
        .filter((frame) => frame?.parent)
        .map((frame) => {
        if (!frame) {
            return PoseUtils.controllerPoseIdentityInFrame('world');
        }
        return PoseUtils.fromPose(frame.pose, frame.parent || 'world');
    });
    const toPoses = toPath
        .slice(0, toPath.indexOf(commonAncestor))
        .reverse()
        .map((frameName) => frameMap.get(frameName))
        .map((frame) => {
        if (!frame) {
            return PoseUtils.controllerPoseIdentityInFrame('world');
        }
        return PoseUtils.fromPose(frame.pose, frame.parent || 'world');
    });
    return traversePoses(pose, fromPoses, toPoses, toFrame);
}
const DEFAULT_ROTATION_THRESHOLD = 0.01;
const DEFAULT_POSITION_THRESHOLD = 0.001;
const DEFAULT_COMPARISON_THRESHOLDS = {
    positionThresholdMeters: DEFAULT_POSITION_THRESHOLD,
    rotationThresholdRadians: DEFAULT_ROTATION_THRESHOLD,
};
/**
 *
 */
function posesAreSignificantlySimilar(pose, lastPose, thresholds = DEFAULT_COMPARISON_THRESHOLDS) {
    if (!pose || !lastPose) {
        return false;
    }
    if (pose.referenceFrame !== lastPose.referenceFrame) {
        return false;
    }
    const { rotationThresholdRadians, positionThresholdMeters } = { ...DEFAULT_COMPARISON_THRESHOLDS, ...thresholds };
    if (rotationThresholdRadians === undefined || positionThresholdMeters === undefined) {
        return false;
    }
    const positionChange = Math.sqrt(Math.pow(pose.objectPosition.zUpPositionMeters[0] - lastPose.objectPosition.zUpPositionMeters[0], 2) +
        Math.pow(pose.objectPosition.zUpPositionMeters[1] - lastPose.objectPosition.zUpPositionMeters[1], 2) +
        Math.pow(pose.objectPosition.zUpPositionMeters[2] - lastPose.objectPosition.zUpPositionMeters[2], 2));
    if (positionChange > positionThresholdMeters) {
        return false;
    }
    const r1 = pose.objectRotation.zUpRotationVectorRadians;
    const r2 = lastPose.objectRotation.zUpRotationVectorRadians;
    const axis1 = new Vector3(...r1);
    const angle1 = axis1.length();
    const q1 = new Quaternion().setFromAxisAngle(axis1.normalize(), angle1);
    const axis2 = new Vector3(...r2);
    const angle2 = axis2.length();
    const q2 = new Quaternion().setFromAxisAngle(axis2.normalize(), angle2);
    return q1.angleTo(q2) <= rotationThresholdRadians;
}
/**
 *
 */
function frameArraysAreSignificantlySimilar(frames, lastFrames, thresholds = DEFAULT_COMPARISON_THRESHOLDS) {
    if (!frames || !lastFrames) {
        return false;
    }
    if (frames.length !== lastFrames.length) {
        return false;
    }
    return frames.every((frame) => {
        const lastFrame = lastFrames.find((f) => f.name === frame.name);
        if (!lastFrame) {
            return false;
        }
        return (frame.parent === lastFrame.parent &&
            posesAreSignificantlySimilar(PoseUtils.fromPose(frame.pose, frame.parent ?? 'world'), PoseUtils.fromPose(lastFrame.pose, lastFrame.parent ?? 'world'), thresholds));
    });
}

/**
 * Enum representing the possible states of the teach mode.
 */
var TeachModeState;
(function (TeachModeState) {
    TeachModeState["TEACHING"] = "teaching";
    TeachModeState["STOPPED"] = "stopped";
    TeachModeState["PAUSED"] = "paused";
})(TeachModeState || (TeachModeState = {}));

/**
 * An enum of all the built in application node types
 */
var ApplicationNodeType;
(function (ApplicationNodeType) {
    ApplicationNodeType["MOUNTING"] = "ur-mounting";
    ApplicationNodeType["FRAMES"] = "ur-frames";
    ApplicationNodeType["GRID_PATTERN"] = "ur-grid-pattern";
    ApplicationNodeType["END_EFFECTOR"] = "ur-end-effector";
    ApplicationNodeType["SMART_SKILLS"] = "ur-smart-skills";
    ApplicationNodeType["MOTION_PROFILES"] = "ur-motion-profiles";
    ApplicationNodeType["APPLICATION_VARIABLES"] = "ur-application-variables";
})(ApplicationNodeType || (ApplicationNodeType = {}));

var SmartSkillType;
(function (SmartSkillType) {
    SmartSkillType["ALIGN_TO_Z"] = "ur-align-to-z";
    SmartSkillType["ALIGN_TO_PLANE"] = "ur-align-to-plane";
    SmartSkillType["ALIGN_Z_TO_NEAREST_AXIS"] = "ur-align-z-to-nearest-axis";
    SmartSkillType["CENTER"] = "ur-center";
    SmartSkillType["FREEDRIVE"] = "ur-freedrive";
    SmartSkillType["MOVE_INTO_CONTACT"] = "ur-move-into-contact";
    SmartSkillType["RETRACT"] = "ur-retract";
    SmartSkillType["PUT_IN_BOX"] = "ur-put-in-box";
    SmartSkillType["CUSTOM_SMART_SKILL"] = "ur-custom-smart-skill";
    SmartSkillType["ADMITTANCE_CONTROL"] = "ur-admittance-control";
})(SmartSkillType || (SmartSkillType = {}));

var MotionProfileMoveType;
(function (MotionProfileMoveType) {
    MotionProfileMoveType["Joint"] = "joint";
    MotionProfileMoveType["Linear"] = "linear";
    MotionProfileMoveType["Process"] = "process";
})(MotionProfileMoveType || (MotionProfileMoveType = {}));
var MovementType;
(function (MovementType) {
    MovementType["Optimove"] = "OptiMove";
    MovementType["Classic"] = "Classic";
})(MovementType || (MovementType = {}));

const floatOperators = ['<', '>'];
const registerOperators = [...floatOperators, '==', '!=', '>=', '<='];
const operatorInverseMap = {
    '<': '>=',
    '>': '<=',
    '==': '!=',
    '!=': '==',
    '>=': '<',
    '<=': '>',
};

var WaypointType;
(function (WaypointType) {
    WaypointType["Teach"] = "teach";
    WaypointType["Expression"] = "expression";
})(WaypointType || (WaypointType = {}));

var NodeType;
(function (NodeType) {
    NodeType["PROGRAM"] = "ur-program";
    NodeType["FUNCTIONS"] = "ur-functions";
    NodeType["CODE"] = "ur-code";
    NodeType["BEFORE_START"] = "ur-before-start";
    NodeType["CONFIGURATION"] = "ur-configuration";
    NodeType["MODULES"] = "ur-modules";
    NodeType["STATUS"] = "ur-status";
    NodeType["FUNCTION"] = "ur-function";
    NodeType["MODULE"] = "ur-module";
    NodeType["WAIT"] = "ur-wait";
    NodeType["LOOP"] = "ur-loop";
    NodeType["ASSIGNMENT"] = "ur-assignment";
    NodeType["FOLDER"] = "ur-folder";
    NodeType["SCRIPT"] = "ur-script";
    NodeType["MOVE"] = "ur-move";
    NodeType["IF"] = "ur-if";
    NodeType["ELSE"] = "ur-else";
    NodeType["ELSEIF"] = "ur-elseif";
    NodeType["WAYPOINT"] = "ur-waypoint";
    NodeType["SET"] = "ur-set";
    NodeType["COMMENT"] = "ur-comment";
    NodeType["TOOL_FORCE"] = "ur-tool-force";
    NodeType["OPERATOR_INPUT"] = "ur-operator-input";
    NodeType["SET_TCP"] = "ur-set-tcp";
    NodeType["CALL_FUNCTION"] = "ur-call-function";
    NodeType["STATUS_ITEM"] = "ur-status-item";
    NodeType["GRID_ITERATOR"] = "ur-grid-iterator";
    NodeType["CONFIGURATION_VALUE_ITEM"] = "ur-configuration-value-item";
    NodeType["CONFIGURATION_REFERENCE_ITEM"] = "ur-configuration-reference-item";
    NodeType["CONFIGURATION_REFERENCE_ITEM_OPTION"] = "ur-configuration-reference-item-option";
    NodeType["MOVE_TO"] = "ur-move-to";
    NodeType["JOINT_MOVE"] = "ur-joint-move";
    NodeType["LINEAR_MOVE"] = "ur-linear-move";
    NodeType["PATH"] = "ur-path";
    NodeType["PAYLOAD"] = "ur-payload";
    NodeType["TCP"] = "ur-tcp";
    NodeType["ALIGN_TO"] = "ur-align-to";
    NodeType["THREAD"] = "ur-thread";
    NodeType["LOGIC_PROGRAMS"] = "ur-logic-programs";
    NodeType["LOGIC_PROGRAM"] = "ur-logic-program";
    NodeType["HALT"] = "ur-halt";
    NodeType["TIMER"] = "ur-timer";
    NodeType["MOVE_P"] = "ur-move-p";
    NodeType["MOVE_C"] = "ur-move-c";
    NodeType["POINT"] = "ur-point";
    NodeType["SWITCH"] = "ur-switch";
    NodeType["CASE"] = "ur-case";
    NodeType["DEFAULT_CASE"] = "ur-default-case";
    NodeType["DIRECTION"] = "ur-direction";
    NodeType["FRAME"] = "ur-frame";
})(NodeType || (NodeType = {}));

const ThreadAction = {
    KILL: 'Kill',
    RUN: 'Run',
};

var ActionEnum;
(function (ActionEnum) {
    ActionEnum["START"] = "Start";
    ActionEnum["PAUSE"] = "Pause";
    ActionEnum["RESET"] = "Reset";
})(ActionEnum || (ActionEnum = {}));

var OrientationMode;
(function (OrientationMode) {
    OrientationMode["FIXED"] = "fixed";
    OrientationMode["UNCONSTRAINED"] = "unconstrained";
})(OrientationMode || (OrientationMode = {}));

var UntilConditionType;
(function (UntilConditionType) {
    UntilConditionType["EXPRESSION"] = "expression";
    UntilConditionType["CONTACT"] = "contact";
    UntilConditionType["DISTANCE"] = "distance";
    UntilConditionType["SIGNAL"] = "signal";
})(UntilConditionType || (UntilConditionType = {}));
const DirectionalPositionAxes = ['Y+', 'Y-', 'X+', 'X-', 'Z+', 'Z-'];
function getDirectionalVector(axis) {
    return DirectionalVectors[axis];
}
const DirectionalVectors = {
    'X+': '[1.0, 0.0, 0.0]',
    'X-': '[-1.0, 0.0, 0.0]',
    'Y+': '[0.0, 1.0, 0.0]',
    'Y-': '[0.0, -1.0, 0.0]',
    'Z+': '[0.0, 0.0, 1.0]',
    'Z-': '[0.0, 0.0, -1.0]',
};

var FrameNodeAction;
(function (FrameNodeAction) {
    FrameNodeAction["CREATE"] = "create";
    FrameNodeAction["MOVE"] = "move";
    FrameNodeAction["DELETE"] = "delete";
    FrameNodeAction["CHANGE_PARENT"] = "change-parent";
})(FrameNodeAction || (FrameNodeAction = {}));

const APPLICATION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ApplicationService.';
/**
 * Provides access to data stored in the application
 */
class ApplicationService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(APPLICATION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Returns a list of the Application Nodes that contribute data to the currently loaded Application
     */
    getAvailableApplicationNodes() {
        return this.postAndAwait('getAvailableApplicationNodes');
    }
    /**
     * Returns the data stored on the specified Application Node
     * @param name the name of the Application Node to fetch
     */
    getApplicationNode(name) {
        return this.postAndAwait('getApplicationNode', { name });
    }
    /**
     * Returns true if a grid from application is valid. If the variable name is not a grid
     * or a grid defined somewhere else then it always returns true.
     * @param name The name of the variable being validated
     * @returns true if the grid is valid or is not a grid but a different variable type
     */
    async isValidGridPattern(name) {
        const gridPatternNode = (await this.getApplicationNode(ApplicationNodeType.GRID_PATTERN));
        const grid = gridPatternNode.grids.find((grid) => grid.grid.name === name);
        if (!grid) {
            // Grid is defined somewhere else, so we cannot validate it and assume it is valid
            return true;
        }
        // A grid pattern needs to have at least some corner positions defined.
        if (!grid.corners.length) {
            return false;
        }
        // Determine whether the grid pattern is 1D (single row or column) or 2D (matrix).
        // 1D grids need at least 2 corners.
        // 2D grids need at least 4 corners.
        const columns = grid.numColumns;
        const rows = grid.numRows;
        const requiredCorners = columns === 1 || rows === 1 ? 2 : 4;
        const hasRequiredCorners = grid.corners.length >= requiredCorners;
        // Every corner must be defined to be a valid grid.
        const hasValidCorners = grid.corners.every((corner) => !!corner);
        return hasRequiredCorners && hasValidCorners;
    }
}

const DIALOG_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.DialogService.';
/**
 * Service for open a dialog
 */
class DialogService extends MessageInvokerService {
    /**
     * Create a service for the specific worker
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(DIALOG_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Open a Confirmation Dialog with a single dismiss button.
     * @param title Dialog title
     * @param text Dialog message
     * @param icon Dialog icon. It can be 'info', 'warning', 'error', or other icon strings.
     * @param confirmText Optional. Text for confirm button. Default to 'OK'.
     * @param  confirmIcon Optional. icon for confirm button. Default to no icon.
     */
    openConfirmDialog(title, text, icon, confirmText, confirmIcon) {
        return this.postAndAwait('openConfirmDialog', {
            title,
            text,
            icon,
            textIsTranslationKey: false,
            confirmText,
            confirmIcon,
            replacementPatterns: undefined,
            replacements: undefined,
            showCancelButton: false,
            cancelText: undefined,
        });
    }
    /**
     * Open a Confirmation Dialog with a single dismiss button.
     * @param title Dialog title
     * @param text Dialog message
     * @param icon Dialog icon. It can be 'info', 'warning', 'error', or other icon strings.
     * @param confirmText Optional. Text for confirm button. Default to 'Confirm'.
     * @param confirmIcon Optional. Icon for confirm button. Default to no icon.
     * @param cancelText Optional. Text for cancel button. Default to 'Go Back'.
     */
    openConfirmCancelDialog(title, text, icon, confirmText, confirmIcon, cancelText) {
        return this.postAndAwait('openConfirmDialog', {
            title,
            text,
            icon,
            textIsTranslationKey: false,
            confirmText,
            confirmIcon,
            replacementPatterns: undefined,
            replacements: undefined,
            showCancelButton: true,
            cancelText,
        });
    }
    /**
     * Open a Custom Webcomponent Dialog
     * @param componentTag The tagname of the webcomponent to render in the dialog
     * @param initialData The initial data to be passed to the dialog component upon opening
     * @param options
     */
    openCustomDialog(componentTag, initialData, options) {
        return this.postAndAwait('openCustomDialog', {
            componentTag,
            inputData: initialData,
            options,
        });
    }
    /**
     * Open a Custom Webcomponent Dialog without waiting for user to close
     * @param componentTag The tagname of the webcomponent to render in the dialog
     * @param initialData The initial data to be passed to the dialog component upon opening
     * @param options
     * @returns The id of the dialog
     */
    openCustomDialogNoWait(componentTag, initialData, options) {
        return this.postAndAwait('openCustomDialogNoWait', {
            componentTag,
            inputData: initialData,
            options,
        });
    }
    /**
     * Close a Custom Webcomponent Dialog
     * @param id The id of the dialog to close
     */
    closeCustomDialogById(id) {
        return this.postAndAwait('closeCustomDialogById', {
            id,
        });
    }
}

const LOG_MESSAGE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.LogMessageService.';
/**
 * Service for sending log messages
 */
class LogMessageService extends MessageInvokerService {
    /**
     * Create a service for the specific worker
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(LOG_MESSAGE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Sends a log message.
     *
     * @param message The message to be logged
     */
    sendLogMessage(message) {
        return this.postAndAwait('sendLogMessage', message);
    }
    /**
     * Sends a warning log message.
     *
     * @param message The message to be logged
     * @param type The type of message - if not specified 'generic' will be used
     */
    warn(message, type = 'generic') {
        return this.postAndAwait('warn', { message, type });
    }
    /**
     * Sends a info log message.
     *
     * @param message The message to be logged
     * @param type The type of message - if not specified 'generic' will be used
     */
    info(message, type = 'generic') {
        return this.postAndAwait('info', { message, type });
    }
    /**
     * Sends a debug log message.
     *
     * @param message The message to be logged
     * @param type The type of message - if not specified 'generic' will be used
     */
    debug(message, type = 'generic') {
        return this.postAndAwait('debug', { message, type });
    }
    /**
     * Sends a error log message.
     *
     * @param message The message to be logged
     * @param type The type of message - if not specified 'generic' will be used
     */
    error(message, type = 'generic') {
        return this.postAndAwait('error', { message, type });
    }
}

const LOG_PERFORMANCE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.LogPerformanceService.';
/**
 * Service for sending log performance metrics
 */
class LogPerformanceService extends MessageInvokerService {
    /**
     * Create a service for the specific worker
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(LOG_PERFORMANCE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Sends a basic log performance metric where duration, start and end names are the same.
     *
     * @param markName
     */
    logPerformanceMetrics(markName) {
        return this.postAndAwait('logPerformanceMetrics', markName);
    }
    /**
     * Sends a extended log performance metric where duration, start and end names can be specified individually.
     *
     * @param durationName The duration name
     * @param startName The start name
     * @param endName The end name
     */
    logPerformanceMetricsExtended(durationName, startName, endName) {
        return this.postAndAwait('logPerformanceMetricsExtended', { durationName, startName, endName });
    }
}

const PROGRAM_NODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramNodeService.';
/**
 * Service that handles node insertion and removal og nodes
 */
class ProgramNodeService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     * @param selectedNodeId
     */
    constructor(eventTarget, selectedNodeId) {
        super(PROGRAM_NODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
        this.selectedNodeId = selectedNodeId;
    }
    /**
     * Update the program node
     * @param node New program node state
     */
    async updateNode(node) {
        return this.postAndAwait('updateParentNode', {
            node,
            id: this.selectedNodeId,
        });
    }
}

const ROBOT_MOVE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.RobotMoveService.';
/**
 * RobotMoveService handles movement screen navigation
 */
class RobotMoveService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(ROBOT_MOVE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Opens the move screen and returns the selected position of the robot. Returns undefined if cancel is selected
     * @param options Move screen options
     */
    async openMoveScreen(options) {
        return this.postAndAwait('openMoveScreen', options);
    }
    /**
     * Opens the autoMove screen
     * @param targetPosition Joint vector to move to
     */
    async autoMove(targetPosition) {
        return this.postAndAwait('autoMove', targetPosition);
    }
}

const ROBOT_POSITION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.RobotPositionService.';
/**
 * A service to obtain information on the current robot position
 */
class RobotPositionService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(ROBOT_POSITION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Gets the id of the currently selected frame id to perform moves relative to
     */
    async getRelativeToFrameId() {
        return this.postAndAwait('getRelativeToFrameId');
    }
    /**
     * Gets the kinematic info
     */
    async getKinematicInfo() {
        return this.postAndAwait('getKinematicInfo');
    }
    /**
     * Implementation
     */
    async getInverseKinematics(pose, qNear) {
        return this.postAndAwait('getInverseKinematics', {
            pose: isControllerPose(pose) ? PoseUtils.asPose(pose) : pose,
            qNear,
        });
    }
    /**
     * Get the current pose of the TCP relative to the given frame
     */
    getPoseRelativeToFrame(frame) {
        return this.postAndObserve('getPoseRelativeToFrame', { frame });
    }
    /**
     * Get the current joint positions of the robot
     */
    getJointPositions() {
        return this.postAndObserve('getJointPositions');
    }
    /**
     * Converts the jointPositions to TCPPose.
     */
    convertJointPositionsToTcpPose(jointPositions) {
        return this.postAndAwait('convertJointPositionsToTcpPose', { jointPositions });
    }
    /**
     * Get current position of the robot
     */
    async getCurrentPosition() {
        return this.postAndAwait('getCurrentPosition');
    }
}

const SAFETY_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SafetyService.';
/**
 * Service for getting information about Safety
 */
class SafetyService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SAFETY_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Returns a list of safety IO's
     */
    getIOs() {
        return this.postAndAwait('getIOs');
    }
    /**
     * Get the maximum allowed tool force for the robot
     */
    getMaxToolForce() {
        return this.postAndAwait('getMaxToolForce');
    }
    /**
     * Get the payload limits for the robot
     */
    getPayloadLimits() {
        return this.postAndAwait('getPayloadLimits');
    }
    /**
     * Get the operational mode of the robot
     */
    getOperationalMode() {
        return this.postAndObserve('getOperationalMode');
    }
}

const SOURCE_MESSAGE_TYPE_BASE = 'ur.web.message.SourceService.';
/**
 * Service for getting information about Sources and Signals
 */
class SourceService extends MessageInvokerService {
    /**
     * @constructor
     * @param target
     */
    constructor(eventTarget) {
        super(SOURCE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Returns the ID's of Sources that are available to the application
     * @param filter SignalFilter used to filter only Sources which contain Signals matching the filter
     */
    getSources(filter) {
        return firstValueFrom(this.postAndObserve('sourcesList', { filter }).pipe(map((sources) => {
            return sources.map((source) => source.sourceID);
        })));
    }
    /**
     * Returns the map of Sources
     */
    sources(filter) {
        return this.postAndObserve('sources', { filter });
    }
    /**
     * Returns the source node label for the griven groupId
     */
    sourceNodeLabel(groupId) {
        return this.sourceNodeLabels().pipe(map((labels) => labels[groupId]));
    }
    /**
     * Returns the map of source node labels
     */
    sourceNodeLabels() {
        return this.postAndObserve('getSourceNodeLabels', {});
    }
    /**
     * Returns the list of Signals in a Source
     * @param sourceID The Source to list Signals for
     * @param filter SignalFilter used to filter only Signals which match the filter
     * @deprecated use getSourceSignals instead
     */
    getSignals(sourceID, filter) {
        return firstValueFrom(this.postAndObserve('getSourceSignals', { sourceID, filter }));
    }
    /**
     * Returns the list of Signals in a Source
     * @param sourceGroupID The Source group, containing the source to provide signals for
     * @param sourceID The Source to list Signals for
     * @param filter SignalFilter used to filter only Signals which match the filter
     */
    sourceSignals(sourceGroupID, sourceID, filter) {
        return this.postAndObserve('getSourceSignals', {
            sourceGroupID,
            sourceID,
            filter,
        });
    }
    /**
     * Returns an Observable providing Signal events
     * @param sourceID The Source containing the Signals to provide events for
     * @param filter SignalFilter used to filter only events for Signals which match the filter
     * @deprecated use getSourceUpdates instead
     */
    getSignalUpdates(sourceID, filter) {
        return this.postAndObserve('getSignalUpdates', { sourceID, filter });
    }
    /**
     * Returns an Observable providing Signal events
     * @param sourceGroupID The Source group, containing the source to provide events for
     * @param sourceID The Source containing the Signals to provide events for
     * @param filter SignalFilter used to filter only events for Signals which match the filter
     */
    getSourceUpdates(sourceGroupID, sourceID, filter) {
        // Combine results of "old" and "new" APIs, and return whichever produces a value
        // The old message
        const o1 = this.postAndObserve('getSignalUpdates', {
            sourceID,
            filter,
        });
        // The new message
        const o2 = this.postAndObserve('getSourceUpdates', {
            sourceGroupID,
            sourceID,
            filter,
        });
        return merge(o1, o2);
    }
    /**
     * Returns the generated script code for setting the signal to the given value
     * @param sourceID The ID of the source containing the signal to set
     * @param signalID The ID of the signal to set
     * @param value The value to set the signal to - for digital values use 0 or 1, for registers use only integers, for analog values use any float
     * @deprecated use getSetSignalScript instead
     */
    generateSetSignalScript(sourceID, signalID, value) {
        return this.postAndAwait('generateSetSignalScript', {
            sourceID,
            signalID,
            value,
        });
    }
    /**
     * Returns the generated script code for setting the signal to the given value
     * @param sourceGroupID The Source group, containing the source and signal to provide script for
     * @param sourceID The ID of the source containing the signal to set
     * @param signalID The ID of the signal to set
     * @param value The value to set the signal to - for digital values use 0 or 1, for registers use only integers, for analog values use any float
     */
    getSetSignalScript(sourceGroupID, sourceID, signalID, value) {
        // Combine results of "old" and "new" APIs, and return whichever produces a value
        return new Promise((resolve, reject) => {
            Promise.all([
                // The old message
                this.postAndAwait('generateSetSignalScript', {
                    sourceID,
                    signalID,
                    value,
                }),
                // The new message
                this.postAndAwait('getSetSignalScript', {
                    sourceGroupID,
                    sourceID,
                    signalID,
                    value,
                }),
            ])
                .then((value) => {
                // Return whichever value (if any) that comes back (priority on the "new" value)
                resolve(value[1] ? value[1] : value[0] ? value[0] : '');
            })
                .catch((reason) => reject(reason));
        });
    }
    /**
     * Returns the generated script code for getting the value of a given signal
     * @param sourceID The ID of the source containing the signal to get
     * @param signalID The ID of the signal to get
     * @deprecated use getGetSignalScript instead
     */
    generateGetSignalScript(sourceID, signalID) {
        return this.postAndAwait('generateGetSignalScript', {
            sourceID,
            signalID,
        });
    }
    /**
     * Returns the generated script code for getting the value of a given signal
     * @param groupId The Source group, containing the source to provide events for
     * @param sourceId The ID of the source containing the signal to get
     * @param signalId The ID of the signal to get
     */
    getGetSignalScript(groupId, sourceId, signalId) {
        // Combine results of "old" and "new" APIs, and return whichever produces a value
        return new Promise((resolve, reject) => {
            Promise.all([
                // The old message
                this.postAndAwait('generateGetSignalScript', {
                    sourceID: sourceId,
                    signalID: signalId,
                }),
                // The new message
                this.postAndAwait('getGetSignalScript', {
                    groupId,
                    sourceId,
                    signalId,
                }),
            ])
                .then((value) => {
                // Return whichever value (if any) that comes back (priority on the "new" value)
                resolve(value[1] ? value[1] : value[0] ? value[0] : '');
            })
                .catch((reason) => reject(reason));
        });
    }
    /**
     * Returns an object literal containing a mapping of SignalIDs -> AnalogDomains
     * @param sourceID The ID of the Source for which to get Domain data
     * @deprecated should be handled by the individual contribution
     */
    getAnalogSignalDomains(sourceID) {
        return this.postAndAwait('getAnalogSignalDomains', { sourceID });
    }
    /**
     * Performs validation on a new value that will be used in a set script
     * @param groupId The contribution groupId
     * @param sourceId The contribution sourceId
     * @param signalId The contribution signalId
     * @param value The value that will be set
     */
    validateSetSignal(groupId, sourceId, signalId, value) {
        return this.postAndAwait('validateSetSignal', {
            groupId,
            sourceId,
            signalId,
            value,
        });
    }
    /**
     * Performs validation on a new value that will be used in a get script
     * @param groupId The contribution groupId
     * @param sourceId The contribution sourceId
     * @param signalId The contribution signalId
     * @param value The value that will be got
     * @param operator The operator on the value that will be got
     */
    validateGetSignal(groupId, sourceId, signalId, value, operator) {
        return this.postAndAwait('validateGetSignal', {
            groupId,
            sourceId,
            signalId,
            value,
            operator,
        });
    }
    /**
     * Returns info about the signals for a given source
     * @param groupId
     * @param sourceId
     */
    getSignalsDomainData(groupId, sourceId) {
        // What this needs to do is:
        // If it's the old tool/wired IO (if the groupId is 'ur-robot') then call through to the getSignalsDomainData method
        // on the data-store SourceService
        // Else call the getSignalsDomainData method from the behavior of the groupId SourcesNode
        return this.postAndAwait('getSignalsDomainData', { groupId, sourceId });
    }
    /**
     * Sets a value on a signal
     * @param sourceID The ID of the Source, containing the Signal to set
     * @param signalID The ID of the Signal to set
     * @param value The value to set
     * @deprecated use setSourceSignalValue instead
     */
    setSignalValue(sourceID, signalID, value) {
        const updateSignalValue = {
            sourceID,
            signalID,
            value,
        };
        return this.postAndAwait('setSignalValue', updateSignalValue);
    }
    /**
     * Sets a value on a signal
     * @param sourceGroupID The Source group, containing the source to provide events for
     * @param sourceID The ID of the Source, containing the Signal to set
     * @param signalID The ID of the Signal to set
     * @param value The value to set
     */
    setSourceSignalValue(sourceGroupID, sourceID, signalID, value) {
        const updateSignalValue = {
            sourceID,
            signalID,
            value,
        };
        const setSignalValue = {
            sourceGroupID,
            sourceID,
            signalID,
            value,
        };
        // Send the update to both "old" and "new" APIs
        return new Promise((resolve, reject) => {
            Promise.all([
                // The old message
                this.postAndAwait('setSignalValue', updateSignalValue),
                // The new message
                this.postAndAwait('setSourceSignalValue', setSignalValue),
            ])
                .then(() => resolve())
                .catch((reason) => {
                reject(reason);
            });
        });
    }
    /**
     * Returns an object literal containing a mapping of SignalIDs -> Labels
     * @param sourceID The ID of the Source for which to get the Label mappings
     * @deprecated Source contributions will be responsible for providing labels for signals directly
     */
    getSignalLabels(sourceID) {
        return this.postAndAwait('getSignalLabels', sourceID);
    }
    /**
     * Returns an object literal containing a mapping of SignalIDs -> Presets
     * @param sourceID The ID of the Source for which to get the Preset mappings
     * @deprecated Source contributions will be responsible for handling presets themselves
     */
    getSignalPresets(sourceID) {
        return this.postAndAwait('getSignalPresets', sourceID);
    }
}

/**
 * A service for setting signal properties such as their label or preset
 */
class SignalService extends MessageInvokerService {
    /**
     *
     */
    constructor(eventTarget, sourceID) {
        super(SOURCE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
        this.sourceID = sourceID;
    }
    /** Update the label for a specific signal id
     * @param signalID id for the signal being labelled
     * @param label the new label for the signal
     * @deprecated Source contributions will be responsible for labels for signals directly
     */
    async updateSignalLabel(signalID, label) {
        const setLabel = {
            sourceID: this.sourceID,
            signalID,
            label,
        };
        return this.postAndAwait('updateSignalLabel', setLabel);
    }
    /** Update the Analog Domain for a specific signal id
     * @param signalID id for the signal being changed
     * @param analogDomainValueEnum the domain to set
     * @deprecated should be handled by the individual contribution
     */
    async updateSignalAnalogDomain(signalID, analogDomainValueEnum) {
        const updateAnalogDomainValue = {
            sourceID: this.sourceID,
            signalID,
            analogDomain: analogDomainValueEnum,
        };
        return this.postAndAwait('updateSourceSignalAnalogDomain', updateAnalogDomainValue);
    }
    /**
     * Set the Preset Action for a given Digital-In signal
     * @param signalID ID of the signal to set the preset for
     * @param preset the preset to set
     * @deprecated Source contributions will be responsible for handling presets themselves
     */
    setDigitalInPreset(signalID, preset) {
        const updateAnalogInPreset = {
            sourceID: this.sourceID,
            signalID,
            preset,
        };
        return this.postAndAwait('setDigitalInPreset', updateAnalogInPreset);
    }
}

const SOURCE_NODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SourceNodeService.';
/**
 * Service that handles updating source nodes
 */
class SourceNodeService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SOURCE_NODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Update the source node
     * @param node New source node state
     */
    updateNode(node) {
        return this.postAndAwait('updateNode', node);
    }
}

const TREE_BUILDER_MESSAGE_TYPE_BASE = 'ur.web.message.TreeBuilder.';
/**
 * TreeBuilder
 *  Provides methods to build program node trees that can then be passed to
 *  the application for insertion to the main program.
 */
class TreeBuilder extends MessageInvokerService {
    /**
     * @constructor
     */
    constructor(eventTarget) {
        super(TREE_BUILDER_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Turns the passed in ProgramNode into a BranchNode, allowing children to
     * be added to the subtree of the given node.
     * @param node The ProgramNode to convert to a BranchNode
     */
    createBranchNode(node) {
        return {
            children: [],
            type: node.type,
            version: node.version,
            allowsChildren: node.allowsChildren,
            lockChildren: node.lockChildren,
            parameters: node.parameters,
        };
    }
    /**
     * Appends a child node to the subtree of the given parent node
     * @param parentNode The BranchNode to add the child to
     * @param node The child ProgramNode to be added to the subtree
     */
    appendChild(parentNode, node) {
        parentNode.children.push(node);
    }
    /**
     * Requests a new instance of a ProgramNode from the application
     * @param ofType The type of the ProgramNode to be instantiated - see the
     * nodeType enum for the builtin types.
     */
    async createNode(ofType) {
        return this.postAndAwait('createNode', ofType);
    }
}

const SYMBOL_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SymbolService.';
/**
 * Service for generating and getting reserved variable names
 */
class SymbolService extends MessageInvokerService {
    /**
     * Create a service for the specific worker
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SYMBOL_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Get a list of available variables
     * @returns
     */
    getVariables() {
        return this.postAndAwait('getVariables', {});
    }
    /**
     * Get an observable of available variables
     */
    variables() {
        return this.postAndObserve('variables', {});
    }
    /**
     * Returns a list of the global variables as a stream.
     * @returns {Observable<Array<GlobalVariable>>} Observable of global variables object
     */
    globalVariables() {
        return this.postAndObserve('globalVariables', {});
    }
    /**
     * Generates a new variable. The variable name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName The intended name for the variable, will be suffixed if the name is already taken
     * @param valueType The ValueType of the variable
     * @param blacklist Optional parameter to provide additional names which shouldn't be used.
     */
    generateVariable(suggestedName, valueType, blacklist) {
        return this.postAndAwait('generateVariable', {
            suggestedName,
            valueType,
            blacklist,
        });
    }
    /**
     * Return true if the provided name is the name of a registered variable
     *
     * @param variableName
     */
    isRegisteredVariableName(variableName) {
        return this.postAndAwait('isRegisteredVariableName', variableName);
    }
    /**
     * Get a list of available functions for the given module name. If no name provided, functions for the global scope
     * @param moduleName
     * @returns
     */
    getFunctions(moduleName = '') {
        return this.postAndAwait('getFunctions', { moduleName });
    }
    /**
     * Get functions map. Contains a list of functions for each module name. Note: Empty string is the global scope.
     * @param filter Filter on if the function is async or not
     * is async or not
     * @returns
     */
    getFunctionsMap(filter) {
        return this.postAndAwait('getFunctionsMap', filter);
    }
    /**
     * Generates a new function. The function name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName
     * @param moduleName
     */
    generateFunction(suggestedName, moduleName) {
        return this.postAndAwait('generateFunction', {
            functionName: suggestedName,
            moduleName,
        });
    }
    /**
     * Return true if the provided name is the name of a registered function
     *
     * @param functionName
     * @param moduleName
     */
    isRegisteredFunctionName(functionName, moduleName) {
        return this.postAndAwait('isRegisteredFunctionName', {
            functionName,
            moduleName,
        });
    }
    /**
     * Get a list of available modules
     * @returns
     */
    getModuleNames() {
        return this.postAndAwait('getModuleNames', {});
    }
    /**
     * Generates a new module. The module name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName
     */
    generateModule(suggestedName) {
        return this.postAndAwait('generateModule', suggestedName);
    }
    /**
     * Return true if the provided name is the name of a registered module
     *
     * @param moduleName
     */
    isRegisteredModuleName(moduleName) {
        return this.postAndAwait('isRegisteredModuleName', { moduleName });
    }
    /**
     * Get a list of available Logic Programs
     * @returns
     */
    getLogicProgramNames() {
        return this.postAndAwait('getLogicProgramNames', {});
    }
    /**
     * Generates a new Logic Program. The program name is based on the suggested name.
     * If the suggested name is not usable a new, based on the suggestion, will be created
     *
     * @param suggestedName
     */
    generateLogicProgram(suggestedName) {
        return this.postAndAwait('generateLogicProgram', suggestedName);
    }
    /**
     * Return true if the provided name is the name of a registered Logic Program
     *
     * @param logicProgramName
     */
    isRegisteredLogicProgramName(logicProgramName) {
        return this.postAndAwait('isRegisteredLogicProgramName', {
            logicProgramName,
        });
    }
    /**
     *  Return true if the provided name is a registered name of the given type.
     * @param name
     * @param type
     * @param moduleName
     * @param unique
     * @returns
     */
    isRegisteredName(name, type, moduleName, unique = false) {
        return this.postAndAwait('isRegisteredName', {
            name,
            type,
            moduleName,
            unique,
        });
    }
    /**
     * Return true if the declaring program node is suppressed
     * @param name The name of the symbol
     * @param moduleName The module of the symbol if defined
     * @return Boolean describing if the declaring node is suppressed
     */
    isSuppressed(name, moduleName) {
        return this.postAndAwait('isSuppressed', { name, moduleName });
    }
    /**
     * Get the URVariable with the given name
     * @return URVariable with the given name
     * @param name Name of the variable to get
     */
    getVariable(name) {
        return this.postAndAwait('getVariable', { name });
    }
    /**
     *
     * @param variableName name of the variable being validated
     * @param acceptedTypes an optional array of valid type strings, e.g., float.
     * @returns true if the variable is registered not suppressed, and is of a valid value type
     */
    async isValidVariable(variableName, acceptedTypes) {
        const isRegistered = await this.isRegisteredVariableName(variableName);
        const isSuppressed = await this.isSuppressed(variableName);
        const variable = await this.getVariable(variableName);
        let isOfValidValueType = true;
        if (acceptedTypes) {
            isOfValidValueType = acceptedTypes.some((acceptedType) => acceptedType === variable?.valueType);
        }
        return isRegistered && !isSuppressed && isOfValidValueType;
    }
    /**
     * Return true if the function is a thread
     * @param functionName The name of the function
     * @param moduleName The module of the symbol if defined
     * @return Boolean describing if the function is a thread
     */
    isAsyncFunction(functionName, moduleName) {
        return this.postAndAwait('isAsyncFunction', { functionName, moduleName });
    }
}

const VALIDATION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ValidationService.';
/**
 * Allows program nodes to obtain the validation response generated from their respective behavior worker.
 */
class ValidationService extends MessageInvokerService {
    /**
     * Creates a new instance of the ValidationService
     * @param eventTarget the target to send message events on
     * @param selectedNodeId the id of the currently selected node
     */
    constructor(eventTarget, selectedNodeId) {
        super(VALIDATION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
        this.selectedNodeId = selectedNodeId;
    }
    /**
     * Returns the last validation response generated from the behavior worker.
     * If the node is valid the returned response will be exactly { isValid: true } without any extra data.
     */
    async getValidationResponse(nodeId = this.selectedNodeId) {
        return this.postAndAwait('getValidationResponse', {
            id: nodeId,
        });
    }
}

const SNACKBAR_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SnackbarService.';
/**
 * Service that handles showing snack notifications.
 */
class SnackbarService extends MessageInvokerService {
    /**
     * Create a service for the specific eventTarget
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SNACKBAR_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Open a snack notification.
     * @param message Snackbar message
     * @param type Optional. Type of notification (success, error, warning, info(default)).
     * @param title Optional. Snackbar title
     */
    showSnackbar(message, type, title) {
        return this.postAndAwait('showSnackbar', {
            message,
            type,
            title,
        });
    }
}

const SMART_SKILL_INSTANCE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SmartSkillInstanceService.';
/**
 * Service that handles updating smart skill instances
 */
class SmartSkillInstanceService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SMART_SKILL_INSTANCE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Update the program node
     * @param instance New smart skill instance data
     */
    async updateInstance(instance) {
        return this.postAndAwait('updateInstance', {
            instance,
        });
    }
    /**
     * Get all smart skill instances as an observable stream.
     * @returns Observable<SmartSkillInstance[]>
     */
    getInstances() {
        return this.postAndObserve('getAllInstancesObservable', {});
    }
    /**
     * Get the smart skill instance by type and optionally name. If name is not provided, the first instance of the type is returned.
     * @param type Type of the smart skill instance
     * @param name Optional name of the smart skill instance
     */
    async getInstance(type, name) {
        return firstValueFrom(this.getInstances().pipe(map$1((instances) => instances.find((instance) => instance.type === type && (!name || instance.name === name)) || undefined)));
    }
}

const PROGRAM_EXECUTION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramExecutionService.';
/**
 * Service that handles program execution
 */
class ProgramExecutionService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(PROGRAM_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Stop the program
     */
    async stopProgram() {
        return this.postAndAwait('stopProgram');
    }
    /**
     * Play the program
     */
    async playProgram() {
        return this.postAndAwait('playProgram');
    }
    /**
     * Resumes the program
     */
    async resumeProgram() {
        return this.postAndAwait('resumeProgram');
    }
    /**
     * Pause the program
     */
    async pauseProgram() {
        return this.postAndAwait('pauseProgram');
    }
    /**
     * Get the Program Status
     */
    getProgramStatus() {
        return this.postAndObserve('getStatus');
    }
    /**
     * Step to the next line in the program
     */
    async stepProgram() {
        return this.postAndAwait('stepProgram');
    }
}

const TOOL_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ToolService.';
/**
 * Provides access to URScript functions
 * Parameters are aligned with URScript functions, see URScript manual for more info.
 */
class ToolService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(TOOL_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Sets the active tcp offset, i.e. the transformation from the output flange coordinate system to the TCP as a pose.
     * @see ScriptBuilder#setTcp
     */
    setTcp(tcp) {
        return this.postAndAwait('setTCP', tcp);
    }
    /**
     * Sets the mass, CoG (center of gravity), the inertia matrix of the active payload
     * @see ScriptBuilder#setTargetPayload
     */
    setTargetPayload(mass, cog, inertia) {
        return this.postAndAwait('setTargetPayload', { mass, cog, inertia });
    }
    /**
     * Get active TCP name
     * @returns `Observable<string>` emitting the name of the currently active TCP known to the controller.
     * If the TCP has been set without providing a name, this `Observable` will emit an empty `string`.
     * For documentation on `Observable`, see https://rxjs.dev/guide/observable
     */
    getActiveTCPName() {
        return this.postAndObserve('getActiveTCPName');
    }
}

const PROGRAM_CODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramCodeService.';
/**
 * Service that handles code generation
 */
class ProgramCodeService extends MessageInvokerService {
    /**
     * @constructor
     * @param target
     */
    constructor(eventTarget) {
        super(PROGRAM_CODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     *
     */
    async generateModulesScriptCode() {
        return this.postAndAwait('GENERATE_MODULES_SCRIPT_CODE', {});
    }
    /**
     *
     */
    async generateGlobalFunctionsScriptCode() {
        return this.postAndAwait('GENERATE_FUNCTIONS_SCRIPT_CODE', {});
    }
    /**
     *
     */
    async generateModulesAndGlobalFunctionsScriptCode() {
        return this.postAndAwait('GENERATE_MODULES_AND_FUNCTIONS_SCRIPT_CODE', {});
    }
    /**
     *
     */
    async getProgramPreambleScriptCode() {
        return this.postAndAwait('GET_PROGRAM_PREAMBLE_SCRIPT_CODE', {});
    }
    /**
     *
     */
    async generateFunctionScriptCode(functionNodeID) {
        return this.postAndAwait('GET_FUNCTION_SCRIPT_CODE', functionNodeID);
    }
}

const MOUNTING_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.MountingService.';
/**
 * Provides access to URScript functions
 * Parameters in this case are not aligned with setGravity
 * The input parameters are transformed into parameters for the setGravity URScript function
 * @see ScriptBuilder#setGravity
 */
class MountingService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(MOUNTING_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Sets the robot mounting as a rotation and a tilt
     * @param rotation The robot's rotation at the base
     * @param tilt The robot's tilt at the base
     */
    setMounting(rotation, tilt) {
        return this.postAndAwait('setMounting', { rotation, tilt });
    }
}

const FRAMES_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.FrameService.';
/**
 * Internal utility for overload implementation detail.
 */
function isZUpRotationVectorRadians$1(obj) {
    return 'zUpRotationVectorRadians' in obj;
}
/**
 * Create, Read, Update, Delete functionality for frames
 * Parameters are aligned with URScript functions, see URScript manual for more info.
 */
class FramesService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(FRAMES_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Implementation
     */
    addFrame(name, pose, refFrame = 'base') {
        return this.postAndAwait('addFrame', {
            name,
            pose: isControllerPose(pose) ? PoseUtils.asPose(pose) : pose,
            refFrame: isControllerPose(pose) ? pose.referenceFrame : refFrame,
        });
    }
    /**
     * Delete the frame named frame from the world model.
     * The "world", "base", and "tcp" frames cannot be deleted.
     * Any frames that are attached to the deleted frame will be attached to the "world" frame with new frame offsets set
     * such that the detached frame does not move in the world.
     * This command will fail if the frame does not exist.
     * @see ScriptBuilder#deleteFrame
     */
    deleteFrame(name) {
        return this.postAndAwait('deleteFrame', { name });
    }
    /**
     * Implementation
     */
    moveFrame(name, pose, refFrame = 'base') {
        return this.postAndAwait('moveFrame', {
            name,
            pose: isControllerPose(pose) ? PoseUtils.asPose(pose) : pose,
            refFrame: isControllerPose(pose) ? pose.referenceFrame : refFrame,
        });
    }
    /**
     * Implementation
     */
    setFrameOrientation(name, orientation) {
        return this.postAndAwait('setFrameOrientation', {
            name,
            orientation: isZUpRotationVectorRadians$1(orientation) ? orientation.zUpRotationVectorRadians : orientation,
        });
    }
    /**
     * Attaches the child frame to the parent world model object. The relative transform between the parent and child will be set such that
     * the child does not move in the world when the attachment occurs.
     * The child cannot be "world", "tcp", or the same as parent.
     * This will fail if child or parent is not an existing frame, or this makes the attachments form a closed chain.
     * @see ScriptBuilder#attachFrame
     */
    attachFrame(child, parent) {
        return this.postAndAwait('attachFrame', { child, parent });
    }
    /**
     * Returns an observable of live frame data.
     */
    observeFrames() {
        return this.postAndObserve('observeFrames');
    }
}

const OPERATOR_SCREEN_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.OperatorScreenService.';
/**
 * Service for handling updating of operator screen instances
 */
class OperatorScreenService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(OPERATOR_SCREEN_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Update the operator screen instance
     * @param operatorScreen New operator screen instance data
     */
    async updateOperatorScreen(operatorScreen) {
        return this.postAndAwait('updateOperatorScreen', { operatorScreen });
    }
}

const ROBOT_INFO_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.RobotInfoService.';
/**
 * Provides access to information on the robot
 */
class RobotInfoService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(ROBOT_INFO_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Get the robot type
     */
    getRobotType() {
        return this.postAndAwait('getRobotType');
    }
    /**
     * Get the robot serial number
     */
    getSerialNumber() {
        return this.postAndAwait('getSerialNumber');
    }
    /**
     * Checks if the robot is in 3 PE stop state.
     *
     * @returns {Observable<boolean>} - An observable that emits `true` if the robot
     * is in 3 PE stop state, otherwise `false`.
     */
    is3PEStop() {
        return this.postAndObserve('is3PEStop');
    }
    /**
     * Determines whether the robot is currently running.
     *
     * @returns {Observable<boolean>} An observable that emits `true` if the robot is running
     * (`robotMode === RUNNING`), otherwise `false`.
     */
    isRobotRunning() {
        return this.postAndObserve('isRobotRunning');
    }
}

const FREEDRIVE_STATE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.FreedriveStateService.';
/**
 * Provides access to freedrive information on the robot
 */
class FreedriveService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(FREEDRIVE_STATE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Get the freedrive state
     *
     * @returns {Observable<boolean>} An observable that emits `true` if the robot is in freedrive state
     */
    isInFreedrive() {
        return this.postAndObserve('isInFreedrive');
    }
}

const PROGRAM_TREE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramTreeService.';
/**
 * Service that handles node insertion and removal of nodes
 */
class ProgramTreeService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(PROGRAM_TREE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Update a specific node in the program tree using the given nodes id
     * @param node Node to be updated
     */
    async updateSubTreeNode(node) {
        return this.postAndAwait('updateSubTreeNode', { node: node.node, id: node.id });
    }
    /**
     * Update child node
     * @param node Child node to be updated
     * @deprecated Use {@link updateSubTreeNode} instead
     */
    async updateChildNode(node) {
        return this.postAndAwait('updateChildNode', node);
    }
    /**
     * Add node as either child or sibling
     * @param node node to be added
     */
    async addNode(node) {
        return this.postAndAwait('addNode', node);
    }
    /**
     * Add a node to the root of a program block, for example the main program or
     * the before start
     * @param The node, and other add parameters
     */
    async addBlockChildNode(node) {
        return this.postAndAwait('addBlockChildNode', node);
    }
    /**
     * Remove child node
     * @param node Child node to be removed
     */
    async removeChildNode(node) {
        return this.postAndAwait('removeChildNode', node);
    }
    /**
     * Sets the given node as the active program block
     * @param nodeID The node to navigate to
     */
    setActiveProgramBlock(nodeID) {
        return this.postAndAwait('setActiveProgramBlock', nodeID);
    }
    /**
     * Sets the given node as the active program block
     * @param nodeID The node to navigate to
     */
    selectProgramNode(nodeID) {
        return this.postAndAwait('selectProgramNode', nodeID);
    }
    /**
     * Get a readonly version of a given node
     * @param nodeID The node to get
     */
    getProgramNodeById(nodeID) {
        return this.postAndAwait('getProgramNodeById', nodeID);
    }
    /**
     * Get the tree context from a given program node
     */
    getTreeContextFromProgramNodeById(subTreeNodeId) {
        return this.postAndAwait('getTreeContextFromProgramNodeById', { subTreeNodeId });
    }
    /**
     * Get the subtree context from a given program node.
     * This returns the same traversals as getTreeContextFromProgramNodeById but will
     * return a SubtreeNode for ancestor and sibling calls.
     * For ancestor and sibling calls, where a SubtreeNode is not from the calling URCap,
     * then the SubtreeNode id will be ''.
     */
    getSubtreeContextFromProgramNodeById(subTreeNodeId) {
        return this.postAndAwait('getTreeContextFromProgramNodeById', { subTreeNodeId });
    }
    /**
     * Get the contributed node instances for the URCap that are currently inserted in the program
     */
    getContributedNodeInstancesForURCap() {
        return this.postAndAwait('getContributedNodeInstancesForURCap');
    }
}

const SETTINGS_MESSAGE_TYPE_BASE = 'ur.web.message.SettingsService.';
/**
 * A service for getting settings such as language and units
 */
class SettingsService extends MessageInvokerService {
    /**
     *
     */
    constructor(eventTarget) {
        super(SETTINGS_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Get the current robot settings as an observable
     */
    getRobotSettings() {
        return this.postAndObserve('getRobotSettings');
    }
    /**
     * Get the current robot settings once
     */
    getRobotSettingsOnce() {
        return this.postAndAwait('getRobotSettingsOnce');
    }
}

const PROGRAM_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramService.';
/**
 * Service for handling program related operations
 */
class ProgramService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(PROGRAM_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Will get information and metadata of all programs
     * @returns Promise<Array<ProgramInformation>>
     */
    async getProgramsList() {
        return this.postAndAwait('getProgramsList');
    }
    /**
     * Get a program
     * @param programInformation
     * @returns Promise<Program>
     */
    async getProgram(programInformation) {
        return this.postAndAwait('getProgram', { programInformation });
    }
    /**
     * Load program
     * @param programId The id of the program to load
     * @see {@link getPrograms} for getting the ids
     */
    loadProgram({ programId }) {
        return this.postAndAwait('loadProgram', { programId });
    }
    /**
     * Retrieves the loaded program's information.
     *
     * This method sends a request to the backend to retrieve the information of the currently loaded program.
     *
     * @returns {Promise<ProgramInformation>} A promise that resolves to the information of the loaded program.
     *
     * @example
     * // Usage example
     * const programInfo = await this.presenterAPI.programService.getLoadedProgram()
     * console.log('Loaded Program Information:', programInfo);
     *
     */
    getLoadedProgram() {
        return this.postAndAwait('getLoadedProgram');
    }
}

const SMART_SKILL_EXECUTION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SmartSkillExecutionService.';
/**
 * Service that handles executing smart skill instances
 */
class SmartSkillExecutionService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SMART_SKILL_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Execute the smart skill instance
     * @param instance Smart skill instance to execute
     */
    async executeInstance(instance) {
        return this.postAndAwait('executeInstance', {
            instance,
        });
    }
    /**
     * Stop the smart skill instance
     * @param instance Smart skill instance to stop
     */
    async stopInstance(instance) {
        return this.postAndAwait('stopInstance', {
            instance,
        });
    }
    /**
     * Get active smart skill observable
     */
    activeSmartSkill() {
        return this.postAndObserve('getActiveSmartSkillObservable', {});
    }
    /**
     * Will be false if 3PE is disengaged, robot is powered off or Freedrive is enabled.
     */
    executionAllowed() {
        return this.postAndObserve('getExecutionAllowedObservable', {});
    }
    /**
     * Wait for the active smart skill to stop
     */
    async waitForActiveSmartSkillToStop(timeoutMs) {
        const timeoutPromise = new Promise((_, reject) => {
            if (timeoutMs !== undefined) {
                setTimeout(() => reject(new Error('Timeout waiting for active smart skill to stop')), timeoutMs);
            }
        });
        const waitForSkillToStop = new Promise((resolve) => {
            this.activeSmartSkill()
                .pipe(filter((skill) => skill === undefined), take(1))
                .subscribe(() => resolve());
        });
        return Promise.race([waitForSkillToStop, timeoutPromise]);
    }
}

const SYSTEM_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SystemService.';
/**
 * Service that handles system information.
 */
class SystemService extends MessageInvokerService {
    /**
     * Create a service for the specific worker
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SYSTEM_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Get the software version.
     * @returns The software version.
     */
    getSoftwareVersion() {
        return this.postAndAwait('getSoftwareVersion');
    }
}

const MOTION_PROFILES_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.MotionProfilesService.';
/**
 * Service for getting information of motion profiles
 */
class MotionProfilesService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(MOTION_PROFILES_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Returns the data stored on the specified Motion Profiles type
     * @param type the type of the Motion Profiles to fetch:
     * - joint
     * - linear
     * - process
     */
    getMotionProfiles(type) {
        return this.postAndAwait('getMotionProfiles', { type });
    }
}

const TEACH_MODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.TeachModeService.';
/**
 * Service that handles teach mode for generating program nodes.
 */
class TeachModeService extends MessageInvokerService {
    /**
     * Creates an instance of TeachModeService.
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(TEACH_MODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Starts a teach mode session.
     */
    async startTeachMode() {
        return this.postAndAwait('startTeachMode', {});
    }
    /**
     * Stops the current teach mode session.
     */
    async stopTeachMode() {
        return this.postAndAwait('stopTeachMode', {});
    }
    /**
     * Pauses the current teach mode session.
     */
    async pauseTeachMode() {
        return this.postAndAwait('pauseTeachMode', {});
    }
    /**
     * Pauses the current teach mode session.
     */
    async resumeTeachMode() {
        return this.postAndAwait('resumeTeachMode', {});
    }
    /**
     * Retrieves the current state of the teach mode session.
     * @returns An Observable with the current state of the teach mode session.
     */
    getTeachModeState() {
        return this.postAndObserve('getTeachModeState', {});
    }
}

const APPLICATION_VARIABLES_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ApplicationVariablesService.';
/**
 * Service for managing application variables.
 */
class ApplicationVariablesService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(APPLICATION_VARIABLES_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Retrieves all application variables as an observable.
     * @experimental
     * @returns An observable that emits a record of application variables.
     */
    applicationVariables() {
        return this.postAndObserve('applicationVariables');
    }
    /**
     * Sends request to initialize variables in controller and store.
     * @experimental
     * @param variableMap - A record mapping variable names to ApplicationVariable objects.
     */
    initializeVariables(variables) {
        return this.postAndAwait('initializeVariables', variables);
    }
    /**
     * Sends request to clean up variables in controller.
     * @experimental
     * @param variables - A record mapping variable names to ApplicationVariable objects.
     */
    cleanUpControllerVariables() {
        return this.postAndAwait('cleanUpControllerVariables');
    }
    /**
     * Sends request to set value of an existing variable.
     * @experimental
     * @param variable - The ApplicationVariable object to create.
     */
    setVariable(variable) {
        return this.postAndAwait('setVariable', variable);
    }
    /**
     * Sends request to create a new variable.
     * @experimental
     * @param variable - The ApplicationVariable object to create.
     */
    createVariable(variable) {
        return this.postAndAwait('createVariable', variable);
    }
    /**
     * Sends request to delete an existing variable.
     * @experimental
     * @param variableName - The name of the variable to delete.
     */
    deleteVariable(variableName) {
        return this.postAndAwait('deleteVariable', variableName);
    }
}

const SCRIPT_FILE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ScriptFileService.';
/**
 * Service for getting script files
 */
class ScriptFileService extends MessageInvokerService {
    /**
     * @constructor
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(SCRIPT_FILE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Returns the script files that are available. This will not contain the urscript content
     */
    getScriptFiles() {
        return this.postAndAwait('getScriptFiles');
    }
    /**
     * Returns a script file for a given name, including the urscript content
     * @param name
     */
    getScriptFile(name) {
        return this.postAndAwait('getScriptFile', name);
    }
}

const EXPRESSION_EDITOR_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ExpressionEditorService.';
/**
 * Service that handles editing expressions
 */
class ExpressionEditorService extends MessageInvokerService {
    /**
     * Create a service for the specific eventTarget
     * @param eventTarget
     */
    constructor(eventTarget) {
        super(EXPRESSION_EDITOR_SERVICE_MESSAGE_TYPE_BASE, eventTarget);
        this.eventTarget = eventTarget;
    }
    /**
     * Returns content that can be inserted on the expression tab of the tab input
     * @returns Arrays of the different types of insertables, eg inputs, outputs, built in
     * functions
     */
    getTabInputInsertableModel() {
        return this.postAndAwait('getTabInputInsertableModel');
    }
}

/**
 * Enum for HistoryPolicy
 * @readonly
 * @enum {number}
 */
var HistoryPolicy;
(function (HistoryPolicy) {
    HistoryPolicy[HistoryPolicy["SYSTEM_DEFAULT"] = 0] = "SYSTEM_DEFAULT";
    HistoryPolicy[HistoryPolicy["KEEP_LAST"] = 1] = "KEEP_LAST";
    HistoryPolicy[HistoryPolicy["KEEP_ALL"] = 2] = "KEEP_ALL";
    HistoryPolicy[HistoryPolicy["UNKNOWN"] = 3] = "UNKNOWN";
})(HistoryPolicy || (HistoryPolicy = {}));
/**
 * Enum for ReliabilityPolicy
 * @readonly
 * @enum {number}
 */
var ReliabilityPolicy;
(function (ReliabilityPolicy) {
    ReliabilityPolicy[ReliabilityPolicy["SYSTEM_DEFAULT"] = 0] = "SYSTEM_DEFAULT";
    ReliabilityPolicy[ReliabilityPolicy["RELIABLE"] = 1] = "RELIABLE";
    ReliabilityPolicy[ReliabilityPolicy["BEST_EFFORT"] = 2] = "BEST_EFFORT";
    ReliabilityPolicy[ReliabilityPolicy["UNKNOWN"] = 3] = "UNKNOWN";
})(ReliabilityPolicy || (ReliabilityPolicy = {}));
/**
 * Enum for DurabilityPolicy
 * @readonly
 * @enum {number}
 */
var DurabilityPolicy;
(function (DurabilityPolicy) {
    DurabilityPolicy[DurabilityPolicy["SYSTEM_DEFAULT"] = 0] = "SYSTEM_DEFAULT";
    DurabilityPolicy[DurabilityPolicy["TRANSIENT_LOCAL"] = 1] = "TRANSIENT_LOCAL";
    DurabilityPolicy[DurabilityPolicy["VOLATILE"] = 2] = "VOLATILE";
    DurabilityPolicy[DurabilityPolicy["UNKNOWN"] = 3] = "UNKNOWN";
})(DurabilityPolicy || (DurabilityPolicy = {}));
/**
 * QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.
 * For a subscriber, these are its requirements for its topic's publishers.
 * @readonly
 * @enum {number}
 */
var LivelinessPolicy;
(function (LivelinessPolicy) {
    LivelinessPolicy[LivelinessPolicy["SYSTEM_DEFAULT"] = 0] = "SYSTEM_DEFAULT";
    LivelinessPolicy[LivelinessPolicy["AUTOMATIC"] = 1] = "AUTOMATIC";
    LivelinessPolicy[LivelinessPolicy["MANUAL_BY_NODE"] = 2] = "MANUAL_BY_NODE";
    LivelinessPolicy[LivelinessPolicy["MANUAL_BY_TOPIC"] = 3] = "MANUAL_BY_TOPIC";
    LivelinessPolicy[LivelinessPolicy["UNKNOWN"] = 4] = "UNKNOWN";
})(LivelinessPolicy || (LivelinessPolicy = {}));
/**
 * The quality of service profile for ROS2 communication.
 * @dynamic
 */
class QoSProfile {
    /**
     * Get HistoryPolicy enum.
     * @return HistoryPolicy
     */
    static { this.HistoryPolicy = HistoryPolicy; }
    /**
     * Get ReliabilityPolicy enum.
     * @return ReliabilityPolicy
     */
    static { this.ReliabilityPolicy = ReliabilityPolicy; }
    /**
     * Get DurabilityPolicy enum.
     * @return DurabilityPolicy
     */
    static { this.DurabilityPolicy = DurabilityPolicy; }
    /**
     * Get LivelinessPolicy enum
     * @return LivelinessPolicy
     */
    static { this.LivelinessPolicy = LivelinessPolicy; }
    /**
     * Default duration is duration unspecified
     */
    static get DurationUnspecified() {
        return { seconds: 0, nanoseconds: 0 };
    }
    /**
     * Default duration is duration unspecified
     */
    static get DurationInfinite() {
        return { seconds: 9223372036, nanoseconds: 854775807 };
    }
    /**
     * Get default profile. Default values are:
     *     HistoryPolicy = KEEP_LAST,
     *     depth = 10,
     *     ReliabilityPolicy = RELIABLE,
     *     DurabilityPolicy = VOLATILE,
     *     deadline = QoSProfile.DurationUnspecified,
     *     lifespan = QoSProfile.DurationUnspecified,
     *     LivelinessPolicy = SYSTEM_DEFAULT,
     *     liveliness_lease_duration = QoSProfile.DurationUnspecified,
     *     avoid_ros_namespace_conventions = false
     * @return QoSProfile
     */
    static get default() {
        return new QoSProfile(HistoryPolicy.KEEP_LAST, 10, ReliabilityPolicy.RELIABLE, DurabilityPolicy.VOLATILE, QoSProfile.DurationUnspecified, QoSProfile.DurationUnspecified, LivelinessPolicy.SYSTEM_DEFAULT, QoSProfile.DurationUnspecified, false);
    }
    /**
     * Get most compatible QoS profile with Reliability set to BEST_EFFORT. Values are:
     *     HistoryPolicy = KEEP_LAST,
     *     depth = 10,
     *     ReliabilityPolicy = BEST_EFFORT,
     *     DurabilityPolicy = VOLATILE,
     *     deadline = QoSProfile.DurationUnspecified,
     *     lifespan = QoSProfile.DurationUnspecified,
     *     LivelinessPolicy = SYSTEM_DEFAULT,
     *     liveliness_lease_duration = QoSProfile.DurationUnspecified,
     *     avoid_ros_namespace_conventions = false
     * @return QoSProfile
     */
    static get compatible() {
        return new QoSProfile(HistoryPolicy.KEEP_LAST, 10, ReliabilityPolicy.BEST_EFFORT, DurabilityPolicy.VOLATILE, QoSProfile.DurationUnspecified, QoSProfile.DurationUnspecified, LivelinessPolicy.SYSTEM_DEFAULT, QoSProfile.DurationUnspecified, false);
    }
    /**
     * Create a QosProfile for ROS2 communication.
     * @param history HistoryPolicy The history value, default value is HistoryPolicy.KEEP_LAST.
     * @param depth number The depth value, default value is depth=10.
     * @param reliability ReliabilityPolicy The reliability value, default value is ReliabilityPolicy.RELIABLE.
     * @param durability DurabilityPolicy The durability value, default value is DurabilityPolicy.VOLATILE.
     * @param deadline The deadline value, default value is DurationUnspecified.
     * @param lifespan The lifespan value, default value is DurationUnspecified.
     * @param liveliness LivelinessPolicy The liveliness value, default value is LivelinessPolicy.SYSTEM_DEFAULT.
     * @param liveliness_lease_duration The liveliness_lease_duration value, default values is DurationUnspecified.
     * @param avoid_ros_namespace_conventions The avoid_ros_namespace_conventions value, default value=false.
     */
    constructor(history = HistoryPolicy.KEEP_LAST, depth = 10, reliability = ReliabilityPolicy.RELIABLE, durability = DurabilityPolicy.VOLATILE, deadline = QoSProfile.DurationUnspecified, lifespan = QoSProfile.DurationUnspecified, liveliness = LivelinessPolicy.SYSTEM_DEFAULT, liveliness_lease_duration = QoSProfile.DurationUnspecified, avoid_ros_namespace_conventions = false) {
        this.history = history;
        this.depth = depth;
        this.reliability = reliability;
        this.durability = durability;
        this.deadline = deadline;
        this.lifespan = lifespan;
        this.liveliness = liveliness;
        this.liveliness_lease_duration = liveliness_lease_duration;
        this.avoid_ros_namespace_conventions = avoid_ros_namespace_conventions;
    }
}

/**
 * Check if message is an exception, throw error if exception
 * @param msg message to check
 */
const assertNotException = (msg) => {
    if (isException(msg)) {
        throw new Error(msg.exception);
    }
};
/**
 * Check if message is an exception
 * @param msg
 * @private
 * @return boolean true if exception
 */
function isException(msg) {
    return msg.exception !== undefined && msg.message !== undefined;
}
/**
 * The UR TypeScript API for ROS 2
 */
class Ros2Client {
    /**
     * Get Id for connection
     * @return Id for connection
     * @private
     */
    getConnectionId() {
        return Guid.create().toString();
    }
    /**
     * Create Ros2Client ROS2 client for UR ROS2 Web Bridge
     * @constructor
     * @param ros2Service Ros2 service for ROS2 communication
     */
    constructor(ros2Service) {
        this.ros2Service = ros2Service;
    }
    /**
     * Get topic path to be used for ROS2 communication, including optional robot namespace and custom namespace.
     * @param prependRobotNamespace boolean if true then local ROS2 robot namespace will be prepended to topic.
     * @param topic string to be used for ROS2 communication.
     * @param namespace optional namespaces to prepend topic.
     * @return TopicPath extending Promise<string>
     */
    async getTopicPath(prependRobotNamespace, topic, ...namespace) {
        return await this.getPath(prependRobotNamespace, topic, namespace);
    }
    /**
     * Get service path to be used for ROS2 communication, including optional robot namespace and custom namespace.
     * @param prependRobotNamespace boolean if true then local ROS2 robot namespace will be prepended to service name.
     * @param serviceName string to be used for ROS2 communication.
     * @param namespace optional namespaces to prepend service name.
     * @return ServicePath extending Promise<string>
     */
    async getServicePath(prependRobotNamespace, serviceName, ...namespace) {
        return await this.getPath(prependRobotNamespace, serviceName, namespace);
    }
    /**
     * Get promise path
     * @param prependRobotNamespace
     * @param topicOrMessageName
     * @param namespace
     * @return Promise<String>
     * @private
     */
    async getPath(prependRobotNamespace, topicOrMessageName, namespace) {
        let localNamespace = namespace.length > 0 ? namespace.join('/').replace(/^\/?/, '').replace(/\/?$/, '') : '';
        localNamespace = localNamespace.length > 0 ? `/${localNamespace}/` : '';
        if (prependRobotNamespace) {
            const ros2Namespace = await this.getRobotNamespace();
            let rosNamespacePath = ros2Namespace?.length > 0 ? ros2Namespace.replace(/^\/?/, '/').replace(/\/?$/, '') : '';
            rosNamespacePath = rosNamespacePath.length > 0 && localNamespace.length === 0 ? rosNamespacePath + '/' : rosNamespacePath;
            return rosNamespacePath + localNamespace + topicOrMessageName;
        }
        return localNamespace + topicOrMessageName;
    }
    /**
     * Get RobotNamespace
     * @private
     */
    async getRobotNamespace() {
        if (!this.robotNamespace) {
            this.robotNamespace = await this.ros2Service.getRos2Namespace();
        }
        return this.robotNamespace;
    }
    /**
     * Create a new subscription to a ROS2 topic.
     * @param messageType The type of ROS messages the subscription will subscribe to.
     * @param topicPath TopicPath The name of the topic the subscription will subscribe to, may include ros2 namespace.
     * @param qosProfile optional quality of service profile to apply to the subscription. Default is QoSProfile.default.
     * @return Observable to subscribe to
     */
    createSubscription(messageType, topicPath, qosProfile = QoSProfile.default) {
        const connectionId = this.getConnectionId();
        return this.ros2Service.subscribe(connectionId, messageType, topicPath, qosProfile).pipe(tap(assertNotException), map$1((rt) => rt.msg));
    }
    /**
     * Create a new subscription for frame transformation
     * @param targetFrame
     * @param sourceFrame
     * @return Observable to subscribe to
     * @deprecated Use framesService.observeFrames and convertPose instead.
     */
    createTransformSubscription(targetFrame, sourceFrame) {
        const connectionId = this.getConnectionId();
        return this.ros2Service.subscribeTransform(connectionId, targetFrame, sourceFrame).pipe(tap(assertNotException), switchMap((rt) => {
            if (rt.msg?.error) {
                return throwError(() => new Error(rt.msg.error));
            }
            return of(rt);
        }), map$1((rt) => rt.msg));
    }
    /**
     * Make a ROS2 service call for setting argumentValues on a service, and return an observable of type T.
     * @param serviceType The type of ROS service to set argumentValues on.
     * @param servicePath ServicePath The name of the service to set argumentValues on, may include namespace.
     * @param argumentValues Values to be set.
     * @param qosProfile optional quality of service profile to apply to the service client. Default is QoSProfile.default.
     * @param timeout optional float value in seconds, default is 30.0 seconds before timeout.
     * @return The first message returned from the service call.
     */
    async callService(serviceType, servicePath, argumentValues, qosProfile = QoSProfile.default, timeout = 30.0) {
        const connectionId = this.getConnectionId();
        return await firstValueFrom(this.ros2Service.callService(connectionId, serviceType, servicePath, argumentValues, qosProfile, timeout).pipe(tap(assertNotException), map$1((rt) => rt.msg)));
    }
}

const ROS2_MESSAGE_TYPE_BASE = 'ur.web.message.Ros2Service.';
/**
 * Service for ROS2 communication
 * Uses event based messaging for communication
 */
class Ros2EventService extends MessageInvokerService {
    /**
     * Create event based messaging implementation of the Ros2ServiceApi for ROS2 communication
     * @param target Either a Worker to be used as the EventTarget or a standard
     */
    constructor(target) {
        super(ROS2_MESSAGE_TYPE_BASE, target);
        this.target = target;
    }
    /**
     * Get local ROS2 robot namespace
     * @return Promise containing local ROS2 robot namespace
     */
    getRos2Namespace() {
        return this.postAndAwait('getRos2Namespace', {});
    }
    /**
     * Subscribe to topicPath with given message type using QoS profile
     * @param connectionId Id for subscription
     * @param messageType
     * @param topic
     * @param qosProfile optional quality of service profile to apply to the subscription. Default is QoSProfile.default.
     * @return Observable to subscribe to
     */
    subscribe(connectionId, messageType, topic, qosProfile = QoSProfile.default) {
        return this.postAndObserve('subscribe', {
            connectionId,
            messageType,
            topic,
            qosProfile,
        });
    }
    /**
     * Subscribe to frame transformation
     * @param connectionId Id for subscription
     * @param targetFrame
     * @param sourceFrame
     * @param publishRate in milliseconds
     * @return Observable to subscribe to
     */
    subscribeTransform(connectionId, targetFrame, sourceFrame, publishRate = 100) {
        return this.postAndObserve('subscribeTransform', {
            connectionId,
            targetFrame,
            sourceFrame,
            publishRate,
        });
    }
    /**
     * Call service to set argumentValues of service type on service name
     * @param connectionId Id for subscription
     * @param serviceType
     * @param serviceName
     * @param argumentValues
     * @param qosProfile optional quality of service profile to apply to the service client. Default is QoSProfile.default.
     * @param timeout optional float value in seconds, default is 30.0 seconds before timeout.
     * @return Promise with value
     */
    callService(connectionId, serviceType, serviceName, argumentValues, qosProfile = QoSProfile.default, timeout = 30.0) {
        return this.postAndObserve('callService', {
            connectionId,
            serviceType,
            serviceName,
            argumentValues,
            qosProfile,
            timeout,
        });
    }
}

/**
 * Provides access to common related API features in both BehaviorWorkers
 * and Presenters
 */
class CommonBehaviorAPI {
    /** Creates a new instance of the CommonAPI based on either a Worker
     * or an instance of an EventTarget, to allow communication with the
     * surrounding apis from within the Worker or WebComponent
     *
     * @param target Either a Worker to be used as the EventTarget or a standard
     * EventTarget
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new WorkerCommunicationChannel(target);
        }
        this.applicationService = new ApplicationService(communicationChannel);
        this.logMessageService = new LogMessageService(communicationChannel);
        this.logPerformanceService = new LogPerformanceService(communicationChannel);
        this.ros2Client = new Ros2Client(new Ros2EventService(communicationChannel));
        this.safetyService = new SafetyService(communicationChannel);
        this.sourceService = new SourceService(communicationChannel);
        this.robotPositionService = new RobotPositionService(communicationChannel);
        this.symbolService = new SymbolService(communicationChannel);
        this.robotInfoService = new RobotInfoService(communicationChannel);
        this.programTreeService = new ProgramTreeService(communicationChannel);
        this.settingsService = new SettingsService(communicationChannel);
        this.systemService = new SystemService(communicationChannel);
        this.dialogService = new DialogService(communicationChannel);
        this.expressionEditorService = new ExpressionEditorService(communicationChannel);
    }
    /**
     * Creates a URL string for communicating with backend Container Contributions
     * A protocol must be prepended to the string, like 'http://' or 'ws://'
     * @param vendorID Id of Vendor as specified in manifest.yaml file
     * @param urcapID Id of URCap as specified in manifest.yaml file
     * @param containerName Name of Container as specified in manifest.yaml file
     * @param serviceName Name of Service as specified by Ingress name in manifest.yaml file
     * @return URL string without protocol.
     */
    getContainerContributionURL(vendorID, urcapID, containerName, serviceName) {
        return `${location.host}/${vendorID}/${urcapID}/${containerName}/${serviceName}`;
    }
}
/**
 * Provides access to common related API features in Presenters
 */
class CommonPresenterAPI extends CommonBehaviorAPI {
    /** Creates a new instance of the CommonAPI based on an instance of an EventTarget,
     * to allow communication with the
     * surrounding apis from within the Worker or WebComponent
     *
     * @param target An EventTarget
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.snackbarService = new SnackbarService(communicationChannel);
        this.programService = new ProgramService(communicationChannel);
    }
}

/**
 * Provides access to Application related API features in ApplicationBehaviors
 */
class ApplicationBehaviorAPI extends CommonBehaviorAPI {
    /** Creates a new instance of the ApplicationBehaviorAPI to allow communication with the
     * surrounding application from within a WebWorker
     *
     * @param target A worker, provided with 'self' when created inside a web worker
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new WorkerCommunicationChannel(target);
        }
        super(communicationChannel);
        this.toolService = new ToolService(communicationChannel);
        this.mountingService = new MountingService(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
        this.applicationVariablesService = new ApplicationVariablesService(communicationChannel);
    }
}
/**
 * Provides access to Application related API features in ApplicationPresenters
 */
class ApplicationPresenterAPI extends CommonPresenterAPI {
    /** Creates a new instance of the ApplicationPresenterAPI, to allow communication with the
     * surrounding application from within a WebComponent
     *
     * @param target An EventTarget, provided by PolyScope X
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.applicationNodeService = new ApplicationNodeService(communicationChannel);
        this.applicationVariablesService = new ApplicationVariablesService(communicationChannel);
        this.robotMoveService = new RobotMoveService(communicationChannel);
        this.programExecutionService = new ProgramExecutionService(communicationChannel);
        this.toolService = new ToolService(communicationChannel);
        this.mountingService = new MountingService(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
    }
}

/**
 * Provides access to Program related API features in both BehaviorWorkers
 * and ProgramPresenters
 */
class ProgramBehaviorAPI extends CommonBehaviorAPI {
    /** Creates a new instance of the ProgramBehaviorAPI to allow communication with the
     * surrounding application from within a WebWorker
     *
     * @param target A worker, provided with 'self' when created inside a web worker
     */
    constructor(target) {
        const communicationChannel = createWorkerCommChannel(target);
        super(communicationChannel);
        this.builder = new TreeBuilder(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
        this.motionProfilesService = new MotionProfilesService(communicationChannel);
        this.scriptFileService = new ScriptFileService(communicationChannel);
    }
}
/**
 * ProgramPresenterAPI
 */
class ProgramPresenterAPI extends CommonPresenterAPI {
    /** Creates a new instance of the ProgramPresenterAPI, to allow communication with the
     * surrounding application from within a WebComponent
     *
     * @param target An EventTarget, provided by PolyScope X
     * @param selectedNodeId the id of the currently selected program node
     */
    constructor(target, selectedNodeId) {
        const communicationChannel = createEventTargetCommChannel(target);
        super(communicationChannel);
        this.selectedNodeId = selectedNodeId;
        this.programNodeService = new ProgramNodeService(communicationChannel, selectedNodeId);
        this.robotMoveService = new RobotMoveService(communicationChannel);
        this.validationService = new ValidationService(communicationChannel, selectedNodeId);
        this.builder = new TreeBuilder(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
        this.motionProfilesService = new MotionProfilesService(communicationChannel);
        this.scriptFileService = new ScriptFileService(communicationChannel);
    }
}

/**
 * Provides access to source related API features in Source Behaviors
 */
class SourceBehaviorAPI extends CommonBehaviorAPI {
    /** Creates a new instance of the SourceBehaviorAPI to allow communication with the
     * surrounding application from within a WebWorker
     *
     * @param target A worker, provided with 'self' when created inside a web worker
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new WorkerCommunicationChannel(target);
        }
        super(communicationChannel);
    }
}
/**
 * Provides access to source related API features in Source Presenters
 */
class SourcePresenterAPI extends CommonPresenterAPI {
    /** Creates a new instance of the SourcePresenterAPI, to allow communication with the
     * surrounding application from within a WebComponent
     *
     * @param target An EventTarget, provided by PolyScope X
     * @param sourceID ID for this source
     */
    constructor(target, sourceID) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.sourceID = sourceID;
        this.signalService = new SignalService(communicationChannel, sourceID);
        this.sourceNodeService = new SourceNodeService(communicationChannel);
    }
}

/**
 * Provides access to Smart Skills related API features in BehaviorWorkers
 */
class SmartSkillsBehaviorAPI extends CommonBehaviorAPI {
    /** Creates a new instance of the SmartSkillsBehaviorAPI to allow communication with the
     * surrounding application from within a WebWorker
     *
     * @param target A worker, provided with 'self' when created inside a web worker
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new WorkerCommunicationChannel(target);
        }
        super(communicationChannel);
        this.builder = new TreeBuilder(communicationChannel);
        this.programCode = new ProgramCodeService(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
    }
}
/**
 *
 */
class SmartSkillsPresenterAPI extends CommonPresenterAPI {
    /**
     * Create a new instance of the SmartSkillsPresenterAPI to allow a Presenter to interact with the API and update itself
     */
    constructor(target, name) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.smartSkillInstanceService = new SmartSkillInstanceService(communicationChannel);
        this.robotMoveService = new RobotMoveService(communicationChannel);
        this.freedriveService = new FreedriveService(communicationChannel);
    }
}

/**
 * Checks that the message coming is in a SerializableApplicationContext
 * @param message The message to serialize
 */
function isSerializedApplicationContext(message) {
    return message && message.type === '$$ApplicationContext';
}
/**
 * Creates the serializer for the ApplicationContext. Handles serializing and deserializing of the object.
 * @constructor
 */
const ApplicationContextSerializer = () => {
    return {
        /**
         * deserialize the message using a given handler
         * @param message
         * @param defaultHandler
         */
        deserialize(message, defaultHandler) {
            if (isSerializedApplicationContext(message)) {
                // created the application context from the message
                return {
                    contributions: {
                        contributionList: message.contributions?.contributionList ?? [],
                        /**
                         * Returns a Contribution node base on the param
                         * @param type String specifying the contribution node to fetch
                         */
                        getContribution(type) {
                            return this.contributionList.find((contribution) => contribution.parentType === type);
                        },
                    },
                    frames: {
                        framesList: message.frames?.framesList ?? [],
                        /**
                         * Returns a Frame base on the param
                         * @param frameId String specifying the frame to fetch
                         */
                        getFrame(frameId) {
                            return this.framesList.find((frame) => frame.name === frameId);
                        },
                    },
                };
            }
            else {
                return defaultHandler(message);
            }
        },
        /**
         * serializing the item using a give handler
         * @param item
         * @param defaultHandler
         */
        serialize(item, defaultHandler) {
            if (isSerializedApplicationContext(item)) {
                return {
                    type: '$$ApplicationContext',
                    contributions: {
                        contributionList: item.contributions?.contributionList ?? [],
                    },
                    frames: {
                        framesList: item.frames?.framesList ?? [],
                    },
                };
            }
            else {
                return defaultHandler(item);
            }
        },
    };
};

/**
 * An asynchronous array iterator
 */
class AsyncArrayTraverser {
    /**
     * @param nodes the array of nodes to iterate
     */
    constructor(nodes) {
        this.pointer = 0;
        this.values = nodes;
    }
    /**
     * provide the next element for the iterator
     */
    async next() {
        if (this.pointer < this.values.length) {
            const index = this.pointer;
            this.pointer++;
            return {
                done: false,
                value: this.values[index],
            };
        }
        return {
            done: true,
            value: null,
        };
    }
    /**
     * returns the asynchronous iterator
     */
    [Symbol.asyncIterator]() {
        return this;
    }
}

/**
 * Checks that the message coming is in a isSerializedInsertionContext
 * @param message
 */
function isSerializedInsertionContext(message) {
    return message && message.type === '$$InsertionContext';
}
/**
 * Creates the serializer for the InsertionContext. Handles serializing and deserializing of the object.
 * @constructor
 */
const InsertionContextSerializer = () => {
    return {
        /**
         * Deserializes the message as a new InsertionContext based on the message inputs
         * @param message Message containing the values to be parsed to the new InsertionContext
         * @param defaultHandler The object to handle deserializing if not of type InsertionContext
         */
        deserialize(message, defaultHandler) {
            if (isSerializedInsertionContext(message)) {
                return {
                    traverse: {
                        ancestors: new AsyncArrayTraverser(message.ancestors ? message.ancestors : []),
                        nextSiblings: new AsyncArrayTraverser(message.nextSiblings ? message.nextSiblings : []),
                        previousSiblings: new AsyncArrayTraverser(message.previousSiblings ? message.previousSiblings : []),
                    },
                };
            }
            else {
                return defaultHandler(message);
            }
        },
        /**
         * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning
         * @param item The original item that will be serialized
         * @param defaultHandler The object to handle serializing if not of type InsertionContext
         */
        serialize(item, defaultHandler) {
            if (isSerializedInsertionContext(item)) {
                return {
                    type: '$$InsertionContext',
                    ancestors: item.ancestors,
                    previousSiblings: item.previousSiblings,
                    nextSiblings: item.nextSiblings,
                };
            }
            else {
                return defaultHandler(item);
            }
        },
    };
};

/**
 * Internal utility for overload implementation detail.
 */
function isZUpRotationVectorRadians(pose) {
    return 'zUpRotationVectorRadians' in pose;
}
/**
 * Internal utility for formatting POSE value for URScript.
 */
function formatPoseValueForURScript(value) {
    return `p[${value}]`;
}
/**
 * Internal utility for formatting BOOLEAN value for URScript.
 */
function formatBooleanValueForURScript(value) {
    const boolValue = typeof value === 'string' ? value.toLowerCase() === 'true' : Boolean(value);
    return ScriptBuilder.getBooleanAsString(boolValue);
}
/**
 * Internal utility for formatting ARRAY value for URScript.
 */
function formatArrayValueForURScript(value) {
    return `[${value}]`;
}
/**
 * Internal utility for formatting STRING value for URScript.
 */
function formatStringValueForURScript(value) {
    return /^"(.*)"$/.test(value) ? value : `"${value}"`;
}
/**
 * Internal utility for formatting MATRIX value for URScript.
 */
function formatMatrixValueForURScript(value) {
    if (Array.isArray(value)) {
        return JSON.stringify(value);
    }
    if (typeof value === 'string' && value.startsWith('[') && value.endsWith(']')) {
        return value;
    }
    return String(value);
}
/**
 *
 * ScriptBuilder provides methods to easily generate well indented UR script programmatically.
 * This class manages indentation automatically as the script is built step by step.
 * But,it does not guarantee perfect formatting as there is a possibility to pass badly formatted expressions, statements or scripts.
 *
 */
class ScriptBuilder {
    static { this.SINGLE_INDENT = '  '; }
    static { this.SINGLE_INDENT_LEVEL = 1; }
    /**
     * Creates a new ScriptBuilder
     *
     * @param script If a script is specified, the new ScriptBuilder will be preloaded with that script
     * @param initialIndent If an indent is specified, the ScriptBuilder will be initialized with that indent
     */
    constructor(script = '', initialIndent = 0) {
        this.type = '$$ScriptBuilder';
        this.script = '';
        this.currentIndent = 0;
        this.addStatements(script);
        this.currentIndent = initialIndent;
    }
    /**
     * Generate the String representation of a boolean.
     *
     * @param b The input boolean
     * @return The String representation of the input
     */
    static getBooleanAsString(b) {
        return b ? 'True' : 'False';
    }
    /**
     * Return a String representing the URScript for negating an expression.
     * @param expression The expression to be negated
     * @return String representation of the negated expression.
     */
    /**
     *
     * @param expression The expression to be negated
     */
    static negate(expression) {
        return `not (${expression})`;
    }
    /**
     * Return a String representation of the input array.
     * @param input the input array.
     * @return String representation of the input array.
     */
    static formatArray(input) {
        let stringElem;
        let result;
        result = '[';
        input.forEach((elem, index) => {
            if (typeof elem === 'boolean') {
                stringElem = ScriptBuilder.getBooleanAsString(elem);
            }
            else if (typeof elem === 'string') {
                stringElem = `"${elem}"`;
            }
            else {
                stringElem = elem.toString();
            }
            result += stringElem;
            if (index < input.length - 1) {
                result += ', ';
            }
        });
        return result + ']';
    }
    /**
     * Converts a variable's value to a URScript-compatible literal string based on its declared type.
     *
     * Handles proper formatting for POSE, BOOLEAN, ARRAY, and STRING types to ensure valid URScript syntax.
     * - Strings like "true"/"false" are parsed to booleans when the variable type is BOOLEAN.
     * - Arrays passed as comma-separated strings or raw arrays are parsed and validated for homogeneity.
     * - POSE values are returned as-is within a `p[...]` wrapper, assuming correct formatting.
     * - Returns an empty string `''` for invalid or mixed-type array inputs, or if the variable type is missing.
     *
     * @param variable The URVariable object containing the variable's metadata.
     * @param value The value to be converted. Typically a string, but may also be a boolean, number, or array.
     * @returns The value formatted as a URScript-compatible literal string.
     */
    static formatVariableToURScriptLiteral(variable, value) {
        if (!variable || variable.valueType === undefined) {
            return '';
        }
        switch (variable.valueType) {
            case VariableValueType.POSE:
                return formatPoseValueForURScript(value);
            case VariableValueType.BOOLEAN:
                return formatBooleanValueForURScript(value);
            case VariableValueType.ARRAY:
                return formatArrayValueForURScript(value);
            case VariableValueType.STRING:
                return formatStringValueForURScript(value);
            case VariableValueType.MATRIX:
                return formatMatrixValueForURScript(value);
            default:
                return String(value);
        }
    }
    /**
     * Create a ScriptBuilder preloaded with the incognito program definition.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} before
     * calling {@link #getScript()}.
     *
     * @return new ScriptBuilder.
     */
    static CreateInkognitoProgram() {
        return new ScriptBuilder().defineFunction('inkognito');
    }
    /**
     * Create a ScriptBuilder preloaded with a secondary program definition.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} before
     * calling {@link #getScript()}.
     *
     * @param name The name of the secondary program.
     * @return new ScriptBuilder.
     */
    static CreateSecondaryProgram(name) {
        const returnValue = new ScriptBuilder();
        returnValue.addStatements(`sec ${name}():`);
        returnValue.increaseIndent();
        return returnValue;
    }
    /**
     * Add a block of statements to the builder.
     *
     * @param statements A block of statements as a String.
     * @return this object.
     */
    addStatements(statements) {
        // Convert indention to a string
        // If currentIndent is negative, then use blank string
        let indentString = '';
        for (let i = 0; i < this.currentIndent; i++) {
            indentString += ScriptBuilder.SINGLE_INDENT;
        }
        statements
            .split('\n')
            .filter((statement) => statement.length > 0)
            .forEach((statement) => {
            this.script += `${indentString}${statement}\n`;
        });
        return this;
    }
    /**
     * Add raw script code.
     * As this method takes raw script code that may not be indented and appends it without indenting it,
     * it may violate the overall indentation.
     *
     * @param script The script to be appended
     * @return this object.
     */
    addRaw(script) {
        this.script += `${script}\n`;
        return this;
    }
    /**
     * Add a while statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param expression The string representation of an expression.
     * @return this object.
     */
    beginWhile(expression) {
        this.addStatements(`while (${expression}):`);
        this.increaseIndent();
        return this;
    }
    /**
     * Add a while not statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param expression The string representation of an expression.
     * @return this object.
     */
    beginWhileNot(expression) {
        this.addStatements(`while not (${expression}):`);
        this.increaseIndent();
        return this;
    }
    /**
     * Add a while statement that loops forever.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @return this object.
     */
    beginWhileTrue() {
        this.beginWhile('True');
        return this;
    }
    /**
     * Add the end keyword that balances/terminates the declaration of functions, branch and loop statements.
     *
     * @return this object.
     */
    end() {
        this.decreaseIndent();
        this.addStatements('end');
        return this;
    }
    /**
     * End a block, without an end statement
     * Used by if and elseif
     * @return this object.
     */
    endBlock() {
        this.decreaseIndent();
        return this;
    }
    /**
     * Add a return statement.
     *
     * @return this object.
     */
    returnMethod() {
        this.addStatements('return');
        return this;
    }
    /**
     * Add a statement that declares a global variable and assigns it an initial value.
     *
     * @param name  The name of the global variable.
     * @param value An expression which is the initial value of the global variable.
     * @return this object.
     */
    globalVariable(name, value) {
        this.addStatements(`global ${name} = ${value}`);
        return this;
    }
    /**
     * Add a statement that declares a local variable and assigns it an initial value.
     *
     * @param name  The name of the local variable.
     * @param value An expression which is the initial value of the local variable.
     * @return this object.
     */
    localVariable(name, value) {
        this.addStatements(`local ${name} = ${value}`);
        return this;
    }
    /**
     * Declares or updates a persistent (shared) variable in URScript with the given name and value.
     * Shared variables retain their values between program runs and are accessible globally.
     *
     * @param name  The name of the persistent variable.
     * @param value The initial value or expression to assign to the persistent variable.
     * @returns This ScriptBuilder instance for chaining.
     */
    setPersistentVariable(name, value) {
        this.addStatements(`shared ${name} = ${value}`);
        return this;
    }
    /**
     * Add a statement that increments a variable with the given name.
     *
     * @param name The name of the variable.
     * @return this object.
     */
    incrementVariable(name) {
        this.addStatements(`${name} = ${name} + 1`);
        return this;
    }
    /**
     * Add a statement that assigns an expression to a variable.
     *
     * @param name       The name of the variable.
     * @param expression The expression to be assigned to the variable.
     * @return this object.
     */
    assign(name, expression) {
        this.addStatements(`${name} = ${expression}`);
        return this;
    }
    /**
     * Add an if statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #elseIfCondition(String)} or
     * {@link #else()} or {@link #end()} at the appropriate time.
     *
     * @param expression The expression that the if statement branches on.
     * @return this object.
     */
    ifCondition(expression) {
        this.addStatements(`if (${expression}):`);
        this.increaseIndent();
        return this;
    }
    /**
     * Add an else if statement with a given expression.
     * This is unbalanced, it has to be balanced by a call to {@link #elseIfCondition(String)} or
     * {@link #elseIfCondition(Script)} or {@link #else()} or {@link #end()} at the appropriate time.
     *
     * @param expression The expression that the else if statement branches on.
     * @return this object.
     */
    elseIfCondition(expression) {
        this.addStatements(`elif (${expression}):`);
        this.increaseIndent();
        return this;
    }
    /**
     * Add an else statement.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @return this object.
     */
    else() {
        this.addStatements('else:');
        this.increaseIndent();
        return this;
    }
    /**
     * Add a thread definition with given the threadName.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param threadName The threadName of the thread.
     * @return this object.
     */
    defineThread(threadName) {
        this.addStatements(`thread ${threadName}():`);
        this.increaseIndent();
        return this;
    }
    /**
     * Add a statement to run a thread with the given name and assign the thread handle to a variable.
     *
     * @param threadHandle The variable that gets assigned the thread handle .
     * @param threadName   The name of the thread to be started.
     * @return this object.
     */
    runThread(threadHandle, threadName) {
        this.addStatements(`${threadHandle} = run ${threadName}()`);
        return this;
    }
    /**
     * Add a statement to kill a thread.
     *
     * @param threadHandle The thread threadHandle.
     * @return this object.
     */
    killThread(threadHandle) {
        this.addStatements(`kill ${threadHandle}`);
        return this;
    }
    /**
     * Add a function definition with the given name and parameters.
     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.
     *
     * @param name   The name of the function.
     * @param params The parameters of the function.
     * @return this object.
     */
    defineFunction(name, ...params) {
        this.addStatements(`def ${name}(${params.join(',')}):`);
        this.increaseIndent();
        return this;
    }
    /**
     * Add a comment in the script.
     *
     * @param text The comment text.
     * @return this object.
     */
    comment(text) {
        for (const comment of text.split('\n')) {
            this.addStatements(`# ${comment}`);
        }
        return this;
    }
    /**
     * Implementation
     */
    addFrame(name, pose, refFrame = 'base') {
        if (typeof pose === 'string') {
            // Pass pose parameter as string expression
            return this.addStatements(`add_frame("${name}", ${pose}, "${refFrame}")`);
        }
        const position = isControllerPose(pose) ? pose.objectPosition.zUpPositionMeters : pose.position;
        const orientation = isControllerPose(pose) ? pose.objectRotation.zUpRotationVectorRadians : pose.orientation;
        const referenceFrame = isControllerPose(pose) ? pose.referenceFrame : refFrame;
        return this.addStatements(`add_frame("${name}", p[${position[0]}, ${position[1]}, ${position[2]}, ${orientation[0]}, ${orientation[1]}, ${orientation[2]}], "${referenceFrame}")`);
    }
    /**
     * Delete the frame named frame from the world model.
     * The "world", "base", and "tcp" frames cannot be deleted.
     * Any frames that are attached to the deleted frame will be attached to the "world" frame with new frame offsets set
     * such that the detached frame does not move in the world.
     * This command will fail if the frame does not exist.
     * @param name name of the frame to be deleted
     */
    deleteFrame(name) {
        return this.addStatements(`delete_frame("${name}")`);
    }
    /**
     * Implementation
     */
    moveFrame(name, pose, refFrame = 'base') {
        const position = isControllerPose(pose) ? pose.objectPosition.zUpPositionMeters : pose.position;
        const orientation = isControllerPose(pose) ? pose.objectRotation.zUpRotationVectorRadians : pose.orientation;
        const referenceFrame = isControllerPose(pose) ? pose.referenceFrame : refFrame;
        return this.addStatements(`move_frame("${name}", p[${position[0]}, ${position[1]}, ${position[2]}, ${orientation[0]}, ${orientation[1]}, ${orientation[2]}], "${referenceFrame}")`);
    }
    /**
     * Attaches the child frame to the parent world model object. The relative transform between the parent and child will be set such that
     * the child does not move in the world when the attachment occurs.
     * The child cannot be "world", "tcp", or the same as parent.
     * This will fail if child or parent is not an existing frame, or this makes the attachments form a closed chain.
     * @param child name of the frame to be attached.  The name must not be "world" or "tcp".
     * @param parent name of the object that the child frame will be attached to.
     */
    attachFrame(child, parent) {
        return this.addStatements(`attach_frame("${child}", "${parent}")`);
    }
    /**
     * Implementation
     */
    setFrameOrientation(name, orientation) {
        const baseFrameNameString = `"${name}"`;
        const poseOrientation = isZUpRotationVectorRadians(orientation) ? orientation.zUpRotationVectorRadians : orientation;
        return this.addStatements([
            `local existingBaseParent = get_frame_parent(${baseFrameNameString})`,
            `local basePose = get_pose(${baseFrameNameString}, existingBaseParent)`,
            `basePose[3] = ${poseOrientation[0]}`,
            `basePose[4] = ${poseOrientation[1]}`,
            `basePose[5] = ${poseOrientation[2]}`,
            `move_frame(${baseFrameNameString}, basePose, existingBaseParent)`,
        ].join('\n'));
    }
    /**
     * Add a popup with the given parameters.
     *
     * @param message    The popup message.
     * @param title      The popup title.
     * @param level      The popup level.
     * @param isBlocking true if its a blocking popup and false otherwise.
     * @return this object.
     */
    popup(message, title, level, isBlocking) {
        let popupScript;
        switch (level) {
            case PopupLevel.ERROR:
                popupScript = `popup("${message}", "${title}", False, True, blocking=${ScriptBuilder.getBooleanAsString(isBlocking)})`;
                break;
            case PopupLevel.WARNING:
                popupScript = `popup("${message}", "${title}", True, False, blocking=${ScriptBuilder.getBooleanAsString(isBlocking)})`;
                break;
            case PopupLevel.INFO:
                popupScript = `popup("${message}", "${title}", False, False, blocking=${ScriptBuilder.getBooleanAsString(isBlocking)})`;
                break;
        }
        this.addStatements(popupScript);
        return this;
    }
    /**
     * Request a value with the given parameters.
     *
     * @param variableName  The variable name to assign the value to
     * @param message       The request message.
     * @param valueType     The type: integer, float, boolean, or string
     * @return this object.
     */
    requestValue(variableName, message, valueType) {
        if (variableName && message && valueType !== null) {
            const func = `request_${valueType.toLowerCase()}_from_primary_client("${message}")`;
            this.globalVariable(variableName, func);
        }
        return this;
    }
    /**
     * Add a halt statement.
     *
     * @return this object.
     */
    halt() {
        this.addStatements('halt');
        return this;
    }
    /**
     * @deprecated Use {@link break}
     * @description Insert a break statement.
     * @return this object.
     */
    insertBreak() {
        return this.break();
    }
    /**
     * @description Insert a break statement.
     * @return this object.
     */
    break() {
        this.addStatements('break');
        return this;
    }
    /**
     * Add a sync command that uses up the remaining "physical" time a thread has in the current frame.
     *
     * @return this object.
     */
    sync() {
        this.addStatements('sync()');
        return this;
    }
    /**
     * Add a sleep command.
     *
     * @param seconds The amount of time in seconds.
     * @return this object.
     */
    sleep(seconds) {
        this.addStatements(`sleep(${seconds})`);
        return this;
    }
    /**
     * Add a stopl command. It decelerates tool speed to zero.
     *
     * @param toolAcceleration The tool acceleration in <i>m/</i><i>s</i><sup>2</sup>.
     * @return this object.
     */
    stopl(toolAcceleration) {
        this.addStatements(`stopl(${toolAcceleration})`);
        return this;
    }
    /**
     * Add a stopj command. It decelerates joint speeds to zero.
     *
     * @param jointAcceleration The joint acceleration in <i>rad/</i><i>s</i><sup>2</sup>.
     * @return this object.
     */
    stopj(jointAcceleration) {
        this.addStatements(`stopj(${jointAcceleration})`);
        return this;
    }
    /**
     * Add a call to the function that will accelerate linearly in Cartesian space and continue with constant tool
     * speed.
     *
     * @param xd                    array of tool speeds in m/s (spatial vector).
     * @param cartesianAcceleration tool position acceleration <i>m/</i><i>s</i><sup>2</sup>.
     * @param time                  time in seconds before the function returns.
     * @param refFrameName          name of reference frame
     * @return this object.
     */
    speedl(xd, cartesianAcceleration, time, refFrameName) {
        if (refFrameName) {
            this.addStatements(`speedl(struct(vel=${ScriptBuilder.formatArray(xd)}, frame="${refFrameName}"), ${cartesianAcceleration}, ${time})`);
        }
        else {
            this.addStatements(`speedl(${ScriptBuilder.formatArray(xd)}, ${cartesianAcceleration}, ${time})`);
        }
        return this;
    }
    /**
     * Add a call to the function that will accelerate linearly in joint space and continue with constant joint
     * speed.
     *
     * @param qd                array of joint speeds in rad/s.
     * @param jointAcceleration joint acceleration in <i>rad/</i><i>s</i><sup>2</sup> (of leading axis)
     * @param time              time in seconds before the function returns.
     * @return this object.
     */
    speedj(qd, jointAcceleration, time) {
        this.addStatements(`speedj(${ScriptBuilder.formatArray(qd)}, ${jointAcceleration}, ${time})`);
        return this;
    }
    /**
     * Add a call to the function that will Move to position (linear in joint-space).
     * @param q joint positions (q can also be specified as a pose, then
     * inverse kinematics is used to calculate the corresponding
     * joint positions) as a string or number array.
     * @param acc joint acceleration of leading axis in <i>rad/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed joint speed of leading axis in rad/s as a string or number (optional).
     * @param time time in seconds as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    movej(q, acc, speed, time, blendRadius) {
        if (typeof q !== 'string' && !(q instanceof String)) {
            q = ScriptBuilder.formatArray(q);
        }
        const args = [`${q}`];
        if (acc) {
            args.push(`a=${acc}`);
        }
        if (speed) {
            args.push(`v=${speed}`);
        }
        if (time) {
            args.push(`t=${time}`);
        }
        if (blendRadius) {
            args.push(`r=${blendRadius}`);
        }
        this.addStatements(`movej(${args.join(', ')})`);
        return this;
    }
    /**
     * Add a call to the function that will Move to position (linear in tool-space).
     * @param pose target pose (pose can also be specified as joint
     * positions, then forward kinematics is used to
     * calculate the corresponding pose) as a string.
     * @param acc tool acceleration <i>m/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed tool speed in m/s as a string or number (optional).
     * @param time time in seconds as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    movel(pose, acc, speed, time, blendRadius) {
        const args = [pose];
        if (acc) {
            args.push(`a=${acc}`);
        }
        if (speed) {
            args.push(`v=${speed}`);
        }
        if (time) {
            args.push(`t=${time}`);
        }
        if (blendRadius) {
            args.push(`r=${blendRadius}`);
        }
        this.addStatements(`movel(${args.join(', ')})`);
        return this;
    }
    /**
     * Blend circular (in tool-space) and move linear (in tool-space) to position. Accelerates to and moves
     * with constant tool speed v.
     * @param q joint positions (q can also be specified as a pose, then
     * inverse kinematics is used to calculate the corresponding
     * joint positions) as a string or number array.
     * @param acc joint acceleration of leading axis in <i>rad/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed joint speed of leading axis in rad/s as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    movep(q, acc, speed, blendRadius) {
        if (typeof q !== 'string' && !(q instanceof String)) {
            q = ScriptBuilder.formatArray(q);
        }
        const args = [`${q}`];
        if (acc) {
            args.push(`a=${acc}`);
        }
        if (speed) {
            args.push(`v=${speed}`);
        }
        if (blendRadius) {
            args.push(`r=${blendRadius}`);
        }
        this.addStatements(`movep(${args.join(', ')})`);
        return this;
    }
    /**
     * TCP moves on the circular arc segment from current pose, through pose_via to pose_to.
     * Accelerates to and moves with constant tool speed v. Use the mode parameter to define the
     * orientation interpolation.
     * @param pose_via path point (note: only position is used). Pose_via can also be specified as joint
     * positions, then forward kinematics is used to calculate the corresponding pose as a string or number array.
     * @param pose_to target pose (note: only position is used in Fixed orientation mode). Pose_to can also
     * be specified as joint positions, then forward kinematics is used to calculate the corresponding
     * pose as a string or number array.
     * @param acc tool acceleration <i>rad/</i><i>s</i><sup>2</sup> as a string or number (optional).
     * @param speed tool speed in m/s as a string or number (optional).
     * @param blendRadius blend radius (of target pose) in m as a string or number (optional).
     * @param mode mode of circular arc move as a string or number (optional).
     * 0: Unconstrained mode. Interpolate orientation from current pose to target pose (pose_to)
     * 1: Fixed mode. Keep orientation constant relative to the tangent of the circular arc (starting
     * from current pose)
     * @return this object.
     */
    movec(pose_via, pose_to, acc, speed, blendRadius, mode) {
        if (typeof pose_via !== 'string') {
            pose_via = ScriptBuilder.formatArray(pose_via);
        }
        if (typeof pose_to !== 'string') {
            pose_to = ScriptBuilder.formatArray(pose_to);
        }
        const args = [`${pose_via}`, `${pose_to}`];
        if (acc) {
            args.push(`a=${acc}`);
        }
        if (speed) {
            args.push(`v=${speed}`);
        }
        if (blendRadius) {
            args.push(`r=${blendRadius}`);
        }
        if (mode) {
            args.push(`mode=${mode}`);
        }
        this.addStatements(`movec(${args.join(', ')})`);
        return this;
    }
    /**
     * Add a call to the function that will Move to position (linear in joint-space), using OptiMove
     * @param q joint positions (q can also be specified as a pose, then
     * inverse kinematics is used to calculate the corresponding
     * joint positions) as a string or number array.
     * @param acc Joint acceleration as a fraction of what the joints are able to perform - a (0.0, 1.0] (optional).
     * @param speed Joint speed as a fraction of how fast the joints can move during the motion - v (0.0, 1.0] (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    optimovej(q, acc, speed, blendRadius) {
        if (typeof q !== 'string' && !(q instanceof String)) {
            q = ScriptBuilder.formatArray(q);
        }
        const args = [`${q}`];
        if (acc) {
            args.push(`a=${acc}`);
        }
        if (speed) {
            args.push(`v=${speed}`);
        }
        if (blendRadius) {
            args.push(`r=${blendRadius}`);
        }
        this.addStatements(`optimovej(${args.join(', ')})`);
        return this;
    }
    /**
     * Add a call to the function that will Move to position (linear in tool-space), using OptiMove
     * @param pose target pose (pose can also be specified as joint
     * positions, then forward kinematics is used to
     * calculate the corresponding pose) as a string.
     * @param acc tool acceleration <i>m/</i><i>s</i><sup>2</sup> as a string or number.
     * @param speed tool speed in m/s as a string or number (optional).
     * @param blendRadius blend radius in m as a string or number (optional).
     * @return this object.
     */
    optimovel(pose, acc, speed, blendRadius) {
        const args = [pose];
        if (acc) {
            args.push(`a=${acc}`);
        }
        if (speed) {
            args.push(`v=${speed}`);
        }
        if (blendRadius) {
            args.push(`r=${blendRadius}`);
        }
        this.addStatements(`optimovel(${args.join(', ')})`);
        return this;
    }
    /**
     * @deprecated use {@link setTargetPayload}
     * @description Add a call to the function that sets the mass.
     * @param mass mass in kilograms as a Script.
     * @return this object.
     */
    setPayloadMass(mass) {
        this.addStatements(`set_payload_mass(${mass})`);
        return this;
    }
    /**
     * @deprecated use {@link setTargetPayload}
     * @description Add a call to the function that sets the mass and CoG.
     * @param mass mass in kilograms as a Script.
     * @param cx CoG x offset in meters
     * @param cy CoG y offset in meters
     * @param cz CoG z offset in meters
     * @param inertia The payload inertia matrix in kg*m^2, elements lxx,lyy
     * lzz, lxy, lxz, lyz
     * @return this object.
     */
    setPayloadMassAndCoG(mass, cx, cy, cz, inertia) {
        return this.setTargetPayload(mass, cx, cy, cz, inertia);
    }
    /**
     * @description Add a call to the function that sets the mass and CoG.
     * @param mass mass in kilograms as a Script.
     * @param cx CoG x offset in meters
     * @param cy CoG y offset in meters
     * @param cz CoG z offset in meters
     * @param inertia The payload inertia matrix in kg*m^2, elements lxx,lyy
     * lzz, lxy, lxz, lyz
     * @return this object.
     */
    setTargetPayload(mass, cx, cy, cz, inertia) {
        if (inertia) {
            this.addStatements(`set_target_payload(${mass}, [${cx}, ${cy}, ${cz}], [${inertia[0]}, ${inertia[1]}, ${inertia[2]}, ${inertia[3]}, ${inertia[4]}, ${inertia[5]}])`);
        }
        else {
            this.addStatements(`set_target_payload(${mass}, [${cx}, ${cy}, ${cz}])`);
        }
        return this;
    }
    /**
     * Set the direction of the acceleration experienced by the robot.
     *
     * @param x x m/s^2
     * @param y y m/s^2
     * @param z z m/s^2
     */
    setGravity(x, y, z) {
        return this.addStatements(`set_gravity([${x},${y},${z}])`);
    }
    /**
     * @description Add a call function which specifies the desired TCP
     * @param x x length
     * @param y y length
     * @param z z length
     * @param rx rx angle
     * @param ry ry angle
     * @param rz rz angle
     * @param name Name of the TCP
     */
    setTcp(x, y, z, rx, ry, rz, name) {
        this.addStatements(`set_tcp(p[${x}, ${y}, ${z}, ${rx}, ${ry}, ${rz}]${name ? ', "' + name + '"' : ''})`);
        return this;
    }
    /**
     * Append the content of another script builder to
     * this script builder
     *
     * @param scriptBuilder
     */
    append(scriptBuilder) {
        if (scriptBuilder.getIndention() < 0) {
            this.increaseIndent(scriptBuilder.getIndention());
            this.addStatements(scriptBuilder.getScript());
        }
        else {
            this.addStatements(scriptBuilder.getScript());
            this.increaseIndent(scriptBuilder.getIndention());
        }
        return this;
    }
    /**
     * The terminal operation that generates the as string containing the UR Script.
     *
     * @return the string that contains the UR Script.
     */
    getScript() {
        // @ts-ignore trimEnd is not part of the es2015 lib, even though it exists
        return this.script.trimEnd();
    }
    /**
     * Get the current indention level of this ScriptBuilder.
     *
     * @return the indention level as a number.
     */
    getIndention() {
        return this.currentIndent;
    }
    /**
     * Increase the indent.
     */
    increaseIndent(level = ScriptBuilder.SINGLE_INDENT_LEVEL) {
        this.currentIndent += level;
    }
    /**
     * Decrease the indent.
     */
    decreaseIndent(level = ScriptBuilder.SINGLE_INDENT_LEVEL) {
        this.currentIndent -= level;
    }
}

/**
 * Creates the serializer for the ScriptBuilder. Handles serializing and deserializing of the object.
 * @constructor
 */
const ScriptBuilderSerializer = () => {
    return {
        /**
         * Deserializes the message as a new ScriptBuilder based on the message inputs
         * @param message Message containing the values to be parsed to the new ScriptBuilder
         * @param defaultHandler The object to handle deserializing if not of type ScriptBuilder
         */
        deserialize(message, defaultHandler) {
            if (message && message.type === '$$ScriptBuilder') {
                const script = message.script;
                const currentIndent = message.currentIndent;
                return new ScriptBuilder(script, currentIndent);
            }
            return defaultHandler(message);
        },
        /**
         * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning
         * @param item The original item that will be serialized
         * @param defaultHandler The object to handle serializing if not of type ScriptBuilder
         */
        serialize(item, defaultHandler) {
            if (item && item.constructor && item.constructor.name === 'ScriptBuilder') {
                return {
                    type: '$$ScriptBuilder',
                    ...item,
                };
            }
            return defaultHandler(item);
        },
    };
};

/**
 * Checks that the message coming is in a isSerializedScriptContext
 * @param message
 */
function isSerializedScriptContext(message) {
    return message && message.type === '$$ScriptContext';
}
/**
 * Creates the serializer for the ScriptContext. Handles serializing and deserializing of the object.
 * @constructor
 */
const ScriptContextSerializer = () => {
    return {
        /**
         * Deserializes the message as a new ScriptContext based on the message inputs
         * @param message Message containing the values to be parsed to the new ScriptContext
         * @param defaultHandler The object to handle deserializing if not of type ScriptContext
         */
        deserialize(message, defaultHandler) {
            if (isSerializedScriptContext(message)) {
                return {
                    traverse: {
                        ancestors: new AsyncArrayTraverser(message.ancestors ? message.ancestors : []),
                        children: new AsyncArrayTraverser(message.children ? message.children : []),
                        depthFirst: new AsyncArrayTraverser(message.depthFirst ? message.depthFirst : []),
                        nextSiblings: new AsyncArrayTraverser(message.nextSiblings ? message.nextSiblings : []),
                        previousSiblings: new AsyncArrayTraverser(message.previousSiblings ? message.previousSiblings : []),
                    },
                };
            }
            else {
                return defaultHandler(message);
            }
        },
        /**
         * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning
         * @param item The original item that will be serialized
         * @param defaultHandler The object to handle serializing if not of type ScriptContext
         */
        serialize(item, defaultHandler) {
            if (isSerializedScriptContext(item)) {
                return {
                    type: '$$ScriptContext',
                    ancestors: item.ancestors,
                    children: item.children,
                    depthFirst: item.depthFirst,
                    previousSiblings: item.previousSiblings,
                    nextSiblings: item.nextSiblings,
                };
            }
            else {
                return defaultHandler(item);
            }
        },
    };
};

/**
 * Checks that the message coming is in a isSerializedValidationContext
 * @param message
 */
function isSerializedValidationContext(message) {
    return message && message.type === '$$ValidationContext';
}
/**
 * Creates the serializer for the ValidationContext. Handles serializing and deserializing of the object.
 * @constructor
 */
const ValidationContextSerializer = () => {
    return {
        /**
         * Deserializes the message as a new ValidationContext based on the message inputs
         * @param message Message containing the values to be parsed to the new ValidationContext
         * @param defaultHandler The object to handle deserializing if not of type ValidationContext
         */
        deserialize(message, defaultHandler) {
            if (isSerializedValidationContext(message)) {
                return {
                    traverse: {
                        ancestors: new AsyncArrayTraverser(message.ancestors ? message.ancestors : []),
                        children: new AsyncArrayTraverser(message.children ? message.children : []),
                        depthFirst: new AsyncArrayTraverser(message.depthFirst ? message.depthFirst : []),
                        nextSiblings: new AsyncArrayTraverser(message.nextSiblings ? message.nextSiblings : []),
                        previousSiblings: new AsyncArrayTraverser(message.previousSiblings ? message.previousSiblings : []),
                    },
                };
            }
            else {
                return defaultHandler(message);
            }
        },
        /**
         * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning
         * @param item The original item that will be serialized
         * @param defaultHandler The object to handle serializing if not of type ValidationContext
         */
        serialize(item, defaultHandler) {
            if (isSerializedValidationContext(item)) {
                return {
                    type: '$$ValidationContext',
                    ancestors: item.ancestors,
                    children: item.children,
                    depthFirst: item.depthFirst,
                    previousSiblings: item.previousSiblings,
                    nextSiblings: item.nextSiblings,
                };
            }
            else {
                return defaultHandler(item);
            }
        },
    };
};

/**
 * Setup registration of serializers to be used when sending/receiving object across worker boundaries
 */
function registerSerializers() {
    registerSerializer(ScriptContextSerializer());
    registerSerializer(ValidationContextSerializer());
    registerSerializer(InsertionContextSerializer());
    registerSerializer(ScriptBuilderSerializer());
    registerSerializer(ApplicationContextSerializer());
}

/**
 * Common handler for behaviors
 */
const behaviorHandler = (behaviors) => {
    registerSerializers();
    expose(behaviors);
};
/**
 * Registers a Program behavior object allowing the programming area to
 * call the behavior methods.
 *
 * @param behaviors The ProgramBehaviors object to register
 */
const registerProgramBehavior = behaviorHandler;
/**
 * Registers an Application behavior object allowing the application area to
 * call the behavior methods.
 *
 * @param behaviors The ApplicationBehaviors object to register
 */
const registerApplicationBehavior = behaviorHandler;
/**
 * Registers a Source behavior object allowing various entities to call source
 * behavior methods
 *
 * @param behaviors The SourceBehaviors object to register
 */
const registerSourceBehavior = behaviorHandler;
/**
 * Registers a Smart skill behavior object allowing each smart skill to call its execution methods
 * behavior methods
 *
 * @param behaviors The SmartSkillsBehaviors object to register
 */
const registerSmartSkillBehavior = behaviorHandler;
/**
 * Registers a Operator Screen behavior object allowing each operator screen to call its
 * behavior methods
 *
 * @param behaviors The OperatorScreenBehaviors object to register
 */
const registerOperatorScreenBehavior = behaviorHandler;
/**
 * Registers a System Info behavior object allowing each system info screen to call its
 * behavior methods
 *
 * @param behaviors The SystemInfoBehaviors object to register
 */
const registerSystemInfoBehavior = behaviorHandler;
/**
 * Registers a Sidebar behavior object allowing each sidebar to call its
 * behavior methods
 *
 * @param behaviors The SidebarBehaviors object to register
 */
const registerSidebarBehavior = behaviorHandler;

const VALIDATION_OK = { isValid: true };
const VALIDATION_INVALID = { isValid: false };

/**
 * API for operator screen presenter components
 */
class OperatorScreenPresenterAPI extends CommonPresenterAPI {
    /** Creates a new instance of the OperatorScreenPresenterAPI, to allow communication with the
     * surrounding application from within a WebComponent
     *
     * @param target An EventTarget, provided by PolyScope X
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.builder = new TreeBuilder(communicationChannel);
        this.robotMoveService = new RobotMoveService(communicationChannel);
        this.programExecutionService = new ProgramExecutionService(communicationChannel);
        this.toolService = new ToolService(communicationChannel);
        this.mountingService = new MountingService(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
        this.operatorScreenService = new OperatorScreenService(communicationChannel);
        this.motionProfilesService = new MotionProfilesService(communicationChannel);
        this.scriptFileService = new ScriptFileService(communicationChannel);
    }
}
/**
 * Provides access to Operator Screen related API features in BehaviorWorkers
 */
class OperatorScreenBehaviorAPI extends CommonBehaviorAPI {
    /** Creates a new instance of the OperatorScreenBehaviorAPI to allow communication with the
     * surrounding application from within a WebWorker
     *
     * @param target A worker, provided with 'self' when created inside a web worker
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new WorkerCommunicationChannel(target);
        }
        super(communicationChannel);
        this.builder = new TreeBuilder(communicationChannel);
        this.toolService = new ToolService(communicationChannel);
        this.mountingService = new MountingService(communicationChannel);
        this.framesService = new FramesService(communicationChannel);
        this.motionProfilesService = new MotionProfilesService(communicationChannel);
        this.scriptFileService = new ScriptFileService(communicationChannel);
    }
}

/**
 * WebComponentDialogAPI
 */
class WebComponentDialogAPI extends CommonPresenterAPI {
    /** Creates a new instance of the WebComponentDialogAPI, to allow communication with the
     * surrounding application from within a WebComponent
     *
     * @param target An EventTarget, provided by PolyScope X
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.robotMoveService = new RobotMoveService(communicationChannel);
    }
}

/**
 * Provides access to system info related API features in System Info Presenters
 */
class SystemInfoPresenterAPI extends CommonPresenterAPI {
    /** Creates a new instance of the SystemInfoPresenterAPI, to allow communication with the
     * surrounding application from within a WebComponent
     *
     * @param target An EventTarget, provided by PolyScope X
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
    }
}

/**
 * Provides access to Sidebar related API features in BehaviorWorkers
 */
class SidebarBehaviorAPI extends CommonBehaviorAPI {
    /**
     * Creates a new instance of the SidebarBehaviorAPI to allow communication with the
     * surrounding application from within a WebWorker
     *
     * @param target A worker, provided with 'self' when created inside a web worker
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new WorkerCommunicationChannel(target);
        }
        super(communicationChannel);
    }
}
/**
 * Provides access to Sidebar related API features in Presenters
 */
class SidebarPresenterAPI extends CommonPresenterAPI {
    /**
     * Create a new instance of the SidebarPresenterAPI to allow a Presenter to interact with the API and update itself
     */
    constructor(target) {
        let communicationChannel;
        if (isCommunicationChannel(target)) {
            communicationChannel = target;
        }
        else {
            communicationChannel = new EventTargetCommunicationChannel(target);
        }
        super(communicationChannel);
        this.smartSkillInstanceService = new SmartSkillInstanceService(communicationChannel);
        this.smartSkillExecutionService = new SmartSkillExecutionService(communicationChannel);
        this.teachModeService = new TeachModeService(communicationChannel);
        this.applicationVariablesService = new ApplicationVariablesService(communicationChannel);
    }
}

/**
 * Model to be used in collaboration with tabInputComponent.
 */
class TabInputModel {
    /**
     * Initialize the object.
     */
    constructor(entity, selectedType, value) {
        this.entity = entity;
        this.selectedType = selectedType;
        this.value = value;
    }
    /**
     * Validates the model
     * @param model to validate
     */
    static async isValid(model) {
        if (model.selectedType === SelectedInput.VARIABLE) {
            const api = new ProgramBehaviorAPI(self);
            const isSuppressed = await api.symbolService.isSuppressed(model.value);
            const isRegisteredVariableName = await api.symbolService.isRegisteredVariableName(model.value);
            if (!isRegisteredVariableName || isSuppressed) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if tabInputModel has an entity and a selectedType
     * @param value to be interrogated
     */
    static isTabInputModel(value) {
        return value.entity !== undefined && value.selectedType !== undefined;
    }
    /**
     * Returns TabInputValue from TabInputModel which is the input for the TabInput component
     */
    static getTabInputValue(model) {
        return {
            selectedType: model.selectedType,
            value: model.value,
        };
    }
    /**
     * Sets TabInputValue on TabInputModel which is the input for the TabInput component
     * @param model to update the TabInputValue
     * @param value the inserted value for the model.
     */
    static setTabInputValue(model, value) {
        model.selectedType = value.selectedType;
        model.value = value.value;
    }
}

/**
 * Describes a relative insertion point
 */
var InsertionEnum;
(function (InsertionEnum) {
    InsertionEnum["BEFORE"] = "before";
    InsertionEnum["AFTER"] = "after";
    InsertionEnum["INTO_FIRST"] = "intoFirst";
    InsertionEnum["INTO_LAST"] = "intoLast";
})(InsertionEnum || (InsertionEnum = {}));
/**
 *
 */
var BlockEnum;
(function (BlockEnum) {
    BlockEnum["MAIN_PROGRAM"] = "mainProgram";
    BlockEnum["BEFORE_START"] = "beforeStart";
})(BlockEnum || (BlockEnum = {}));

const AngleUnits = ['rad', 'deg'];

const CurrentUnits = ['A', 'mA'];

const AccelerationUnits = ['m/s^2', 'mm/s^2'];

const AngularAccelerationUnits = ['rad/s^2', 'deg/s^2'];

const AngularSpeedUnits = ['rad/s', 'deg/s'];

const ForceUnits = ['N'];

const LengthUnits = ['m', 'mm'];

const MassUnits = ['g', 'kg'];

const SpeedUnits = ['m/s', 'mm/s'];

const TimeUnits = ['s', 'ms'];

const MomentInertiaUnits = ['kg*m^2'];

const MomentumUnits = ['kgm/s'];

const TemperatureUnits = ['C'];

const VoltageUnits = ['V', 'mV'];

const AllUnitStrings = new Set([
    ...MassUnits,
    ...SpeedUnits,
    ...LengthUnits,
    ...AngleUnits,
    ...VoltageUnits,
    ...CurrentUnits,
    ...AngularSpeedUnits,
    ...AccelerationUnits,
    ...AngularAccelerationUnits,
    ...TimeUnits,
    ...ForceUnits,
    ...MomentumUnits,
    ...MomentInertiaUnits,
    ...TemperatureUnits,
]);

/**
 * Map object containing all the ValueObject strings, mapped to their Unit Library unit
 */
const ValueObjectMap = {
    g,
    kg,
    kgM,
    'kgm/s': kgMPerSec,
    'deg/s': degPerSec,
    'deg/s^2': degPerSecSq,
    'm/s': mPerSec,
    'm/s^2': mPerSecSq,
    'mm/s': mmPerSec,
    'mm/s^2': mmPerSecSq,
    'rad/s': radPerSec,
    'rad/s^2': radPerSecSq,
    A,
    N,
    V,
    deg,
    m,
    mA,
    mV,
    mm,
    ms,
    rad,
    s,
    W,
    'kg*m^2': kgMSq,
    degreesCelsius,
};

/**
 * Converts one value object to another one with a different compatible unit
 * @example
 * ```ts
 *  const value = { value: 1, unit: m/s };
 *  const toUnit = mm/s;
 *  const convertedValue = convertValue(value, toUnit);
 *  console.log(convertedValue); // outputs { value: 1000, unit: mm/s };
 * ```
 * @throws Error if the value object and the provided unit are incompatible
 * @param value The value object to be converted
 * @param toUnit The unit to convert into, must be compatible with the value object's unit
 * @returns a new value object that contains the converted value
 * @see valueRawConverter
 */
function convertValue(value, toUnit) {
    if (!Object.keys(ValueObjectMap).includes(value.unit)) {
        throw new Error(`Unknown unit in value ${value.unit}`);
    }
    if (!Object.keys(ValueObjectMap).includes(toUnit)) {
        throw new Error(`Unknown target unit ${toUnit}`);
    }
    const from = ValueObjectMap[value.unit];
    const to = ValueObjectMap[toUnit];
    if (from.quantity.quantity !== to.quantity.quantity) {
        throw new Error('Cannot convert mismatched units');
    }
    const originalValue = new FixedPointNumber(value.value, from);
    const newValue = converter(originalValue, to);
    return {
        value: newValue.getValue(),
        unit: toUnit,
    };
}
/**
 * Get the raw numeric value of a value object converted into another compatible unit as a string
 * <p>The returned value is formatted using {@link FixedPointNumber#getDisplayValue} and is without any unit symbols or label</p>
 * @example
 * ```ts
 *  const value = { value: 1, unit: "m/s" };
 *  const toUnit = "mm/s";
 *  const convertedValue = valueRawConverter(value, toUnit);
 *  console.log(convertedValue); // outputs "1000"
 * ```
 * @throws Error if the value object and the provided unit are incompatible
 * @param value The value object to be converted
 * @param to The unit to convert into, must be compatible with the value object's unit
 * @returns The raw numeric value of the converted value object as a formatted string
 * @see convertValue
 */
function valueRawConverter(value, to) {
    const convertedValue = convertValue(value, to.label);
    return `${new FixedPointNumber(Number(convertedValue.value), to).getDisplayValue()}`;
}
/**
 * Transform the value object into a formatted string converting it to the specified unit with the unit's symbol appended
 * <p>The returned value is formatted using {@link FixedPointNumber#getDisplayValue} and is without any unit symbols or label</p>
 * @example
 * ```ts
 *  const value = { value: 1, unit: "m/s" };
 *  const toUnit = "mm/s";
 *  const convertedValue = valueConverter(value, toUnit);
 *  console.log(convertedValue); // outputs "1000 mm/s"
 * ```
 * @throws Error if the value object and the provided unit are incompatible
 * @param value The value object to be formatted
 * @param to The unit to convert into, must be compatible with the value object's unit
 * @returns The formatted value with the unit's symbol appended
 */
function valueConverter(value, to) {
    const convertedValue = convertValue(value, to.label);
    return `${new FixedPointNumber(Number(convertedValue.value), to).getDisplayValue()} ${to.symbol}`;
}

/**
 * Presets available for Digital In signals
 */
var DigitalInPreset;
(function (DigitalInPreset) {
    DigitalInPreset[DigitalInPreset["NONE"] = 0] = "NONE";
    DigitalInPreset[DigitalInPreset["START"] = 1] = "START";
    DigitalInPreset[DigitalInPreset["STOP"] = 2] = "STOP";
    DigitalInPreset[DigitalInPreset["PAUSE"] = 3] = "PAUSE";
})(DigitalInPreset || (DigitalInPreset = {}));

/**
 * Enumeration for possible signal directions
 */
var SignalDirectionEnum;
(function (SignalDirectionEnum) {
    SignalDirectionEnum["IN"] = "IN";
    SignalDirectionEnum["OUT"] = "OUT";
})(SignalDirectionEnum || (SignalDirectionEnum = {}));
/**
 * Enumeration for possible signal value types
 */
var SignalValueTypeEnum;
(function (SignalValueTypeEnum) {
    SignalValueTypeEnum["BOOLEAN"] = "BOOLEAN";
    SignalValueTypeEnum["FLOAT"] = "FLOAT";
    SignalValueTypeEnum["REGISTER"] = "REGISTER";
    SignalValueTypeEnum["CUSTOM"] = "CUSTOM";
})(SignalValueTypeEnum || (SignalValueTypeEnum = {}));

/**
 * Enum with all possible analog domain values
 */
var SignalAnalogDomainValueEnum;
(function (SignalAnalogDomainValueEnum) {
    SignalAnalogDomainValueEnum["CURRENT"] = "CURRENT";
    SignalAnalogDomainValueEnum["VOLTAGE"] = "VOLTAGE";
})(SignalAnalogDomainValueEnum || (SignalAnalogDomainValueEnum = {}));

/*
 * Public API Surface of contribution-api
 */

/**
 * Generated bundle index. Do not edit.
 */

export { APPLICATION_NODE_SERVICE_MESSAGE_TYPE_BASE, APPLICATION_SERVICE_MESSAGE_TYPE_BASE, APPLICATION_VARIABLES_SERVICE_MESSAGE_TYPE_BASE, AccelerationUnits, ActionEnum, AllUnitStrings, AngleUnits, AngularAccelerationUnits, AngularSpeedUnits, ApplicationBehaviorAPI, ApplicationNodeService, ApplicationNodeType, ApplicationPresenterAPI, ApplicationService, ApplicationVariablesService, AsyncArrayTraverser, BlockEnum, CenterOfGravityAxes, CommunicationChannel, CurrentUnits, DIALOG_SERVICE_MESSAGE_TYPE_BASE, DialogService, DigitalInPreset, DirectionalPositionAxes, DurabilityPolicy, EXPRESSION_EDITOR_SERVICE_MESSAGE_TYPE_BASE, EventTargetCommunicationChannel, ExpressionEditorService, FRAMES_SERVICE_MESSAGE_TYPE_BASE, FREEDRIVE_STATE_SERVICE_MESSAGE_TYPE_BASE, ForceUnits, FrameNodeAction, FramesService, FreedriveService, HistoryPolicy, InertiaMatrixKeys, InsertionEnum, LOG_MESSAGE_SERVICE_MESSAGE_TYPE_BASE, LOG_PERFORMANCE_SERVICE_MESSAGE_TYPE_BASE, LengthUnits, LivelinessPolicy, LogMessageService, LogPerformanceService, MOTION_PROFILES_SERVICE_MESSAGE_TYPE_BASE, MOUNTING_SERVICE_MESSAGE_TYPE_BASE, MassUnits, MessageInvokerService, MomentInertiaUnits, MomentumUnits, MotionProfileMoveType, MotionProfilesService, MountingService, MovementType, NodeType, OPERATOR_SCREEN_SERVICE_MESSAGE_TYPE_BASE, OperatorInputType, OperatorScreenBehaviorAPI, OperatorScreenPresenterAPI, OperatorScreenService, OrientationAxes, OrientationMode, PROGRAM_CODE_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_NODE_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_TREE_SERVICE_MESSAGE_TYPE_BASE, PopupLevel, PoseAxes, PoseUtils, PositionAxes, ProgramBehaviorAPI, ProgramCodeService, ProgramExecutionService, ProgramNodeService, ProgramPresenterAPI, ProgramService, ProgramTreeService, QoSProfile, ROBOT_INFO_SERVICE_MESSAGE_TYPE_BASE, ROBOT_MOVE_SERVICE_MESSAGE_TYPE_BASE, ROBOT_POSITION_SERVICE_MESSAGE_TYPE_BASE, ReliabilityPolicy, RobotInfoService, RobotMoveService, RobotPositionService, Ros2Client, Ros2EventService, SAFETY_SERVICE_MESSAGE_TYPE_BASE, SCRIPT_FILE_SERVICE_MESSAGE_TYPE_BASE, SETTINGS_MESSAGE_TYPE_BASE, SMART_SKILL_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, SMART_SKILL_INSTANCE_SERVICE_MESSAGE_TYPE_BASE, SNACKBAR_SERVICE_MESSAGE_TYPE_BASE, SOURCE_MESSAGE_TYPE_BASE, SOURCE_NODE_SERVICE_MESSAGE_TYPE_BASE, SYMBOL_SERVICE_MESSAGE_TYPE_BASE, SYSTEM_SERVICE_MESSAGE_TYPE_BASE, SafetyService, ScriptBuilder, ScriptFileService, SettingsService, SidebarBehaviorAPI, SidebarPresenterAPI, SignalAnalogDomainValueEnum, SignalDirectionEnum, SignalService, SignalValueTypeEnum, SmartSkillExecutionService, SmartSkillInstanceService, SmartSkillType, SmartSkillsBehaviorAPI, SmartSkillsPresenterAPI, SnackbarService, SourceBehaviorAPI, SourceNodeService, SourcePresenterAPI, SourceService, SpeedUnits, SymbolService, SystemInfoPresenterAPI, SystemService, TEACH_MODE_SERVICE_MESSAGE_TYPE_BASE, TOOL_SERVICE_MESSAGE_TYPE_BASE, TREE_BUILDER_MESSAGE_TYPE_BASE, TabInputModel, TeachModeService, TeachModeState, TemperatureUnits, ThreadAction, TimeUnits, ToolService, TreeBuilder, UNSUBSCRIBE_MESSAGE_TYPE, UREventTarget, URFunction, URLogicProgram, URModule, URSymbol, URSymbolType, URVariable, UntilConditionType, VALIDATION_INVALID, VALIDATION_OK, VALIDATION_SERVICE_MESSAGE_TYPE_BASE, ValidationService, ValueObjectMap, VariableValueType, VoltageUnits, WaypointType, WebComponentDialogAPI, WorkerCommunicationChannel, controllerPose, convertPose, convertValue, createEventTargetCommChannel, createWorkerCommChannel, floatOperators, frameArraysAreSignificantlySimilar, getDirectionalVector, isCommunicationChannel, isControllerPose, isFunction, isJointPositions, isLogicProgram, isModule, isReferenceItem, isURSymbol, isValueItem, isVariable, isWaypoint, isWorkerScope, iskinematicPosition, operatorInverseMap, posesAreSignificantlySimilar, registerApplicationBehavior, registerOperatorScreenBehavior, registerOperators, registerProgramBehavior, registerSerializers, registerSidebarBehavior, registerSmartSkillBehavior, registerSourceBehavior, registerSystemInfoBehavior, threeJsPose, traversePoses, valueConverter, valueRawConverter, yUpEulerRotationRadians, yUpPositionMeters, yUpQuaternion, zUpEulerRotationRadians, zUpPositionMeters, zUpRotationVectorRadians };
//# sourceMappingURL=universal-robots-contribution-api.mjs.map
