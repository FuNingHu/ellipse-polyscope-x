{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservablePromise = void 0;\nconst observable_fns_1 = require(\"observable-fns\");\nconst doNothing = () => undefined;\nconst returnInput = input => input;\nconst runDeferred = fn => Promise.resolve().then(fn);\nfunction fail(error) {\n  throw error;\n}\nfunction isThenable(thing) {\n  return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nclass ObservablePromise extends observable_fns_1.Observable {\n  constructor(init) {\n    super(originalObserver => {\n      // tslint:disable-next-line no-this-assignment\n      const self = this;\n      const observer = Object.assign(Object.assign({}, originalObserver), {\n        complete() {\n          originalObserver.complete();\n          self.onCompletion();\n        },\n        error(error) {\n          originalObserver.error(error);\n          self.onError(error);\n        },\n        next(value) {\n          originalObserver.next(value);\n          self.onNext(value);\n        }\n      });\n      try {\n        this.initHasRun = true;\n        return init(observer);\n      } catch (error) {\n        observer.error(error);\n      }\n    });\n    this.initHasRun = false;\n    this.fulfillmentCallbacks = [];\n    this.rejectionCallbacks = [];\n    this.firstValueSet = false;\n    this.state = \"pending\";\n  }\n  onNext(value) {\n    if (!this.firstValueSet) {\n      this.firstValue = value;\n      this.firstValueSet = true;\n    }\n  }\n  onError(error) {\n    this.state = \"rejected\";\n    this.rejection = error;\n    for (const onRejected of this.rejectionCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onRejected(error));\n    }\n  }\n  onCompletion() {\n    this.state = \"fulfilled\";\n    for (const onFulfilled of this.fulfillmentCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onFulfilled(this.firstValue));\n    }\n  }\n  then(onFulfilledRaw, onRejectedRaw) {\n    const onFulfilled = onFulfilledRaw || returnInput;\n    const onRejected = onRejectedRaw || fail;\n    let onRejectedCalled = false;\n    return new Promise((resolve, reject) => {\n      const rejectionCallback = error => {\n        if (onRejectedCalled) return;\n        onRejectedCalled = true;\n        try {\n          resolve(onRejected(error));\n        } catch (anotherError) {\n          reject(anotherError);\n        }\n      };\n      const fulfillmentCallback = value => {\n        try {\n          resolve(onFulfilled(value));\n        } catch (error) {\n          rejectionCallback(error);\n        }\n      };\n      if (!this.initHasRun) {\n        this.subscribe({\n          error: rejectionCallback\n        });\n      }\n      if (this.state === \"fulfilled\") {\n        return resolve(onFulfilled(this.firstValue));\n      }\n      if (this.state === \"rejected\") {\n        onRejectedCalled = true;\n        return resolve(onRejected(this.rejection));\n      }\n      this.fulfillmentCallbacks.push(fulfillmentCallback);\n      this.rejectionCallbacks.push(rejectionCallback);\n    });\n  }\n  catch(onRejected) {\n    return this.then(undefined, onRejected);\n  }\n  finally(onCompleted) {\n    const handler = onCompleted || doNothing;\n    return this.then(value => {\n      handler();\n      return value;\n    }, () => handler());\n  }\n  static from(thing) {\n    if (isThenable(thing)) {\n      return new ObservablePromise(observer => {\n        const onFulfilled = value => {\n          observer.next(value);\n          observer.complete();\n        };\n        const onRejected = error => {\n          observer.error(error);\n        };\n        thing.then(onFulfilled, onRejected);\n      });\n    } else {\n      return super.from(thing);\n    }\n  }\n}\nexports.ObservablePromise = ObservablePromise;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}