{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;\nconst is_observable_1 = __importDefault(require(\"is-observable\"));\nconst common_1 = require(\"../common\");\nconst transferable_1 = require(\"../transferable\");\nconst messages_1 = require(\"../types/messages\");\nconst implementation_1 = __importDefault(require(\"./implementation\"));\nvar common_2 = require(\"../common\");\nObject.defineProperty(exports, \"registerSerializer\", {\n  enumerable: true,\n  get: function () {\n    return common_2.registerSerializer;\n  }\n});\nvar transferable_2 = require(\"../transferable\");\nObject.defineProperty(exports, \"Transfer\", {\n  enumerable: true,\n  get: function () {\n    return transferable_2.Transfer;\n  }\n});\n/** Returns `true` if this code is currently running in a worker. */\nexports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\nconst isMasterJobCancelMessage = thing => thing && thing.type === messages_1.MasterMessageType.cancel;\nconst isMasterJobRunMessage = thing => thing && thing.type === messages_1.MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nconst isObservable = thing => is_observable_1.default(thing) || isZenObservable(thing);\nfunction isZenObservable(thing) {\n  return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n  return transferable_1.isTransferDescriptor(thing) ? {\n    payload: thing.send,\n    transferables: thing.transferables\n  } : {\n    payload: thing,\n    transferables: undefined\n  };\n}\nfunction postFunctionInitMessage() {\n  const initMessage = {\n    type: messages_1.WorkerMessageType.init,\n    exposed: {\n      type: \"function\"\n    }\n  };\n  implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n  const initMessage = {\n    type: messages_1.WorkerMessageType.init,\n    exposed: {\n      type: \"module\",\n      methods: methodNames\n    }\n  };\n  implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n  const {\n    payload: error,\n    transferables\n  } = deconstructTransfer(rawError);\n  const errorMessage = {\n    type: messages_1.WorkerMessageType.error,\n    uid,\n    error: common_1.serialize(error)\n  };\n  implementation_1.default.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n  const {\n    payload,\n    transferables\n  } = deconstructTransfer(resultValue);\n  const resultMessage = {\n    type: messages_1.WorkerMessageType.result,\n    uid,\n    complete: completed ? true : undefined,\n    payload\n  };\n  implementation_1.default.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n  const startMessage = {\n    type: messages_1.WorkerMessageType.running,\n    uid,\n    resultType\n  };\n  implementation_1.default.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n  try {\n    const errorMessage = {\n      type: messages_1.WorkerMessageType.uncaughtError,\n      error: common_1.serialize(error)\n    };\n    implementation_1.default.postMessageToMaster(errorMessage);\n  } catch (subError) {\n    // tslint:disable-next-line no-console\n    console.error(\"Not reporting uncaught error back to master thread as it \" + \"occured while reporting an uncaught error already.\" + \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n  }\n}\nfunction runFunction(jobUID, fn, args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let syncResult;\n    try {\n      syncResult = fn(...args);\n    } catch (error) {\n      return postJobErrorMessage(jobUID, error);\n    }\n    const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n    postJobStartMessage(jobUID, resultType);\n    if (isObservable(syncResult)) {\n      const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, common_1.serialize(value)), error => {\n        postJobErrorMessage(jobUID, common_1.serialize(error));\n        activeSubscriptions.delete(jobUID);\n      }, () => {\n        postJobResultMessage(jobUID, true);\n        activeSubscriptions.delete(jobUID);\n      });\n      activeSubscriptions.set(jobUID, subscription);\n    } else {\n      try {\n        const result = yield syncResult;\n        postJobResultMessage(jobUID, true, common_1.serialize(result));\n      } catch (error) {\n        postJobErrorMessage(jobUID, common_1.serialize(error));\n      }\n    }\n  });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nfunction expose(exposed) {\n  if (!implementation_1.default.isWorkerRuntime()) {\n    throw Error(\"expose() called in the master thread.\");\n  }\n  if (exposeCalled) {\n    throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n  }\n  exposeCalled = true;\n  if (typeof exposed === \"function\") {\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n      if (isMasterJobRunMessage(messageData) && !messageData.method) {\n        runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));\n      }\n    });\n    postFunctionInitMessage();\n  } else if (typeof exposed === \"object\" && exposed) {\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n      if (isMasterJobRunMessage(messageData) && messageData.method) {\n        runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));\n      }\n    });\n    const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n    postModuleInitMessage(methodNames);\n  } else {\n    throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n  }\n  implementation_1.default.subscribeToMasterMessages(messageData => {\n    if (isMasterJobCancelMessage(messageData)) {\n      const jobUID = messageData.uid;\n      const subscription = activeSubscriptions.get(jobUID);\n      if (subscription) {\n        subscription.unsubscribe();\n        activeSubscriptions.delete(jobUID);\n      }\n    }\n  });\n}\nexports.expose = expose;\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && implementation_1.default.isWorkerRuntime()) {\n  self.addEventListener(\"error\", event => {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n  });\n  self.addEventListener(\"unhandledrejection\", event => {\n    const error = event.reason;\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(() => postUncaughtErrorMessage(error), 250);\n    }\n  });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && implementation_1.default.isWorkerRuntime()) {\n  process.on(\"uncaughtException\", error => {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(() => postUncaughtErrorMessage(error), 250);\n  });\n  process.on(\"unhandledRejection\", error => {\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(() => postUncaughtErrorMessage(error), 250);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}