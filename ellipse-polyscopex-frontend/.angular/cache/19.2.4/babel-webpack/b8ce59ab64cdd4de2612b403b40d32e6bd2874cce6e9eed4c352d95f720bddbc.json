{"ast":null,"code":"import Observable from \"./observable\";\nimport Subject from \"./subject\";\nimport unsubscribe from \"./unsubscribe\";\n// TODO: Subject already creates additional observables \"under the hood\",\n//       now we introduce even more. A true native MulticastObservable\n//       would be preferable.\n/**\n * Takes a \"cold\" observable and returns a wrapping \"hot\" observable that\n * proxies the input observable's values and errors.\n *\n * An observable is called \"cold\" when its initialization function is run\n * for each new subscriber. This is how observable-fns's `Observable`\n * implementation works.\n *\n * A hot observable is an observable where new subscribers subscribe to\n * the upcoming values of an already-initialiazed observable.\n *\n * The multicast observable will lazily subscribe to the source observable\n * once it has its first own subscriber and will unsubscribe from the\n * source observable when its last own subscriber unsubscribed.\n */\nfunction multicast(coldObservable) {\n  const subject = new Subject();\n  let sourceSubscription;\n  let subscriberCount = 0;\n  return new Observable(observer => {\n    // Init source subscription lazily\n    if (!sourceSubscription) {\n      sourceSubscription = coldObservable.subscribe(subject);\n    }\n    // Pipe all events from `subject` into this observable\n    const subscription = subject.subscribe(observer);\n    subscriberCount++;\n    return () => {\n      subscriberCount--;\n      subscription.unsubscribe();\n      // Close source subscription once last subscriber has unsubscribed\n      if (subscriberCount === 0) {\n        unsubscribe(sourceSubscription);\n        sourceSubscription = undefined;\n      }\n    };\n  });\n}\nexport default multicast;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}