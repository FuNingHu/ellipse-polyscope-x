{"ast":null,"code":"/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n  defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n  skip: Symbol(\"deepmerge-ts: skip\")\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n  defaultMerge: actions.defaultMerge\n};\n\n/**\n * The default function to update meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n  return metaMeta;\n}\n\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n  if (typeof object !== \"object\" || object === null) {\n    return 0 /* ObjectType.NOT */;\n  }\n  if (Array.isArray(object)) {\n    return 2 /* ObjectType.ARRAY */;\n  }\n  if (isRecord(object)) {\n    return 1 /* ObjectType.RECORD */;\n  }\n  if (object instanceof Set) {\n    return 3 /* ObjectType.SET */;\n  }\n  if (object instanceof Map) {\n    return 4 /* ObjectType.MAP */;\n  }\n  return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n  const keys = new Set();\n  /* eslint-disable functional/no-loop-statements, functional/no-expression-statements -- using a loop here is more efficient. */\n  for (const object of objects) {\n    for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n      keys.add(key);\n    }\n  }\n  /* eslint-enable functional/no-loop-statements, functional/no-expression-statements */\n  return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n  return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n  return {\n    // eslint-disable-next-line functional/functional-parameters\n    *[Symbol.iterator]() {\n      // eslint-disable-next-line functional/no-loop-statements\n      for (const iterable of iterables) {\n        // eslint-disable-next-line functional/no-loop-statements\n        for (const value of iterable) {\n          yield value;\n        }\n      }\n    }\n  };\n}\nconst validRecordToStringValues = new Set([\"[object Object]\", \"[object Module]\"]);\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n  // All records are objects.\n  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {\n    return false;\n  }\n  const {\n    constructor\n  } = value;\n  // If has modified constructor.\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (constructor === undefined) {\n    return true;\n  }\n  // eslint-disable-next-line prefer-destructuring\n  const prototype = constructor.prototype;\n  // If has modified prototype.\n  if (prototype === null || typeof prototype !== \"object\" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {\n    return false;\n  }\n  // If constructor does not have an Object-specific method.\n  // eslint-disable-next-line sonarjs/prefer-single-boolean-return, no-prototype-builtins\n  if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  // Most likely a record.\n  return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$2(values, utils, meta) {\n  const result = {};\n  /* eslint-disable functional/no-loop-statements, functional/no-conditional-statements, functional/no-expression-statements, functional/immutable-data -- using imperative code here is more performant. */\n  for (const key of getKeys(values)) {\n    const propValues = [];\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n    if (propValues.length === 0) {\n      continue;\n    }\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values\n    });\n    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n    if (propertyResult === actions.skip) {\n      continue;\n    }\n    if (key === \"__proto__\") {\n      Object.defineProperty(result, key, {\n        value: propertyResult,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      });\n    } else {\n      result[key] = propertyResult;\n    }\n  }\n  /* eslint-enable functional/no-loop-statements, functional/no-conditional-statements, functional/no-expression-statements, functional/immutable-data */\n  return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$2(values) {\n  return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$2(values) {\n  return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$2(values) {\n  return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last value in the given array.\n */\nfunction mergeOthers$2(values) {\n  return values.at(-1);\n}\nvar defaultMergeFunctions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mergeArrays: mergeArrays$2,\n  mergeMaps: mergeMaps$2,\n  mergeOthers: mergeOthers$2,\n  mergeRecords: mergeRecords$2,\n  mergeSets: mergeSets$2\n});\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(\n// eslint-disable-next-line functional/functional-parameters\n...objects) {\n  return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n  const utils = getUtils(options, customizedDeepmerge);\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmerge(\n  // eslint-disable-next-line functional/functional-parameters\n  ...objects) {\n    return mergeUnknowns(objects, utils, rootMetaData);\n  }\n  return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n  return {\n    defaultMergeFunctions,\n    mergeFunctions: {\n      ...defaultMergeFunctions,\n      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))\n    },\n    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,\n    deepmerge: customizedDeepmerge,\n    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n    actions\n  };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n  if (values.length === 0) {\n    return undefined;\n  }\n  if (values.length === 1) {\n    return mergeOthers$1(values, utils, meta);\n  }\n  const type = getObjectType(values[0]);\n  /* eslint-disable functional/no-loop-statements, functional/no-conditional-statements -- using imperative code here is more performant. */\n  if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n    for (let m_index = 1; m_index < values.length; m_index++) {\n      if (getObjectType(values[m_index]) === type) {\n        continue;\n      }\n      return mergeOthers$1(values, utils, meta);\n    }\n  }\n  /* eslint-enable functional/no-loop-statements, functional/no-conditional-statements */\n  switch (type) {\n    case 1 /* ObjectType.RECORD */:\n      {\n        return mergeRecords$1(values, utils, meta);\n      }\n    case 2 /* ObjectType.ARRAY */:\n      {\n        return mergeArrays$1(values, utils, meta);\n      }\n    case 3 /* ObjectType.SET */:\n      {\n        return mergeSets$1(values, utils, meta);\n      }\n    case 4 /* ObjectType.MAP */:\n      {\n        return mergeMaps$1(values, utils, meta);\n      }\n    default:\n      {\n        return mergeOthers$1(values, utils, meta);\n      }\n  }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {\n    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n  }\n  return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {\n    return utils.defaultMergeFunctions.mergeArrays(values);\n  }\n  return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {\n    return utils.defaultMergeFunctions.mergeSets(values);\n  }\n  return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {\n    return utils.defaultMergeFunctions.mergeMaps(values);\n  }\n  return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {\n    return utils.defaultMergeFunctions.mergeOthers(values);\n  }\n  return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param m_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecords(m_target, values, utils, meta) {\n  for (const key of getKeys(values)) {\n    const propValues = [];\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n    if (propValues.length === 0) {\n      continue;\n    }\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values\n    });\n    const propertyTarget = {\n      value: propValues[0]\n    };\n    mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n    if (key === \"__proto__\") {\n      Object.defineProperty(m_target, key, {\n        value: propertyTarget.value,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      });\n    } else {\n      m_target.value[key] = propertyTarget.value;\n    }\n  }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param m_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArrays(m_target, values) {\n  m_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param m_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSets(m_target, values) {\n  for (const value of getIterableOfIterables(values.slice(1))) {\n    m_target.value.add(value);\n  }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param m_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMaps(m_target, values) {\n  for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n    m_target.value.set(key, value);\n  }\n}\n/**\n * Set the target to the last value.\n */\nfunction mergeOthers(m_target, values) {\n  m_target.value = values.at(-1);\n}\nvar defaultMergeIntoFunctions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mergeArrays: mergeArrays,\n  mergeMaps: mergeMaps,\n  mergeOthers: mergeOthers,\n  mergeRecords: mergeRecords,\n  mergeSets: mergeSets\n});\nfunction deepmergeInto(target, ...objects) {\n  return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n  const utils = getIntoUtils(options, customizedDeepmergeInto);\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmergeInto(target, ...objects) {\n    mergeUnknownsInto({\n      value: target\n    }, [target, ...objects], utils, rootMetaData);\n  }\n  return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n  return {\n    defaultMergeFunctions: defaultMergeIntoFunctions,\n    mergeFunctions: {\n      ...defaultMergeIntoFunctions,\n      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeIntoFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers] : [key, option]))\n    },\n    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,\n    deepmergeInto: customizedDeepmergeInto,\n    actions: actionsInto\n  };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) {\n  if (values.length === 0) {\n    return;\n  }\n  if (values.length === 1) {\n    return void mergeOthersInto(m_target, values, utils, meta);\n  }\n  const type = getObjectType(m_target.value);\n  if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n    for (let m_index = 1; m_index < values.length; m_index++) {\n      if (getObjectType(values[m_index]) === type) {\n        continue;\n      }\n      return void mergeOthersInto(m_target, values, utils, meta);\n    }\n  }\n  switch (type) {\n    case 1 /* ObjectType.RECORD */:\n      {\n        return void mergeRecordsInto(m_target, values, utils, meta);\n      }\n    case 2 /* ObjectType.ARRAY */:\n      {\n        return void mergeArraysInto(m_target, values, utils, meta);\n      }\n    case 3 /* ObjectType.SET */:\n      {\n        return void mergeSetsInto(m_target, values, utils, meta);\n      }\n    case 4 /* ObjectType.MAP */:\n      {\n        return void mergeMapsInto(m_target, values, utils, meta);\n      }\n    default:\n      {\n        return void mergeOthersInto(m_target, values, utils, meta);\n      }\n  }\n}\n/**\n * Merge records into a target record.\n *\n * @param m_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n  }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param m_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeArrays(m_target, values);\n  }\n}\n/**\n * Merge sets into a target set.\n *\n * @param m_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeSets(m_target, values);\n  }\n}\n/**\n * Merge maps into a target map.\n *\n * @param m_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeMaps(m_target, values);\n  }\n}\n/**\n * Merge other things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeOthers(m_target, values);\n  }\n}\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom, getKeys, getObjectType, objectHasProperty };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}