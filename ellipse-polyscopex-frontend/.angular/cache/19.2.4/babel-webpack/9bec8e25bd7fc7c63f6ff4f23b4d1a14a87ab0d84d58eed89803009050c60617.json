{"ast":null,"code":"import _asyncToGenerator from \"/workspaces/polyscopex-0.18.90/ellipse-polyscopex/ellipse-polyscopex-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Guid } from 'guid-typescript';\nimport { Subject, firstValueFrom, map, merge, filter, take, throwError, of } from 'rxjs';\nimport { finalize, map as map$1, tap, switchMap } from 'rxjs/operators';\nimport { Md5 } from 'ts-md5';\nimport { Quaternion, Vector3, Euler, Matrix4 } from 'three';\nimport { expose } from 'threads/worker';\nimport { registerSerializer } from 'threads';\nimport { SelectedInput } from '@universal-robots/ui-models';\nimport { degreesCelsius, kgMSq, W, s, rad, ms, mm, mV, mA, m, deg, V, N, A, radPerSecSq, radPerSec, mmPerSecSq, mmPerSec, mPerSecSq, mPerSec, degPerSecSq, degPerSec, kgMPerSec, kgM, kg, g, FixedPointNumber, converter } from '@universal-robots/utilities-units';\nconst UNSUBSCRIBE_MESSAGE_TYPE = 'ur.web.message.unsubscribeUpdates';\n/**\n *\n */\nclass UREventTarget extends EventTarget {\n  /**\n   *\n   * @param name\n   */\n  constructor(options) {\n    super();\n    this.name = options?.name || Md5.hashStr(`${options?.values?.join('')}${options?.salt}`);\n  }\n}\n/**\n * returns true if the item is a worker type\n * @param item\n */\nfunction isWorkerScope(item) {\n  return item.postMessage && typeof item.postMessage === 'function';\n}\n/**\n * Abstract interface for communication within PSX\n *\n * This class is an internal implementation detail used by higher-level contribution APIs.\n */\nclass CommunicationChannel {\n  constructor() {\n    this.requestResponders = new Map();\n    this.observerResponders = new Map();\n  }\n  /**\n   *\n   */\n  triggerRequestResponse(event, responder) {\n    if (event.data.error) {\n      responder.reject(event.data.error);\n    } else {\n      responder.resolve(event.data.data);\n    }\n  }\n  /**\n   *\n   */\n  triggerObserverResponse(event, responder) {\n    if (event.data.error) {\n      responder.error(event.data.error);\n    } else {\n      responder.next(event.data.data);\n    }\n  }\n  /**\n   *\n   */\n  handleMessage(event) {\n    const responder = this.requestResponders.get(event.data.id);\n    if (responder) {\n      this.triggerRequestResponse(event, responder);\n      this.requestResponders.delete(event.data.id);\n      return;\n    }\n    const observerResponder = this.observerResponders.get(event.data.id);\n    if (observerResponder) {\n      this.triggerObserverResponse(event, observerResponder);\n    }\n  }\n  /**\n   *\n   */\n  requestInternal(sender, type, name, data = {}) {\n    const id = Guid.raw();\n    const promise = new Promise((resolve, reject) => {\n      this.requestResponders.set(id, {\n        resolve,\n        reject\n      });\n    });\n    const message = {\n      type,\n      data,\n      id\n    };\n    if (name) {\n      message.name = name;\n    }\n    sender(message);\n    return promise;\n  }\n  /**\n   *\n   */\n  requestObserveInternal(sender, finalizeFunc, type, data = {}) {\n    const id = Guid.raw();\n    const response$ = new Subject();\n    this.observerResponders.set(id, response$);\n    const message = {\n      type,\n      data: {\n        ...data\n      },\n      id\n    };\n    sender(message);\n    return response$.pipe(finalize(() => finalizeFunc(id)));\n  }\n  /**\n   *\n   */\n  unsubscribeFinalized(id) {\n    this.observerResponders.delete(id);\n  }\n}\n/**\n * Communication implementation for workers in PSX\n *\n * This class is an internal implementation detail used by higher-level contribution APIs.\n */\nclass WorkerCommunicationChannel extends CommunicationChannel {\n  /**\n   *\n   */\n  constructor(worker) {\n    super();\n    this.worker = worker;\n    this.id = Guid.raw();\n    this.messageChannel = new MessageChannel();\n    this.portToMainThread = this.messageChannel.port1;\n    this.portToMainThread.addEventListener('message', event => {\n      this.handleMessage(event);\n    });\n    this.portToMainThread.start();\n    worker.postMessage({\n      type: 'handshake'\n    }, [this.messageChannel.port2]);\n  }\n  /**\n   *\n   */\n  request(type, data = {}) {\n    return this.requestInternal(message => {\n      this.dispatchWorkerEvent(message);\n    }, type, this.worker.name, data);\n  }\n  /**\n   *\n   */\n  dispatchWorkerEvent(message) {\n    this.portToMainThread.postMessage(message);\n  }\n  /**\n   *\n   */\n  unsubscribeOnFinalized(id) {\n    this.unsubscribeFinalized(id);\n    const unsubscribeMessage = {\n      type: UNSUBSCRIBE_MESSAGE_TYPE,\n      data: {\n        id\n      }\n    };\n    this.portToMainThread.postMessage(unsubscribeMessage);\n  }\n  /**\n   * returns an observable that will emit any messages replied to the specified message\n   *\n   * @param type The type of message being sent\n   * @param data The message data\n   */\n  requestObserve(type, data = {}) {\n    return this.requestObserveInternal(message => {\n      this.dispatchWorkerEvent(message);\n    }, id => this.unsubscribeOnFinalized(id), type, data);\n  }\n}\n/**\n * Communication implementation for presenters in PSX\n *\n * This class is an internal implementation detail used by higher-level contribution APIs.\n */\nclass EventTargetCommunicationChannel extends CommunicationChannel {\n  /**\n   *\n   */\n  constructor(eventTarget) {\n    super();\n    this.eventTarget = eventTarget;\n    if (isWorkerScope(this.eventTarget)) {\n      throw new Error('Use WorkerCommunicationChannel for communication with workers');\n    }\n  }\n  /**\n   *\n   */\n  request(type, data = {}) {\n    const id = Guid.raw();\n    return new Promise((resolve, reject) => {\n      this.eventTarget.addEventListener(`reply_${type}_${id}`, event => {\n        resolve(event.data.data);\n      }, {\n        once: true,\n        passive: true\n      });\n      const message = {\n        type,\n        data,\n        id\n      };\n      const name = this.eventTarget?.name || self.name;\n      if (name) {\n        message.name = name;\n      }\n      this.dispatchTargetEvent(message);\n    });\n  }\n  /**\n   *\n   */\n  dispatchTargetEvent(message) {\n    this.eventTarget.dispatchEvent(new MessageEvent('message', {\n      data: message\n    }));\n  }\n  /**\n   *\n   */\n  unsubscribeOnFinalized(type, id, callback) {\n    this.eventTarget.removeEventListener(`reply_${type}_${id}`, callback);\n    const unsubscribeMessage = {\n      type: UNSUBSCRIBE_MESSAGE_TYPE,\n      data: {\n        id\n      }\n    };\n    this.eventTarget.dispatchEvent(new MessageEvent('message', {\n      data: unsubscribeMessage\n    }));\n  }\n  /**\n   * returns an observable that will emit any messages replied to the specified message\n   *\n   * @param type The type of message being sent\n   * @param data The message data\n   */\n  requestObserve(type, data = {}) {\n    const id = Guid.raw();\n    const response$ = new Subject();\n    /**\n     *\n     */\n    const callback = event => {\n      if (response$.observed) {\n        response$.next(event.data.data);\n      }\n    };\n    this.eventTarget.addEventListener(`reply_${type}_${id}`, callback, {\n      passive: true\n    });\n    const message = {\n      type,\n      data: {\n        ...data\n      },\n      id\n    };\n    this.dispatchTargetEvent(message);\n    return response$.pipe(finalize(() => this.unsubscribeOnFinalized(type, id, callback)));\n  }\n}\n/**\n * returns true if the item is a CommunicationChannel type\n * @param item\n */\nfunction isCommunicationChannel(item) {\n  return item.request && typeof item.request === 'function';\n}\n/**\n * Creates a WorkerCommunicationChannel\n * @param target\n */\nfunction createWorkerCommChannel(target) {\n  let communicationChannel;\n  if (isCommunicationChannel(target)) {\n    communicationChannel = target;\n  } else {\n    communicationChannel = new WorkerCommunicationChannel(target);\n  }\n  return communicationChannel;\n}\n/**\n * Creates a EventTargetCommunicationChannel\n * @param target\n */\nfunction createEventTargetCommChannel(target) {\n  let communicationChannel;\n  if (isCommunicationChannel(target)) {\n    communicationChannel = target;\n  } else {\n    communicationChannel = new EventTargetCommunicationChannel(target);\n  }\n  return communicationChannel;\n}\n/**\n * Base class for invoking messages\n */\nclass MessageInvokerService {\n  /**\n   * @constructor\n   * @param messageBase\n   * @param eventTarget\n   */\n  constructor(messageBase, eventTarget) {\n    this.messageBase = messageBase;\n    this.eventTarget = eventTarget;\n    if (isCommunicationChannel(eventTarget)) {\n      this.communicationChannel = eventTarget;\n    } else {\n      if (isWorkerScope(eventTarget)) {\n        this.communicationChannel = new WorkerCommunicationChannel(eventTarget);\n      } else {\n        this.communicationChannel = new EventTargetCommunicationChannel(eventTarget);\n      }\n    }\n  }\n  /**\n   * returns a reply promise for the requested message\n   *\n   * @param type The type of message being sent\n   * @param data The message data\n   */\n  request(type, data = {}) {\n    return this.communicationChannel.request(this.messageBase + type, data);\n  }\n  /**\n   * returns an observable that will emit any messages replied to the requested message\n   *\n   * @param type The type of message being sent\n   * @param data The message data\n   */\n  requestObserve(type, data = {}) {\n    return this.communicationChannel.requestObserve(this.messageBase + type, data);\n  }\n  /**\n   * returns a reply promise to the specified message\n   *\n   * @param type The type of message being sent\n   * @param data The message data\n   */\n  postAndAwait(type, data = {}) {\n    return this.communicationChannel.request(this.messageBase + type, data);\n  }\n  /**\n   * returns an observable that will emit any messages replied to the specified message\n   *\n   * @param type The type of message being sent\n   * @param data The message data\n   */\n  postAndObserve(type, data = {}) {\n    return this.communicationChannel.requestObserve(this.messageBase + type, data);\n  }\n}\nconst APPLICATION_NODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ApplicationNodeService.';\n/**\n * Service that handles updating application nodes\n */\nclass ApplicationNodeService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(APPLICATION_NODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Update the program node\n   * @param node New program node state\n   */\n  updateNode(node) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.postAndAwait('updateNode', node);\n    })();\n  }\n}\n\n/**\n * Defines the types of URSymbols\n */\nvar URSymbolType = /*#__PURE__*/function (URSymbolType) {\n  URSymbolType[\"Variable\"] = \"$$Variable\";\n  URSymbolType[\"Function\"] = \"$$Function\";\n  URSymbolType[\"Module\"] = \"$$Module\";\n  URSymbolType[\"LogicProgram\"] = \"$$LogicProgram\";\n  return URSymbolType;\n}(URSymbolType || {});\n/**\n * Defines abstract symbol class used by URSymbolService\n */\nclass URSymbol {\n  /**\n   *  Create new URSymbol\n   * @param name\n   * @param reference\n   */\n  constructor(name, reference = false) {\n    this.name = name;\n    this.reference = reference;\n  }\n}\n/**\n * Definition of variable used for discovering variables in the tree node parameters\n */\nclass URVariable extends URSymbol {\n  /**\n   *  Create new URVariable\n   * @param name\n   * @param valueType\n   * @param reference\n   */\n  constructor(name, valueType, reference = false) {\n    super(name, reference);\n    this.type = URSymbolType.Variable;\n    this.valueType = valueType;\n  }\n}\n/**\n * Defines the ValueTypes that can be assigned to a variable.\n */\nvar VariableValueType = /*#__PURE__*/function (VariableValueType) {\n  VariableValueType[\"BOOLEAN\"] = \"boolean\";\n  VariableValueType[\"FLOAT\"] = \"float\";\n  VariableValueType[\"INTEGER\"] = \"integer\";\n  VariableValueType[\"POSE\"] = \"pose\";\n  VariableValueType[\"STRING\"] = \"string\";\n  VariableValueType[\"MATRIX\"] = \"matrix\";\n  VariableValueType[\"ARRAY\"] = \"array\";\n  VariableValueType[\"WAYPOINT\"] = \"waypoint\";\n  VariableValueType[\"GRID\"] = \"grid\";\n  VariableValueType[\"FRAME\"] = \"frame\";\n  VariableValueType[\"TIMER\"] = \"timer\";\n  VariableValueType[\"PROFILE\"] = \"profile\";\n  return VariableValueType;\n}(VariableValueType || {});\n/**\n * Definition of Logic Program\n */\nclass URLogicProgram extends URSymbol {\n  constructor() {\n    super(...arguments);\n    this.type = URSymbolType.LogicProgram;\n  }\n}\n/**\n * Definition of function\n */\nclass URFunction extends URSymbol {\n  constructor() {\n    super(...arguments);\n    this.type = URSymbolType.Function;\n  }\n}\n/**\n * Definition of Module\n */\nclass URModule extends URSymbol {\n  constructor() {\n    super(...arguments);\n    this.type = URSymbolType.Module;\n  }\n}\n/**\n * Check if item is a URSymbol\n * @param item\n * @returns\n */\nfunction isURSymbol(item) {\n  return !!item && Object.prototype.hasOwnProperty.call(item, 'name') && Object.prototype.hasOwnProperty.call(item, 'type') && Object.values(URSymbolType).includes(item.type);\n}\n/**\n * TypeGuard to verify whether a given object is a variable\n * @param item The item to be interrogated\n */\nfunction isVariable(item) {\n  return isURSymbol(item) && item.type === URSymbolType.Variable;\n}\n/**\n * TypeGuard to verify whether a given object is a function\n * @param item The item to be interrogated\n */\nfunction isFunction(item) {\n  return isURSymbol(item) && item.type === URSymbolType.Function;\n}\n/**\n * TypeGuard to verify whether a given object is a module\n * @param item The item to be interrogated\n */\nfunction isModule(item) {\n  return isURSymbol(item) && item.type === URSymbolType.Module;\n}\n/**\n * TypeGuard to verify whether a given object is a logic program\n * @param item The item to be interrogated\n */\nfunction isLogicProgram(item) {\n  return isURSymbol(item) && item.type === URSymbolType.LogicProgram;\n}\n\n/** Describes the various axes used to define poses in the application. */\n/** Position */\n/**  Constant array of the position axes. */\nconst PositionAxes = ['x', 'y', 'z'];\n/** Orientation */\n/** Constant array of the orientation axes. */\nconst OrientationAxes = ['rx', 'ry', 'rz'];\n/** Center of Gravity */\n/** Constant array of the center of gravity axes. */\nconst CenterOfGravityAxes = ['cx', 'cy', 'cz'];\n/** Pose */\n/** Constant array of the combination of a position and an orientation into a pose. */\nconst PoseAxes = [...PositionAxes, ...OrientationAxes];\n\n/** Position */\n/**  Constant array of the InertiaMatrixKeys. */\nconst InertiaMatrixKeys = ['Ixx', 'Iyy', 'Izz', 'Ixy', 'Ixz', 'Iyz'];\n\n/**\n * Checks if the value implements ReferenceItem\n */\nconst isReferenceItem = value => {\n  return value.type === 'Reference';\n};\n/**\n * Checks if the value implements ValueItem\n */\nconst isValueItem = value => {\n  return value.type === 'Value';\n};\n\n/**\n * A type guard to check if an object is a JointPositions\n */\nfunction isJointPositions(jp) {\n  return jp.base !== undefined && jp.shoulder !== undefined && jp.elbow !== undefined && jp.wrist1 !== undefined && jp.wrist2 !== undefined && jp.wrist3 !== undefined;\n}\n\n/**\n * A type guard to check if an object is a KinematicPosition\n */\nfunction iskinematicPosition(kinematicPosition) {\n  return kinematicPosition?.jointVector !== undefined && kinematicPosition?.links !== undefined && kinematicPosition?.tcp !== undefined;\n}\n\n/**\n * OperatorInputType enum\n */\nvar OperatorInputType = /*#__PURE__*/function (OperatorInputType) {\n  OperatorInputType[\"INPUT\"] = \"input\";\n  OperatorInputType[\"MESSAGE\"] = \"message\";\n  return OperatorInputType;\n}(OperatorInputType || {});\n/**\n * PopupLevel enum\n */\nvar PopupLevel = /*#__PURE__*/function (PopupLevel) {\n  PopupLevel[\"ERROR\"] = \"error\";\n  PopupLevel[\"WARNING\"] = \"warning\";\n  PopupLevel[\"INFO\"] = \"info\";\n  return PopupLevel;\n}(PopupLevel || {});\n/**\n * Implementation\n */\nfunction zUpPositionMeters(value1, value2, value3) {\n  if (value1 === undefined) {\n    return {\n      zUpPositionMeters: [0, 0, 0]\n    };\n  } else {\n    return {\n      zUpPositionMeters: [value1, value2, value3]\n    };\n  }\n}\n/**\n * Implementation\n */\nfunction yUpPositionMeters(value1, value2, value3) {\n  if (value1 === undefined) {\n    return {\n      yUpPositionMeters: [0, 0, 0]\n    };\n  } else {\n    return {\n      yUpPositionMeters: [value1, value2, value3]\n    };\n  }\n}\nconst X_AXIS_90_DEG_ROTATION = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2);\nconst X_AXIS_NEG_90_DEG_ROTATION = new Quaternion().setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);\n/**\n * Transforms a Z-up quaternion to Y-up coordinate system.\n */\nfunction transformZUpQuaternionToYUp(zUpQuaternion) {\n  return new Quaternion().multiplyQuaternions(X_AXIS_NEG_90_DEG_ROTATION, zUpQuaternion);\n}\n/**\n * Transforms a Y-up quaternion to Z-up coordinate system.\n */\nfunction transformYUpQuaternionToZUp(yUpQuaternion) {\n  return new Quaternion().multiplyQuaternions(X_AXIS_90_DEG_ROTATION, yUpQuaternion);\n}\n// this code is copied from Quat4d in controller/general/math/Quat4d\n/**\n * Converts a quaternion to rotation vector representation.\n */\nfunction getRotationVectorRadiansFromQuaternion(x, y, z, w) {\n  let norm = x * x + y * y + z * z;\n  const axis = [0, 0, 0];\n  if (norm > 1e-8) {\n    norm = Math.sqrt(norm);\n    const angle = 2 * Math.atan2(norm, w);\n    const invnorm = 1 / norm;\n    axis[0] = x * invnorm * angle;\n    axis[1] = y * invnorm * angle;\n    axis[2] = z * invnorm * angle;\n  }\n  return zUpRotationVectorRadians(...axis);\n}\n/**\n * Implementation\n */\nfunction yUpEulerRotationRadians(value1, value2, value3) {\n  if (value1 === undefined) {\n    return {\n      yUpEulerRotationRadians: [0, 0, 0]\n    };\n  } else {\n    return {\n      yUpEulerRotationRadians: [value1, value2, value3]\n    };\n  }\n}\n/**\n * Implementation\n */\nfunction zUpEulerRotationRadians(value1, value2, value3) {\n  if (value1 === undefined) {\n    return {\n      zUpEulerRotationRadians: [0, 0, 0]\n    };\n  } else {\n    return {\n      zUpEulerRotationRadians: [value1, value2, value3]\n    };\n  }\n}\n/**\n * Implementation\n */\nfunction zUpRotationVectorRadians(value1, value2, value3) {\n  if (value1 === undefined) {\n    return {\n      zUpRotationVectorRadians: [0, 0, 0]\n    };\n  } else {\n    return {\n      zUpRotationVectorRadians: [value1, value2, value3]\n    };\n  }\n}\n/**\n * Implementation\n */\nfunction yUpQuaternion(value1, value2, value3, value4) {\n  if (value1 === undefined) {\n    return {\n      yUpQuaternion: [0, 0, 0, 1]\n    };\n  } else {\n    return {\n      yUpQuaternion: [value1, value2, value3, value4]\n    };\n  }\n}\n/**\n * Converts rotation representation to raw Z-up rotation vector array.\n * Internal helper function for converting various rotation formats to Z-up rotation vector format.\n */\nfunction asZUpRotationVectorRadiansRaw(value) {\n  if ('zUpRotationVectorRadians' in value) {\n    return value.zUpRotationVectorRadians;\n  } else if ('zUpEulerRotationRadians' in value) {\n    const q = new Quaternion().setFromEuler(new Euler(...value.zUpEulerRotationRadians));\n    q.normalize();\n    const a = Math.acos(q.w);\n    let v = new Vector3(q.x, q.y, q.z);\n    if (v.length() > 1.0e-7) {\n      v.normalize();\n    } else {\n      v = new Vector3(0, 0, 0);\n    }\n    v.multiplyScalar(2 * a);\n    return [v.x, v.y, v.z];\n  } else if ('yUpQuaternion' in value) {\n    return asZUpRotationVectorRadiansRaw(PoseUtils.asZUpEulerRotationRadians(value));\n  } else if ('yUpEulerRotationRadians' in value) {\n    return asZUpRotationVectorRadiansRaw(PoseUtils.asZUpEulerRotationRadians(value));\n  } else if (isRosQuaternion(value)) {\n    return getRotationVectorRadiansFromQuaternion(value.x, value.y, value.z, value.w).zUpRotationVectorRadians;\n  } else {\n    return [0, 0, 0];\n  }\n}\n/**\n * Converts rotation representation to raw Z-up Euler rotation array.\n * Internal helper function for converting various rotation formats to Z-up Euler angles.\n */\nfunction asZUpEulerRotationRadiansRaw(value) {\n  if ('zUpEulerRotationRadians' in value) {\n    return value.zUpEulerRotationRadians;\n  } else if ('zUpRotationVectorRadians' in value) {\n    const n = new Vector3(...value.zUpRotationVectorRadians);\n    const ang = n.length();\n    n.normalize();\n    n.multiplyScalar(Math.sin(ang / 2));\n    const euler = new Euler().setFromQuaternion(new Quaternion(n.x, n.y, n.z, Math.cos(ang / 2)));\n    return [euler.x, euler.y, euler.z];\n  } else if ('yUpQuaternion' in value) {\n    return asZUpEulerRotationRadiansRaw(PoseUtils.asYUpEulerRotationRadians(value));\n  } else if ('yUpEulerRotationRadians' in value) {\n    const yUpQuaternion = new Quaternion().setFromEuler(new Euler(...value.yUpEulerRotationRadians));\n    const zUpQuaternion = transformYUpQuaternionToZUp(yUpQuaternion);\n    const zUpEuler = new Euler().setFromQuaternion(zUpQuaternion);\n    return [zUpEuler.x, zUpEuler.y, zUpEuler.z];\n  } else {\n    return [0, 0, 0];\n  }\n}\n/**\n * Converts rotation representation to raw Y-up Euler rotation array.\n * Internal helper function for converting various rotation formats to Y-up Euler angles.\n */\nfunction asYUpEulerRotationRadiansRaw(value) {\n  if ('yUpEulerRotationRadians' in value) {\n    return value.yUpEulerRotationRadians;\n  } else if ('zUpEulerRotationRadians' in value) {\n    const zUpQuaternion = new Quaternion().setFromEuler(new Euler(...value.zUpEulerRotationRadians));\n    const yUpQuaternion = transformZUpQuaternionToYUp(zUpQuaternion);\n    const yUpEuler = new Euler().setFromQuaternion(yUpQuaternion);\n    return [yUpEuler.x, yUpEuler.y, yUpEuler.z];\n  } else if ('zUpRotationVectorRadians' in value) {\n    return asYUpEulerRotationRadiansRaw(PoseUtils.asZUpEulerRotationRadians(value));\n  } else if ('yUpQuaternion' in value) {\n    const euler = new Euler().setFromQuaternion(new Quaternion(...value.yUpQuaternion));\n    return [euler.x, euler.y, euler.z];\n  } else {\n    return [0, 0, 0];\n  }\n}\n/**\n * Converts rotation representation to raw Y-up quaternion array.\n * Internal helper function for converting various rotation formats to Y-up quaternion format.\n */\nfunction asYUpQuaternionRaw(value) {\n  if ('yUpQuaternion' in value) {\n    return value.yUpQuaternion;\n  } else if ('zUpRotationVectorRadians' in value) {\n    return asYUpQuaternionRaw(PoseUtils.asZUpEulerRotationRadians(value));\n  } else if ('yUpEulerRotationRadians' in value) {\n    const q = new Quaternion().setFromEuler(new Euler(...value.yUpEulerRotationRadians));\n    q.normalize();\n    return [q.x, q.y, q.z, q.w];\n  } else if ('zUpEulerRotationRadians' in value) {\n    return asYUpQuaternionRaw(PoseUtils.asYUpEulerRotationRadians(value));\n  } else {\n    return [0, 0, 0, 0];\n  }\n}\n/**\n * Converts position representation to raw Z-up position array.\n * Internal helper function for converting various position formats to Z-up coordinate system.\n */\nfunction asZUpPositionMetersRaw(value) {\n  if ('zUpPositionMeters' in value) {\n    return value.zUpPositionMeters;\n  } else if ('yUpPositionMeters' in value) {\n    return [value.yUpPositionMeters[0], -value.yUpPositionMeters[2], value.yUpPositionMeters[1]];\n  } else if (isRosVector3(value)) {\n    return [value.x, value.y, value.z];\n  } else {\n    return [0, 0, 0];\n  }\n}\n/**\n * Converts position representation to raw Y-up position array.\n * Internal helper function for converting various position formats to Y-up coordinate system.\n */\nfunction asYUpPositionMetersRaw(value) {\n  if ('yUpPositionMeters' in value) {\n    return value.yUpPositionMeters;\n  } else if ('zUpPositionMeters' in value) {\n    return [value.zUpPositionMeters[0], value.zUpPositionMeters[2], -value.zUpPositionMeters[1]];\n  } else {\n    return [0, 0, 0];\n  }\n}\n/**\n * Utility class for converting between different pose and rotation representations.\n * Provides static methods to convert between coordinate systems (Z-up vs Y-up),\n * rotation formats (Euler, quaternion, rotation vector), and position formats.\n */\nclass PoseUtils {\n  /**\n   * Converts rotation representation to Z-up rotation vector format.\n   * @param value - The rotation representation to convert\n   * @returns Z-up rotation vector representation\n   */\n  static asZUpRotationVectorRadians(value) {\n    return zUpRotationVectorRadians(...asZUpRotationVectorRadiansRaw(value));\n  }\n  /**\n   * Converts rotation representation to Z-up Euler rotation format.\n   * @param value - The rotation representation to convert\n   * @returns Z-up Euler rotation representation\n   */\n  static asZUpEulerRotationRadians(value) {\n    return zUpEulerRotationRadians(...asZUpEulerRotationRadiansRaw(value));\n  }\n  /**\n   * Converts rotation representation to Y-up Euler rotation format.\n   * @param value - The rotation representation to convert\n   * @returns Y-up Euler rotation representation\n   */\n  static asYUpEulerRotationRadians(value) {\n    return yUpEulerRotationRadians(...asYUpEulerRotationRadiansRaw(value));\n  }\n  /**\n   * Converts rotation representation to Y-up quaternion format.\n   * @param value - The rotation representation to convert\n   * @returns Y-up quaternion representation\n   */\n  static asYUpQuaternion(value) {\n    return yUpQuaternion(...asYUpQuaternionRaw(value));\n  }\n  /**\n   * Converts position representation to Z-up position format.\n   * @param value - The position representation to convert\n   * @returns Z-up position representation\n   */\n  static asZUpPositionMeters(value) {\n    return zUpPositionMeters(...asZUpPositionMetersRaw(value));\n  }\n  /**\n   * Converts position representation to Y-up position format.\n   * @param value - The position representation to convert\n   * @returns Y-up position representation\n   */\n  static asYUpPositionMeters(value) {\n    return yUpPositionMeters(...asYUpPositionMetersRaw(value));\n  }\n  /**\n   * Converts pose representation to ThreeJS-compatible format (Y-up coordinate system).\n   * @param value - The pose representation to convert\n   * @returns ThreeJS pose representation with Y-up coordinates\n   */\n  static asThreeJsPose(value) {\n    return {\n      objectPosition: PoseUtils.asYUpPositionMeters(value.objectPosition),\n      objectRotation: PoseUtils.asYUpEulerRotationRadians(value.objectRotation),\n      referenceFrame: value.referenceFrame\n    };\n  }\n  /**\n   * Converts pose representation to controller-compatible format (Z-up coordinate system).\n   * @param value - The pose representation to convert\n   * @returns Controller pose representation with Z-up coordinates\n   */\n  static asControllerPose(value) {\n    return {\n      objectPosition: PoseUtils.asZUpPositionMeters(value.objectPosition),\n      objectRotation: PoseUtils.asZUpRotationVectorRadians(value.objectRotation),\n      referenceFrame: value.referenceFrame\n    };\n  }\n  /**\n   * Converts Y-up position to ThreeJS Vector3 object.\n   * @param pos - Y-up position to convert\n   * @returns ThreeJS Vector3 object\n   */\n  static asThreeJsVector3(pos) {\n    return new Vector3().fromArray(pos.yUpPositionMeters);\n  }\n  /**\n   * Converts rotation to ThreeJS Euler object.\n   * @param rot - Rotation representation to convert\n   * @returns ThreeJS Euler object with Y-up orientation\n   */\n  static asThreeJsEuler(rot) {\n    return new Euler(...PoseUtils.asYUpEulerRotationRadians(rot).yUpEulerRotationRadians);\n  }\n  /**\n   * Converts rotation to ThreeJS Quaternion object.\n   * @param rot - Rotation representation to convert\n   * @returns ThreeJS Quaternion object with Y-up orientation\n   */\n  static asThreeJsQuaternion(rot) {\n    return new Quaternion(...PoseUtils.asYUpQuaternion(rot).yUpQuaternion);\n  }\n  /**\n   * Create ControllerPose from Pose\n   */\n  static fromPose(pose, referenceFrame) {\n    return controllerPose(zUpPositionMeters(...pose.position), zUpRotationVectorRadians(...pose.orientation), referenceFrame);\n  }\n  /**\n   * Create Pose from ControllerPose\n   */\n  static asPose(pose) {\n    return {\n      position: [...pose.objectPosition.zUpPositionMeters],\n      orientation: [...pose.objectRotation.zUpRotationVectorRadians]\n    };\n  }\n  /**\n   * Create ControllerPose from ROS transform or pose\n   */\n  static fromRos(transform, referenceFrame) {\n    return {\n      objectPosition: PoseUtils.asZUpPositionMeters(isRosPose(transform) ? transform.position : transform.translation),\n      objectRotation: PoseUtils.asZUpRotationVectorRadians(isRosPose(transform) ? transform.orientation : transform.rotation),\n      referenceFrame\n    };\n  }\n  /**\n   * Create ThreeJsPose from Object3D in world frame\n   */\n  static fromObject3DInWorld(object) {\n    const position = object.getWorldPosition(new Vector3());\n    const euler = new Euler().setFromQuaternion(object.getWorldQuaternion(new Quaternion()));\n    return threeJsPose(yUpPositionMeters(position.x, position.y, position.z), yUpEulerRotationRadians(euler.x, euler.y, euler.z), 'world');\n  }\n  /**\n   * Create ControllerPose for identity pose in a given frame\n   */\n  static controllerPoseIdentityInFrame(referenceFrame) {\n    return {\n      objectPosition: zUpPositionMeters(),\n      objectRotation: zUpRotationVectorRadians(),\n      referenceFrame\n    };\n  }\n  /**\n   * Create ThreeJsPose for identity pose in a given frame\n   */\n  static threeJsPoseIdentityInFrame(referenceFrame) {\n    return {\n      objectPosition: yUpPositionMeters(),\n      objectRotation: yUpEulerRotationRadians(),\n      referenceFrame\n    };\n  }\n}\n/**\n * Type guard to distinguish between ROS pose and transform messages.\n */\nfunction isRosPose(obj) {\n  return 'position' in obj && 'orientation' in obj;\n}\n/**\n * Type guard to handle ROS point and vector3 messages.\n */\nfunction isRosVector3(obj) {\n  return 'x' in obj && 'y' in obj && 'z' in obj;\n}\n/**\n * Type guard to handle ROS point and vector3 messages.\n */\nfunction isRosQuaternion(obj) {\n  return 'x' in obj && 'y' in obj && 'z' in obj && 'w' in obj;\n}\n/**\n * Constructor for ControllerPose\n */\nfunction controllerPose(objectPosition, objectRotation, referenceFrame) {\n  return {\n    objectPosition,\n    objectRotation,\n    referenceFrame\n  };\n}\n/**\n * Constructor for ControllerPose\n */\nfunction threeJsPose(objectPosition, objectRotation, referenceFrame) {\n  return {\n    objectPosition,\n    objectRotation,\n    referenceFrame\n  };\n}\n/**\n * Internal utility for overload implementation detail.\n */\nfunction isControllerPose(pose) {\n  return 'objectPosition' in pose && 'objectRotation' in pose && 'referenceFrame' in pose;\n}\n/**\n * Gets the transformation matrix for this pose.\n */\nfunction getZUpMatrix4(pose) {\n  const euler = PoseUtils.asZUpEulerRotationRadians(pose.objectRotation);\n  const q = new Quaternion().setFromEuler(new Euler(...euler.zUpEulerRotationRadians));\n  q.normalize();\n  return new Matrix4().compose(new Vector3(...pose.objectPosition.zUpPositionMeters), new Quaternion(q.x, q.y, q.z, q.w), new Vector3(1, 1, 1));\n}\n/**\n * Creates PoseUtils.asControllerPose a Z-up transformation matrix.\n */\nfunction getControllerPoseFromZUpMatrix4(matrix, referenceFrame) {\n  const position = new Vector3();\n  const orientation = new Quaternion();\n  const scale = new Vector3();\n  matrix.decompose(position, orientation, scale);\n  return controllerPose(zUpPositionMeters(position.x, position.y, position.z), getRotationVectorRadiansFromQuaternion(orientation.x, orientation.y, orientation.z, orientation.w), referenceFrame);\n}\n/**\n * Traverse a pose through a series of poses.\n */\nfunction traversePoses(pose, fromPoses, toPoses, toFrame) {\n  if (fromPoses.length === 0 && toPoses.length === 0) {\n    return pose;\n  }\n  const fromTransforms = fromPoses.map(pose => getZUpMatrix4(pose));\n  const toTransforms = toPoses.map(pose => getZUpMatrix4(pose).invert());\n  const allTransforms = [...fromTransforms, ...toTransforms];\n  const transformMatrix = allTransforms.reduce((matrix, transform) => transform.multiply(matrix), getZUpMatrix4(pose));\n  return getControllerPoseFromZUpMatrix4(transformMatrix, toFrame);\n}\n\n/**\n * A type guard to check if an object is a Waypoint\n */\nfunction isWaypoint(waypoint) {\n  return waypoint?.frame !== undefined && waypoint?.pose !== undefined && waypoint?.qNear !== undefined;\n}\n\n/**\n *\n */\nfunction getPathToRoot(frameName, frameMap) {\n  const path = [];\n  let currentFrame = frameName;\n  while (currentFrame) {\n    path.push(currentFrame);\n    const frame = frameMap.get(currentFrame);\n    currentFrame = frame?.parent || '';\n  }\n  return path;\n}\n/**\n *\n */\nfunction findCommonAncestor(path1, path2) {\n  const set1 = new Set(path1);\n  for (const frame of path2) {\n    if (set1.has(frame)) {\n      return frame;\n    }\n  }\n  return path1[path1.length - 1];\n}\n/**\n * @param pose pose to be converted\n * @param toFrame name of reference frame at origin of new coordinate system\n *\n * @return Value of pose expressed in the coordinates of toFrame.\n */\nfunction convertPose(pose, toFrame, frames) {\n  if (pose.referenceFrame === toFrame) {\n    return pose;\n  }\n  const frameMap = new Map();\n  frames.forEach(frame => frameMap.set(frame.name, frame));\n  const fromFrameObj = frameMap.get(pose.referenceFrame);\n  const toFrameObj = frameMap.get(toFrame);\n  if (!fromFrameObj || !toFrameObj) {\n    return pose;\n  }\n  const fromPath = getPathToRoot(pose.referenceFrame, frameMap);\n  const toPath = getPathToRoot(toFrame, frameMap);\n  const commonAncestor = findCommonAncestor(fromPath, toPath);\n  const fromPoses = fromPath.slice(0, fromPath.indexOf(commonAncestor)).map(frameName => frameMap.get(frameName)).filter(frame => frame?.parent).map(frame => {\n    if (!frame) {\n      return PoseUtils.controllerPoseIdentityInFrame('world');\n    }\n    return PoseUtils.fromPose(frame.pose, frame.parent || 'world');\n  });\n  const toPoses = toPath.slice(0, toPath.indexOf(commonAncestor)).reverse().map(frameName => frameMap.get(frameName)).map(frame => {\n    if (!frame) {\n      return PoseUtils.controllerPoseIdentityInFrame('world');\n    }\n    return PoseUtils.fromPose(frame.pose, frame.parent || 'world');\n  });\n  return traversePoses(pose, fromPoses, toPoses, toFrame);\n}\nconst DEFAULT_ROTATION_THRESHOLD = 0.01;\nconst DEFAULT_POSITION_THRESHOLD = 0.001;\nconst DEFAULT_COMPARISON_THRESHOLDS = {\n  positionThresholdMeters: DEFAULT_POSITION_THRESHOLD,\n  rotationThresholdRadians: DEFAULT_ROTATION_THRESHOLD\n};\n/**\n *\n */\nfunction posesAreSignificantlySimilar(pose, lastPose, thresholds = DEFAULT_COMPARISON_THRESHOLDS) {\n  if (!pose || !lastPose) {\n    return false;\n  }\n  if (pose.referenceFrame !== lastPose.referenceFrame) {\n    return false;\n  }\n  const {\n    rotationThresholdRadians,\n    positionThresholdMeters\n  } = {\n    ...DEFAULT_COMPARISON_THRESHOLDS,\n    ...thresholds\n  };\n  if (rotationThresholdRadians === undefined || positionThresholdMeters === undefined) {\n    return false;\n  }\n  const positionChange = Math.sqrt(Math.pow(pose.objectPosition.zUpPositionMeters[0] - lastPose.objectPosition.zUpPositionMeters[0], 2) + Math.pow(pose.objectPosition.zUpPositionMeters[1] - lastPose.objectPosition.zUpPositionMeters[1], 2) + Math.pow(pose.objectPosition.zUpPositionMeters[2] - lastPose.objectPosition.zUpPositionMeters[2], 2));\n  if (positionChange > positionThresholdMeters) {\n    return false;\n  }\n  const r1 = pose.objectRotation.zUpRotationVectorRadians;\n  const r2 = lastPose.objectRotation.zUpRotationVectorRadians;\n  const axis1 = new Vector3(...r1);\n  const angle1 = axis1.length();\n  const q1 = new Quaternion().setFromAxisAngle(axis1.normalize(), angle1);\n  const axis2 = new Vector3(...r2);\n  const angle2 = axis2.length();\n  const q2 = new Quaternion().setFromAxisAngle(axis2.normalize(), angle2);\n  return q1.angleTo(q2) <= rotationThresholdRadians;\n}\n/**\n *\n */\nfunction frameArraysAreSignificantlySimilar(frames, lastFrames, thresholds = DEFAULT_COMPARISON_THRESHOLDS) {\n  if (!frames || !lastFrames) {\n    return false;\n  }\n  if (frames.length !== lastFrames.length) {\n    return false;\n  }\n  return frames.every(frame => {\n    const lastFrame = lastFrames.find(f => f.name === frame.name);\n    if (!lastFrame) {\n      return false;\n    }\n    return frame.parent === lastFrame.parent && posesAreSignificantlySimilar(PoseUtils.fromPose(frame.pose, frame.parent ?? 'world'), PoseUtils.fromPose(lastFrame.pose, lastFrame.parent ?? 'world'), thresholds);\n  });\n}\n\n/**\n * Enum representing the possible states of the teach mode.\n */\nvar TeachModeState = /*#__PURE__*/function (TeachModeState) {\n  TeachModeState[\"TEACHING\"] = \"teaching\";\n  TeachModeState[\"STOPPED\"] = \"stopped\";\n  TeachModeState[\"PAUSED\"] = \"paused\";\n  return TeachModeState;\n}(TeachModeState || {});\n/**\n * An enum of all the built in application node types\n */\nvar ApplicationNodeType = /*#__PURE__*/function (ApplicationNodeType) {\n  ApplicationNodeType[\"MOUNTING\"] = \"ur-mounting\";\n  ApplicationNodeType[\"FRAMES\"] = \"ur-frames\";\n  ApplicationNodeType[\"GRID_PATTERN\"] = \"ur-grid-pattern\";\n  ApplicationNodeType[\"END_EFFECTOR\"] = \"ur-end-effector\";\n  ApplicationNodeType[\"SMART_SKILLS\"] = \"ur-smart-skills\";\n  ApplicationNodeType[\"MOTION_PROFILES\"] = \"ur-motion-profiles\";\n  ApplicationNodeType[\"APPLICATION_VARIABLES\"] = \"ur-application-variables\";\n  return ApplicationNodeType;\n}(ApplicationNodeType || {});\nvar SmartSkillType = /*#__PURE__*/function (SmartSkillType) {\n  SmartSkillType[\"ALIGN_TO_Z\"] = \"ur-align-to-z\";\n  SmartSkillType[\"ALIGN_TO_PLANE\"] = \"ur-align-to-plane\";\n  SmartSkillType[\"ALIGN_Z_TO_NEAREST_AXIS\"] = \"ur-align-z-to-nearest-axis\";\n  SmartSkillType[\"CENTER\"] = \"ur-center\";\n  SmartSkillType[\"FREEDRIVE\"] = \"ur-freedrive\";\n  SmartSkillType[\"MOVE_INTO_CONTACT\"] = \"ur-move-into-contact\";\n  SmartSkillType[\"RETRACT\"] = \"ur-retract\";\n  SmartSkillType[\"PUT_IN_BOX\"] = \"ur-put-in-box\";\n  SmartSkillType[\"CUSTOM_SMART_SKILL\"] = \"ur-custom-smart-skill\";\n  SmartSkillType[\"ADMITTANCE_CONTROL\"] = \"ur-admittance-control\";\n  return SmartSkillType;\n}(SmartSkillType || {});\nvar MotionProfileMoveType = /*#__PURE__*/function (MotionProfileMoveType) {\n  MotionProfileMoveType[\"Joint\"] = \"joint\";\n  MotionProfileMoveType[\"Linear\"] = \"linear\";\n  MotionProfileMoveType[\"Process\"] = \"process\";\n  return MotionProfileMoveType;\n}(MotionProfileMoveType || {});\nvar MovementType = /*#__PURE__*/function (MovementType) {\n  MovementType[\"Optimove\"] = \"OptiMove\";\n  MovementType[\"Classic\"] = \"Classic\";\n  return MovementType;\n}(MovementType || {});\nconst floatOperators = ['<', '>'];\nconst registerOperators = [...floatOperators, '==', '!=', '>=', '<='];\nconst operatorInverseMap = {\n  '<': '>=',\n  '>': '<=',\n  '==': '!=',\n  '!=': '==',\n  '>=': '<',\n  '<=': '>'\n};\nvar WaypointType = /*#__PURE__*/function (WaypointType) {\n  WaypointType[\"Teach\"] = \"teach\";\n  WaypointType[\"Expression\"] = \"expression\";\n  return WaypointType;\n}(WaypointType || {});\nvar NodeType = /*#__PURE__*/function (NodeType) {\n  NodeType[\"PROGRAM\"] = \"ur-program\";\n  NodeType[\"FUNCTIONS\"] = \"ur-functions\";\n  NodeType[\"CODE\"] = \"ur-code\";\n  NodeType[\"BEFORE_START\"] = \"ur-before-start\";\n  NodeType[\"CONFIGURATION\"] = \"ur-configuration\";\n  NodeType[\"MODULES\"] = \"ur-modules\";\n  NodeType[\"STATUS\"] = \"ur-status\";\n  NodeType[\"FUNCTION\"] = \"ur-function\";\n  NodeType[\"MODULE\"] = \"ur-module\";\n  NodeType[\"WAIT\"] = \"ur-wait\";\n  NodeType[\"LOOP\"] = \"ur-loop\";\n  NodeType[\"ASSIGNMENT\"] = \"ur-assignment\";\n  NodeType[\"FOLDER\"] = \"ur-folder\";\n  NodeType[\"SCRIPT\"] = \"ur-script\";\n  NodeType[\"MOVE\"] = \"ur-move\";\n  NodeType[\"IF\"] = \"ur-if\";\n  NodeType[\"ELSE\"] = \"ur-else\";\n  NodeType[\"ELSEIF\"] = \"ur-elseif\";\n  NodeType[\"WAYPOINT\"] = \"ur-waypoint\";\n  NodeType[\"SET\"] = \"ur-set\";\n  NodeType[\"COMMENT\"] = \"ur-comment\";\n  NodeType[\"TOOL_FORCE\"] = \"ur-tool-force\";\n  NodeType[\"OPERATOR_INPUT\"] = \"ur-operator-input\";\n  NodeType[\"SET_TCP\"] = \"ur-set-tcp\";\n  NodeType[\"CALL_FUNCTION\"] = \"ur-call-function\";\n  NodeType[\"STATUS_ITEM\"] = \"ur-status-item\";\n  NodeType[\"GRID_ITERATOR\"] = \"ur-grid-iterator\";\n  NodeType[\"CONFIGURATION_VALUE_ITEM\"] = \"ur-configuration-value-item\";\n  NodeType[\"CONFIGURATION_REFERENCE_ITEM\"] = \"ur-configuration-reference-item\";\n  NodeType[\"CONFIGURATION_REFERENCE_ITEM_OPTION\"] = \"ur-configuration-reference-item-option\";\n  NodeType[\"MOVE_TO\"] = \"ur-move-to\";\n  NodeType[\"JOINT_MOVE\"] = \"ur-joint-move\";\n  NodeType[\"LINEAR_MOVE\"] = \"ur-linear-move\";\n  NodeType[\"PATH\"] = \"ur-path\";\n  NodeType[\"PAYLOAD\"] = \"ur-payload\";\n  NodeType[\"TCP\"] = \"ur-tcp\";\n  NodeType[\"ALIGN_TO\"] = \"ur-align-to\";\n  NodeType[\"THREAD\"] = \"ur-thread\";\n  NodeType[\"LOGIC_PROGRAMS\"] = \"ur-logic-programs\";\n  NodeType[\"LOGIC_PROGRAM\"] = \"ur-logic-program\";\n  NodeType[\"HALT\"] = \"ur-halt\";\n  NodeType[\"TIMER\"] = \"ur-timer\";\n  NodeType[\"MOVE_P\"] = \"ur-move-p\";\n  NodeType[\"MOVE_C\"] = \"ur-move-c\";\n  NodeType[\"POINT\"] = \"ur-point\";\n  NodeType[\"SWITCH\"] = \"ur-switch\";\n  NodeType[\"CASE\"] = \"ur-case\";\n  NodeType[\"DEFAULT_CASE\"] = \"ur-default-case\";\n  NodeType[\"DIRECTION\"] = \"ur-direction\";\n  NodeType[\"FRAME\"] = \"ur-frame\";\n  return NodeType;\n}(NodeType || {});\nconst ThreadAction = {\n  KILL: 'Kill',\n  RUN: 'Run'\n};\nvar ActionEnum = /*#__PURE__*/function (ActionEnum) {\n  ActionEnum[\"START\"] = \"Start\";\n  ActionEnum[\"PAUSE\"] = \"Pause\";\n  ActionEnum[\"RESET\"] = \"Reset\";\n  return ActionEnum;\n}(ActionEnum || {});\nvar OrientationMode = /*#__PURE__*/function (OrientationMode) {\n  OrientationMode[\"FIXED\"] = \"fixed\";\n  OrientationMode[\"UNCONSTRAINED\"] = \"unconstrained\";\n  return OrientationMode;\n}(OrientationMode || {});\nvar UntilConditionType = /*#__PURE__*/function (UntilConditionType) {\n  UntilConditionType[\"EXPRESSION\"] = \"expression\";\n  UntilConditionType[\"CONTACT\"] = \"contact\";\n  UntilConditionType[\"DISTANCE\"] = \"distance\";\n  UntilConditionType[\"SIGNAL\"] = \"signal\";\n  return UntilConditionType;\n}(UntilConditionType || {});\nconst DirectionalPositionAxes = ['Y+', 'Y-', 'X+', 'X-', 'Z+', 'Z-'];\nfunction getDirectionalVector(axis) {\n  return DirectionalVectors[axis];\n}\nconst DirectionalVectors = {\n  'X+': '[1.0, 0.0, 0.0]',\n  'X-': '[-1.0, 0.0, 0.0]',\n  'Y+': '[0.0, 1.0, 0.0]',\n  'Y-': '[0.0, -1.0, 0.0]',\n  'Z+': '[0.0, 0.0, 1.0]',\n  'Z-': '[0.0, 0.0, -1.0]'\n};\nvar FrameNodeAction = /*#__PURE__*/function (FrameNodeAction) {\n  FrameNodeAction[\"CREATE\"] = \"create\";\n  FrameNodeAction[\"MOVE\"] = \"move\";\n  FrameNodeAction[\"DELETE\"] = \"delete\";\n  FrameNodeAction[\"CHANGE_PARENT\"] = \"change-parent\";\n  return FrameNodeAction;\n}(FrameNodeAction || {});\nconst APPLICATION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ApplicationService.';\n/**\n * Provides access to data stored in the application\n */\nclass ApplicationService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(APPLICATION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Returns a list of the Application Nodes that contribute data to the currently loaded Application\n   */\n  getAvailableApplicationNodes() {\n    return this.postAndAwait('getAvailableApplicationNodes');\n  }\n  /**\n   * Returns the data stored on the specified Application Node\n   * @param name the name of the Application Node to fetch\n   */\n  getApplicationNode(name) {\n    return this.postAndAwait('getApplicationNode', {\n      name\n    });\n  }\n  /**\n   * Returns true if a grid from application is valid. If the variable name is not a grid\n   * or a grid defined somewhere else then it always returns true.\n   * @param name The name of the variable being validated\n   * @returns true if the grid is valid or is not a grid but a different variable type\n   */\n  isValidGridPattern(name) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const gridPatternNode = yield _this2.getApplicationNode(ApplicationNodeType.GRID_PATTERN);\n      const grid = gridPatternNode.grids.find(grid => grid.grid.name === name);\n      if (!grid) {\n        // Grid is defined somewhere else, so we cannot validate it and assume it is valid\n        return true;\n      }\n      // A grid pattern needs to have at least some corner positions defined.\n      if (!grid.corners.length) {\n        return false;\n      }\n      // Determine whether the grid pattern is 1D (single row or column) or 2D (matrix).\n      // 1D grids need at least 2 corners.\n      // 2D grids need at least 4 corners.\n      const columns = grid.numColumns;\n      const rows = grid.numRows;\n      const requiredCorners = columns === 1 || rows === 1 ? 2 : 4;\n      const hasRequiredCorners = grid.corners.length >= requiredCorners;\n      // Every corner must be defined to be a valid grid.\n      const hasValidCorners = grid.corners.every(corner => !!corner);\n      return hasRequiredCorners && hasValidCorners;\n    })();\n  }\n}\nconst DIALOG_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.DialogService.';\n/**\n * Service for open a dialog\n */\nclass DialogService extends MessageInvokerService {\n  /**\n   * Create a service for the specific worker\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(DIALOG_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Open a Confirmation Dialog with a single dismiss button.\n   * @param title Dialog title\n   * @param text Dialog message\n   * @param icon Dialog icon. It can be 'info', 'warning', 'error', or other icon strings.\n   * @param confirmText Optional. Text for confirm button. Default to 'OK'.\n   * @param  confirmIcon Optional. icon for confirm button. Default to no icon.\n   */\n  openConfirmDialog(title, text, icon, confirmText, confirmIcon) {\n    return this.postAndAwait('openConfirmDialog', {\n      title,\n      text,\n      icon,\n      textIsTranslationKey: false,\n      confirmText,\n      confirmIcon,\n      replacementPatterns: undefined,\n      replacements: undefined,\n      showCancelButton: false,\n      cancelText: undefined\n    });\n  }\n  /**\n   * Open a Confirmation Dialog with a single dismiss button.\n   * @param title Dialog title\n   * @param text Dialog message\n   * @param icon Dialog icon. It can be 'info', 'warning', 'error', or other icon strings.\n   * @param confirmText Optional. Text for confirm button. Default to 'Confirm'.\n   * @param confirmIcon Optional. Icon for confirm button. Default to no icon.\n   * @param cancelText Optional. Text for cancel button. Default to 'Go Back'.\n   */\n  openConfirmCancelDialog(title, text, icon, confirmText, confirmIcon, cancelText) {\n    return this.postAndAwait('openConfirmDialog', {\n      title,\n      text,\n      icon,\n      textIsTranslationKey: false,\n      confirmText,\n      confirmIcon,\n      replacementPatterns: undefined,\n      replacements: undefined,\n      showCancelButton: true,\n      cancelText\n    });\n  }\n  /**\n   * Open a Custom Webcomponent Dialog\n   * @param componentTag The tagname of the webcomponent to render in the dialog\n   * @param initialData The initial data to be passed to the dialog component upon opening\n   * @param options\n   */\n  openCustomDialog(componentTag, initialData, options) {\n    return this.postAndAwait('openCustomDialog', {\n      componentTag,\n      inputData: initialData,\n      options\n    });\n  }\n  /**\n   * Open a Custom Webcomponent Dialog without waiting for user to close\n   * @param componentTag The tagname of the webcomponent to render in the dialog\n   * @param initialData The initial data to be passed to the dialog component upon opening\n   * @param options\n   * @returns The id of the dialog\n   */\n  openCustomDialogNoWait(componentTag, initialData, options) {\n    return this.postAndAwait('openCustomDialogNoWait', {\n      componentTag,\n      inputData: initialData,\n      options\n    });\n  }\n  /**\n   * Close a Custom Webcomponent Dialog\n   * @param id The id of the dialog to close\n   */\n  closeCustomDialogById(id) {\n    return this.postAndAwait('closeCustomDialogById', {\n      id\n    });\n  }\n}\nconst LOG_MESSAGE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.LogMessageService.';\n/**\n * Service for sending log messages\n */\nclass LogMessageService extends MessageInvokerService {\n  /**\n   * Create a service for the specific worker\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(LOG_MESSAGE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Sends a log message.\n   *\n   * @param message The message to be logged\n   */\n  sendLogMessage(message) {\n    return this.postAndAwait('sendLogMessage', message);\n  }\n  /**\n   * Sends a warning log message.\n   *\n   * @param message The message to be logged\n   * @param type The type of message - if not specified 'generic' will be used\n   */\n  warn(message, type = 'generic') {\n    return this.postAndAwait('warn', {\n      message,\n      type\n    });\n  }\n  /**\n   * Sends a info log message.\n   *\n   * @param message The message to be logged\n   * @param type The type of message - if not specified 'generic' will be used\n   */\n  info(message, type = 'generic') {\n    return this.postAndAwait('info', {\n      message,\n      type\n    });\n  }\n  /**\n   * Sends a debug log message.\n   *\n   * @param message The message to be logged\n   * @param type The type of message - if not specified 'generic' will be used\n   */\n  debug(message, type = 'generic') {\n    return this.postAndAwait('debug', {\n      message,\n      type\n    });\n  }\n  /**\n   * Sends a error log message.\n   *\n   * @param message The message to be logged\n   * @param type The type of message - if not specified 'generic' will be used\n   */\n  error(message, type = 'generic') {\n    return this.postAndAwait('error', {\n      message,\n      type\n    });\n  }\n}\nconst LOG_PERFORMANCE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.LogPerformanceService.';\n/**\n * Service for sending log performance metrics\n */\nclass LogPerformanceService extends MessageInvokerService {\n  /**\n   * Create a service for the specific worker\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(LOG_PERFORMANCE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Sends a basic log performance metric where duration, start and end names are the same.\n   *\n   * @param markName\n   */\n  logPerformanceMetrics(markName) {\n    return this.postAndAwait('logPerformanceMetrics', markName);\n  }\n  /**\n   * Sends a extended log performance metric where duration, start and end names can be specified individually.\n   *\n   * @param durationName The duration name\n   * @param startName The start name\n   * @param endName The end name\n   */\n  logPerformanceMetricsExtended(durationName, startName, endName) {\n    return this.postAndAwait('logPerformanceMetricsExtended', {\n      durationName,\n      startName,\n      endName\n    });\n  }\n}\nconst PROGRAM_NODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramNodeService.';\n/**\n * Service that handles node insertion and removal og nodes\n */\nclass ProgramNodeService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   * @param selectedNodeId\n   */\n  constructor(eventTarget, selectedNodeId) {\n    super(PROGRAM_NODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n    this.selectedNodeId = selectedNodeId;\n  }\n  /**\n   * Update the program node\n   * @param node New program node state\n   */\n  updateNode(node) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.postAndAwait('updateParentNode', {\n        node,\n        id: _this3.selectedNodeId\n      });\n    })();\n  }\n}\nconst ROBOT_MOVE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.RobotMoveService.';\n/**\n * RobotMoveService handles movement screen navigation\n */\nclass RobotMoveService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(ROBOT_MOVE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Opens the move screen and returns the selected position of the robot. Returns undefined if cancel is selected\n   * @param options Move screen options\n   */\n  openMoveScreen(options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.postAndAwait('openMoveScreen', options);\n    })();\n  }\n  /**\n   * Opens the autoMove screen\n   * @param targetPosition Joint vector to move to\n   */\n  autoMove(targetPosition) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.postAndAwait('autoMove', targetPosition);\n    })();\n  }\n}\nconst ROBOT_POSITION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.RobotPositionService.';\n/**\n * A service to obtain information on the current robot position\n */\nclass RobotPositionService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(ROBOT_POSITION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Gets the id of the currently selected frame id to perform moves relative to\n   */\n  getRelativeToFrameId() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return _this6.postAndAwait('getRelativeToFrameId');\n    })();\n  }\n  /**\n   * Gets the kinematic info\n   */\n  getKinematicInfo() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return _this7.postAndAwait('getKinematicInfo');\n    })();\n  }\n  /**\n   * Implementation\n   */\n  getInverseKinematics(pose, qNear) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return _this8.postAndAwait('getInverseKinematics', {\n        pose: isControllerPose(pose) ? PoseUtils.asPose(pose) : pose,\n        qNear\n      });\n    })();\n  }\n  /**\n   * Get the current pose of the TCP relative to the given frame\n   */\n  getPoseRelativeToFrame(frame) {\n    return this.postAndObserve('getPoseRelativeToFrame', {\n      frame\n    });\n  }\n  /**\n   * Get the current joint positions of the robot\n   */\n  getJointPositions() {\n    return this.postAndObserve('getJointPositions');\n  }\n  /**\n   * Converts the jointPositions to TCPPose.\n   */\n  convertJointPositionsToTcpPose(jointPositions) {\n    return this.postAndAwait('convertJointPositionsToTcpPose', {\n      jointPositions\n    });\n  }\n  /**\n   * Get current position of the robot\n   */\n  getCurrentPosition() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return _this9.postAndAwait('getCurrentPosition');\n    })();\n  }\n}\nconst SAFETY_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SafetyService.';\n/**\n * Service for getting information about Safety\n */\nclass SafetyService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SAFETY_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Returns a list of safety IO's\n   */\n  getIOs() {\n    return this.postAndAwait('getIOs');\n  }\n  /**\n   * Get the maximum allowed tool force for the robot\n   */\n  getMaxToolForce() {\n    return this.postAndAwait('getMaxToolForce');\n  }\n  /**\n   * Get the payload limits for the robot\n   */\n  getPayloadLimits() {\n    return this.postAndAwait('getPayloadLimits');\n  }\n  /**\n   * Get the operational mode of the robot\n   */\n  getOperationalMode() {\n    return this.postAndObserve('getOperationalMode');\n  }\n}\nconst SOURCE_MESSAGE_TYPE_BASE = 'ur.web.message.SourceService.';\n/**\n * Service for getting information about Sources and Signals\n */\nclass SourceService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param target\n   */\n  constructor(eventTarget) {\n    super(SOURCE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Returns the ID's of Sources that are available to the application\n   * @param filter SignalFilter used to filter only Sources which contain Signals matching the filter\n   */\n  getSources(filter) {\n    return firstValueFrom(this.postAndObserve('sourcesList', {\n      filter\n    }).pipe(map(sources => {\n      return sources.map(source => source.sourceID);\n    })));\n  }\n  /**\n   * Returns the map of Sources\n   */\n  sources(filter) {\n    return this.postAndObserve('sources', {\n      filter\n    });\n  }\n  /**\n   * Returns the source node label for the griven groupId\n   */\n  sourceNodeLabel(groupId) {\n    return this.sourceNodeLabels().pipe(map(labels => labels[groupId]));\n  }\n  /**\n   * Returns the map of source node labels\n   */\n  sourceNodeLabels() {\n    return this.postAndObserve('getSourceNodeLabels', {});\n  }\n  /**\n   * Returns the list of Signals in a Source\n   * @param sourceID The Source to list Signals for\n   * @param filter SignalFilter used to filter only Signals which match the filter\n   * @deprecated use getSourceSignals instead\n   */\n  getSignals(sourceID, filter) {\n    return firstValueFrom(this.postAndObserve('getSourceSignals', {\n      sourceID,\n      filter\n    }));\n  }\n  /**\n   * Returns the list of Signals in a Source\n   * @param sourceGroupID The Source group, containing the source to provide signals for\n   * @param sourceID The Source to list Signals for\n   * @param filter SignalFilter used to filter only Signals which match the filter\n   */\n  sourceSignals(sourceGroupID, sourceID, filter) {\n    return this.postAndObserve('getSourceSignals', {\n      sourceGroupID,\n      sourceID,\n      filter\n    });\n  }\n  /**\n   * Returns an Observable providing Signal events\n   * @param sourceID The Source containing the Signals to provide events for\n   * @param filter SignalFilter used to filter only events for Signals which match the filter\n   * @deprecated use getSourceUpdates instead\n   */\n  getSignalUpdates(sourceID, filter) {\n    return this.postAndObserve('getSignalUpdates', {\n      sourceID,\n      filter\n    });\n  }\n  /**\n   * Returns an Observable providing Signal events\n   * @param sourceGroupID The Source group, containing the source to provide events for\n   * @param sourceID The Source containing the Signals to provide events for\n   * @param filter SignalFilter used to filter only events for Signals which match the filter\n   */\n  getSourceUpdates(sourceGroupID, sourceID, filter) {\n    // Combine results of \"old\" and \"new\" APIs, and return whichever produces a value\n    // The old message\n    const o1 = this.postAndObserve('getSignalUpdates', {\n      sourceID,\n      filter\n    });\n    // The new message\n    const o2 = this.postAndObserve('getSourceUpdates', {\n      sourceGroupID,\n      sourceID,\n      filter\n    });\n    return merge(o1, o2);\n  }\n  /**\n   * Returns the generated script code for setting the signal to the given value\n   * @param sourceID The ID of the source containing the signal to set\n   * @param signalID The ID of the signal to set\n   * @param value The value to set the signal to - for digital values use 0 or 1, for registers use only integers, for analog values use any float\n   * @deprecated use getSetSignalScript instead\n   */\n  generateSetSignalScript(sourceID, signalID, value) {\n    return this.postAndAwait('generateSetSignalScript', {\n      sourceID,\n      signalID,\n      value\n    });\n  }\n  /**\n   * Returns the generated script code for setting the signal to the given value\n   * @param sourceGroupID The Source group, containing the source and signal to provide script for\n   * @param sourceID The ID of the source containing the signal to set\n   * @param signalID The ID of the signal to set\n   * @param value The value to set the signal to - for digital values use 0 or 1, for registers use only integers, for analog values use any float\n   */\n  getSetSignalScript(sourceGroupID, sourceID, signalID, value) {\n    // Combine results of \"old\" and \"new\" APIs, and return whichever produces a value\n    return new Promise((resolve, reject) => {\n      Promise.all([\n      // The old message\n      this.postAndAwait('generateSetSignalScript', {\n        sourceID,\n        signalID,\n        value\n      }),\n      // The new message\n      this.postAndAwait('getSetSignalScript', {\n        sourceGroupID,\n        sourceID,\n        signalID,\n        value\n      })]).then(value => {\n        // Return whichever value (if any) that comes back (priority on the \"new\" value)\n        resolve(value[1] ? value[1] : value[0] ? value[0] : '');\n      }).catch(reason => reject(reason));\n    });\n  }\n  /**\n   * Returns the generated script code for getting the value of a given signal\n   * @param sourceID The ID of the source containing the signal to get\n   * @param signalID The ID of the signal to get\n   * @deprecated use getGetSignalScript instead\n   */\n  generateGetSignalScript(sourceID, signalID) {\n    return this.postAndAwait('generateGetSignalScript', {\n      sourceID,\n      signalID\n    });\n  }\n  /**\n   * Returns the generated script code for getting the value of a given signal\n   * @param groupId The Source group, containing the source to provide events for\n   * @param sourceId The ID of the source containing the signal to get\n   * @param signalId The ID of the signal to get\n   */\n  getGetSignalScript(groupId, sourceId, signalId) {\n    // Combine results of \"old\" and \"new\" APIs, and return whichever produces a value\n    return new Promise((resolve, reject) => {\n      Promise.all([\n      // The old message\n      this.postAndAwait('generateGetSignalScript', {\n        sourceID: sourceId,\n        signalID: signalId\n      }),\n      // The new message\n      this.postAndAwait('getGetSignalScript', {\n        groupId,\n        sourceId,\n        signalId\n      })]).then(value => {\n        // Return whichever value (if any) that comes back (priority on the \"new\" value)\n        resolve(value[1] ? value[1] : value[0] ? value[0] : '');\n      }).catch(reason => reject(reason));\n    });\n  }\n  /**\n   * Returns an object literal containing a mapping of SignalIDs -> AnalogDomains\n   * @param sourceID The ID of the Source for which to get Domain data\n   * @deprecated should be handled by the individual contribution\n   */\n  getAnalogSignalDomains(sourceID) {\n    return this.postAndAwait('getAnalogSignalDomains', {\n      sourceID\n    });\n  }\n  /**\n   * Performs validation on a new value that will be used in a set script\n   * @param groupId The contribution groupId\n   * @param sourceId The contribution sourceId\n   * @param signalId The contribution signalId\n   * @param value The value that will be set\n   */\n  validateSetSignal(groupId, sourceId, signalId, value) {\n    return this.postAndAwait('validateSetSignal', {\n      groupId,\n      sourceId,\n      signalId,\n      value\n    });\n  }\n  /**\n   * Performs validation on a new value that will be used in a get script\n   * @param groupId The contribution groupId\n   * @param sourceId The contribution sourceId\n   * @param signalId The contribution signalId\n   * @param value The value that will be got\n   * @param operator The operator on the value that will be got\n   */\n  validateGetSignal(groupId, sourceId, signalId, value, operator) {\n    return this.postAndAwait('validateGetSignal', {\n      groupId,\n      sourceId,\n      signalId,\n      value,\n      operator\n    });\n  }\n  /**\n   * Returns info about the signals for a given source\n   * @param groupId\n   * @param sourceId\n   */\n  getSignalsDomainData(groupId, sourceId) {\n    // What this needs to do is:\n    // If it's the old tool/wired IO (if the groupId is 'ur-robot') then call through to the getSignalsDomainData method\n    // on the data-store SourceService\n    // Else call the getSignalsDomainData method from the behavior of the groupId SourcesNode\n    return this.postAndAwait('getSignalsDomainData', {\n      groupId,\n      sourceId\n    });\n  }\n  /**\n   * Sets a value on a signal\n   * @param sourceID The ID of the Source, containing the Signal to set\n   * @param signalID The ID of the Signal to set\n   * @param value The value to set\n   * @deprecated use setSourceSignalValue instead\n   */\n  setSignalValue(sourceID, signalID, value) {\n    const updateSignalValue = {\n      sourceID,\n      signalID,\n      value\n    };\n    return this.postAndAwait('setSignalValue', updateSignalValue);\n  }\n  /**\n   * Sets a value on a signal\n   * @param sourceGroupID The Source group, containing the source to provide events for\n   * @param sourceID The ID of the Source, containing the Signal to set\n   * @param signalID The ID of the Signal to set\n   * @param value The value to set\n   */\n  setSourceSignalValue(sourceGroupID, sourceID, signalID, value) {\n    const updateSignalValue = {\n      sourceID,\n      signalID,\n      value\n    };\n    const setSignalValue = {\n      sourceGroupID,\n      sourceID,\n      signalID,\n      value\n    };\n    // Send the update to both \"old\" and \"new\" APIs\n    return new Promise((resolve, reject) => {\n      Promise.all([\n      // The old message\n      this.postAndAwait('setSignalValue', updateSignalValue),\n      // The new message\n      this.postAndAwait('setSourceSignalValue', setSignalValue)]).then(() => resolve()).catch(reason => {\n        reject(reason);\n      });\n    });\n  }\n  /**\n   * Returns an object literal containing a mapping of SignalIDs -> Labels\n   * @param sourceID The ID of the Source for which to get the Label mappings\n   * @deprecated Source contributions will be responsible for providing labels for signals directly\n   */\n  getSignalLabels(sourceID) {\n    return this.postAndAwait('getSignalLabels', sourceID);\n  }\n  /**\n   * Returns an object literal containing a mapping of SignalIDs -> Presets\n   * @param sourceID The ID of the Source for which to get the Preset mappings\n   * @deprecated Source contributions will be responsible for handling presets themselves\n   */\n  getSignalPresets(sourceID) {\n    return this.postAndAwait('getSignalPresets', sourceID);\n  }\n}\n\n/**\n * A service for setting signal properties such as their label or preset\n */\nclass SignalService extends MessageInvokerService {\n  /**\n   *\n   */\n  constructor(eventTarget, sourceID) {\n    super(SOURCE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n    this.sourceID = sourceID;\n  }\n  /** Update the label for a specific signal id\n   * @param signalID id for the signal being labelled\n   * @param label the new label for the signal\n   * @deprecated Source contributions will be responsible for labels for signals directly\n   */\n  updateSignalLabel(signalID, label) {\n    var _this0 = this;\n    return _asyncToGenerator(function* () {\n      const setLabel = {\n        sourceID: _this0.sourceID,\n        signalID,\n        label\n      };\n      return _this0.postAndAwait('updateSignalLabel', setLabel);\n    })();\n  }\n  /** Update the Analog Domain for a specific signal id\n   * @param signalID id for the signal being changed\n   * @param analogDomainValueEnum the domain to set\n   * @deprecated should be handled by the individual contribution\n   */\n  updateSignalAnalogDomain(signalID, analogDomainValueEnum) {\n    var _this1 = this;\n    return _asyncToGenerator(function* () {\n      const updateAnalogDomainValue = {\n        sourceID: _this1.sourceID,\n        signalID,\n        analogDomain: analogDomainValueEnum\n      };\n      return _this1.postAndAwait('updateSourceSignalAnalogDomain', updateAnalogDomainValue);\n    })();\n  }\n  /**\n   * Set the Preset Action for a given Digital-In signal\n   * @param signalID ID of the signal to set the preset for\n   * @param preset the preset to set\n   * @deprecated Source contributions will be responsible for handling presets themselves\n   */\n  setDigitalInPreset(signalID, preset) {\n    const updateAnalogInPreset = {\n      sourceID: this.sourceID,\n      signalID,\n      preset\n    };\n    return this.postAndAwait('setDigitalInPreset', updateAnalogInPreset);\n  }\n}\nconst SOURCE_NODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SourceNodeService.';\n/**\n * Service that handles updating source nodes\n */\nclass SourceNodeService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SOURCE_NODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Update the source node\n   * @param node New source node state\n   */\n  updateNode(node) {\n    return this.postAndAwait('updateNode', node);\n  }\n}\nconst TREE_BUILDER_MESSAGE_TYPE_BASE = 'ur.web.message.TreeBuilder.';\n/**\n * TreeBuilder\n *  Provides methods to build program node trees that can then be passed to\n *  the application for insertion to the main program.\n */\nclass TreeBuilder extends MessageInvokerService {\n  /**\n   * @constructor\n   */\n  constructor(eventTarget) {\n    super(TREE_BUILDER_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Turns the passed in ProgramNode into a BranchNode, allowing children to\n   * be added to the subtree of the given node.\n   * @param node The ProgramNode to convert to a BranchNode\n   */\n  createBranchNode(node) {\n    return {\n      children: [],\n      type: node.type,\n      version: node.version,\n      allowsChildren: node.allowsChildren,\n      lockChildren: node.lockChildren,\n      parameters: node.parameters\n    };\n  }\n  /**\n   * Appends a child node to the subtree of the given parent node\n   * @param parentNode The BranchNode to add the child to\n   * @param node The child ProgramNode to be added to the subtree\n   */\n  appendChild(parentNode, node) {\n    parentNode.children.push(node);\n  }\n  /**\n   * Requests a new instance of a ProgramNode from the application\n   * @param ofType The type of the ProgramNode to be instantiated - see the\n   * nodeType enum for the builtin types.\n   */\n  createNode(ofType) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      return _this10.postAndAwait('createNode', ofType);\n    })();\n  }\n}\nconst SYMBOL_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SymbolService.';\n/**\n * Service for generating and getting reserved variable names\n */\nclass SymbolService extends MessageInvokerService {\n  /**\n   * Create a service for the specific worker\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SYMBOL_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Get a list of available variables\n   * @returns\n   */\n  getVariables() {\n    return this.postAndAwait('getVariables', {});\n  }\n  /**\n   * Get an observable of available variables\n   */\n  variables() {\n    return this.postAndObserve('variables', {});\n  }\n  /**\n   * Returns a list of the global variables as a stream.\n   * @returns {Observable<Array<GlobalVariable>>} Observable of global variables object\n   */\n  globalVariables() {\n    return this.postAndObserve('globalVariables', {});\n  }\n  /**\n   * Generates a new variable. The variable name is based on the suggested name.\n   * If the suggested name is not usable a new, based on the suggestion, will be created\n   *\n   * @param suggestedName The intended name for the variable, will be suffixed if the name is already taken\n   * @param valueType The ValueType of the variable\n   * @param blacklist Optional parameter to provide additional names which shouldn't be used.\n   */\n  generateVariable(suggestedName, valueType, blacklist) {\n    return this.postAndAwait('generateVariable', {\n      suggestedName,\n      valueType,\n      blacklist\n    });\n  }\n  /**\n   * Return true if the provided name is the name of a registered variable\n   *\n   * @param variableName\n   */\n  isRegisteredVariableName(variableName) {\n    return this.postAndAwait('isRegisteredVariableName', variableName);\n  }\n  /**\n   * Get a list of available functions for the given module name. If no name provided, functions for the global scope\n   * @param moduleName\n   * @returns\n   */\n  getFunctions(moduleName = '') {\n    return this.postAndAwait('getFunctions', {\n      moduleName\n    });\n  }\n  /**\n   * Get functions map. Contains a list of functions for each module name. Note: Empty string is the global scope.\n   * @param filter Filter on if the function is async or not\n   * is async or not\n   * @returns\n   */\n  getFunctionsMap(filter) {\n    return this.postAndAwait('getFunctionsMap', filter);\n  }\n  /**\n   * Generates a new function. The function name is based on the suggested name.\n   * If the suggested name is not usable a new, based on the suggestion, will be created\n   *\n   * @param suggestedName\n   * @param moduleName\n   */\n  generateFunction(suggestedName, moduleName) {\n    return this.postAndAwait('generateFunction', {\n      functionName: suggestedName,\n      moduleName\n    });\n  }\n  /**\n   * Return true if the provided name is the name of a registered function\n   *\n   * @param functionName\n   * @param moduleName\n   */\n  isRegisteredFunctionName(functionName, moduleName) {\n    return this.postAndAwait('isRegisteredFunctionName', {\n      functionName,\n      moduleName\n    });\n  }\n  /**\n   * Get a list of available modules\n   * @returns\n   */\n  getModuleNames() {\n    return this.postAndAwait('getModuleNames', {});\n  }\n  /**\n   * Generates a new module. The module name is based on the suggested name.\n   * If the suggested name is not usable a new, based on the suggestion, will be created\n   *\n   * @param suggestedName\n   */\n  generateModule(suggestedName) {\n    return this.postAndAwait('generateModule', suggestedName);\n  }\n  /**\n   * Return true if the provided name is the name of a registered module\n   *\n   * @param moduleName\n   */\n  isRegisteredModuleName(moduleName) {\n    return this.postAndAwait('isRegisteredModuleName', {\n      moduleName\n    });\n  }\n  /**\n   * Get a list of available Logic Programs\n   * @returns\n   */\n  getLogicProgramNames() {\n    return this.postAndAwait('getLogicProgramNames', {});\n  }\n  /**\n   * Generates a new Logic Program. The program name is based on the suggested name.\n   * If the suggested name is not usable a new, based on the suggestion, will be created\n   *\n   * @param suggestedName\n   */\n  generateLogicProgram(suggestedName) {\n    return this.postAndAwait('generateLogicProgram', suggestedName);\n  }\n  /**\n   * Return true if the provided name is the name of a registered Logic Program\n   *\n   * @param logicProgramName\n   */\n  isRegisteredLogicProgramName(logicProgramName) {\n    return this.postAndAwait('isRegisteredLogicProgramName', {\n      logicProgramName\n    });\n  }\n  /**\n   *  Return true if the provided name is a registered name of the given type.\n   * @param name\n   * @param type\n   * @param moduleName\n   * @param unique\n   * @returns\n   */\n  isRegisteredName(name, type, moduleName, unique = false) {\n    return this.postAndAwait('isRegisteredName', {\n      name,\n      type,\n      moduleName,\n      unique\n    });\n  }\n  /**\n   * Return true if the declaring program node is suppressed\n   * @param name The name of the symbol\n   * @param moduleName The module of the symbol if defined\n   * @return Boolean describing if the declaring node is suppressed\n   */\n  isSuppressed(name, moduleName) {\n    return this.postAndAwait('isSuppressed', {\n      name,\n      moduleName\n    });\n  }\n  /**\n   * Get the URVariable with the given name\n   * @return URVariable with the given name\n   * @param name Name of the variable to get\n   */\n  getVariable(name) {\n    return this.postAndAwait('getVariable', {\n      name\n    });\n  }\n  /**\n   *\n   * @param variableName name of the variable being validated\n   * @param acceptedTypes an optional array of valid type strings, e.g., float.\n   * @returns true if the variable is registered not suppressed, and is of a valid value type\n   */\n  isValidVariable(variableName, acceptedTypes) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const isRegistered = yield _this11.isRegisteredVariableName(variableName);\n      const isSuppressed = yield _this11.isSuppressed(variableName);\n      const variable = yield _this11.getVariable(variableName);\n      let isOfValidValueType = true;\n      if (acceptedTypes) {\n        isOfValidValueType = acceptedTypes.some(acceptedType => acceptedType === variable?.valueType);\n      }\n      return isRegistered && !isSuppressed && isOfValidValueType;\n    })();\n  }\n  /**\n   * Return true if the function is a thread\n   * @param functionName The name of the function\n   * @param moduleName The module of the symbol if defined\n   * @return Boolean describing if the function is a thread\n   */\n  isAsyncFunction(functionName, moduleName) {\n    return this.postAndAwait('isAsyncFunction', {\n      functionName,\n      moduleName\n    });\n  }\n}\nconst VALIDATION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ValidationService.';\n/**\n * Allows program nodes to obtain the validation response generated from their respective behavior worker.\n */\nclass ValidationService extends MessageInvokerService {\n  /**\n   * Creates a new instance of the ValidationService\n   * @param eventTarget the target to send message events on\n   * @param selectedNodeId the id of the currently selected node\n   */\n  constructor(eventTarget, selectedNodeId) {\n    super(VALIDATION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n    this.selectedNodeId = selectedNodeId;\n  }\n  /**\n   * Returns the last validation response generated from the behavior worker.\n   * If the node is valid the returned response will be exactly { isValid: true } without any extra data.\n   */\n  getValidationResponse() {\n    var _this12 = this;\n    return _asyncToGenerator(function* (nodeId = _this12.selectedNodeId) {\n      return _this12.postAndAwait('getValidationResponse', {\n        id: nodeId\n      });\n    }).apply(this, arguments);\n  }\n}\nconst SNACKBAR_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SnackbarService.';\n/**\n * Service that handles showing snack notifications.\n */\nclass SnackbarService extends MessageInvokerService {\n  /**\n   * Create a service for the specific eventTarget\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SNACKBAR_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Open a snack notification.\n   * @param message Snackbar message\n   * @param type Optional. Type of notification (success, error, warning, info(default)).\n   * @param title Optional. Snackbar title\n   */\n  showSnackbar(message, type, title) {\n    return this.postAndAwait('showSnackbar', {\n      message,\n      type,\n      title\n    });\n  }\n}\nconst SMART_SKILL_INSTANCE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SmartSkillInstanceService.';\n/**\n * Service that handles updating smart skill instances\n */\nclass SmartSkillInstanceService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SMART_SKILL_INSTANCE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Update the program node\n   * @param instance New smart skill instance data\n   */\n  updateInstance(instance) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      return _this13.postAndAwait('updateInstance', {\n        instance\n      });\n    })();\n  }\n  /**\n   * Get all smart skill instances as an observable stream.\n   * @returns Observable<SmartSkillInstance[]>\n   */\n  getInstances() {\n    return this.postAndObserve('getAllInstancesObservable', {});\n  }\n  /**\n   * Get the smart skill instance by type and optionally name. If name is not provided, the first instance of the type is returned.\n   * @param type Type of the smart skill instance\n   * @param name Optional name of the smart skill instance\n   */\n  getInstance(type, name) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return firstValueFrom(_this14.getInstances().pipe(map$1(instances => instances.find(instance => instance.type === type && (!name || instance.name === name)) || undefined)));\n    })();\n  }\n}\nconst PROGRAM_EXECUTION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramExecutionService.';\n/**\n * Service that handles program execution\n */\nclass ProgramExecutionService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(PROGRAM_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Stop the program\n   */\n  stopProgram() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      return _this15.postAndAwait('stopProgram');\n    })();\n  }\n  /**\n   * Play the program\n   */\n  playProgram() {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      return _this16.postAndAwait('playProgram');\n    })();\n  }\n  /**\n   * Resumes the program\n   */\n  resumeProgram() {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      return _this17.postAndAwait('resumeProgram');\n    })();\n  }\n  /**\n   * Pause the program\n   */\n  pauseProgram() {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      return _this18.postAndAwait('pauseProgram');\n    })();\n  }\n  /**\n   * Get the Program Status\n   */\n  getProgramStatus() {\n    return this.postAndObserve('getStatus');\n  }\n  /**\n   * Step to the next line in the program\n   */\n  stepProgram() {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      return _this19.postAndAwait('stepProgram');\n    })();\n  }\n}\nconst TOOL_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ToolService.';\n/**\n * Provides access to URScript functions\n * Parameters are aligned with URScript functions, see URScript manual for more info.\n */\nclass ToolService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(TOOL_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Sets the active tcp offset, i.e. the transformation from the output flange coordinate system to the TCP as a pose.\n   * @see ScriptBuilder#setTcp\n   */\n  setTcp(tcp) {\n    return this.postAndAwait('setTCP', tcp);\n  }\n  /**\n   * Sets the mass, CoG (center of gravity), the inertia matrix of the active payload\n   * @see ScriptBuilder#setTargetPayload\n   */\n  setTargetPayload(mass, cog, inertia) {\n    return this.postAndAwait('setTargetPayload', {\n      mass,\n      cog,\n      inertia\n    });\n  }\n  /**\n   * Get active TCP name\n   * @returns `Observable<string>` emitting the name of the currently active TCP known to the controller.\n   * If the TCP has been set without providing a name, this `Observable` will emit an empty `string`.\n   * For documentation on `Observable`, see https://rxjs.dev/guide/observable\n   */\n  getActiveTCPName() {\n    return this.postAndObserve('getActiveTCPName');\n  }\n}\nconst PROGRAM_CODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramCodeService.';\n/**\n * Service that handles code generation\n */\nclass ProgramCodeService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param target\n   */\n  constructor(eventTarget) {\n    super(PROGRAM_CODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   *\n   */\n  generateModulesScriptCode() {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      return _this20.postAndAwait('GENERATE_MODULES_SCRIPT_CODE', {});\n    })();\n  }\n  /**\n   *\n   */\n  generateGlobalFunctionsScriptCode() {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      return _this21.postAndAwait('GENERATE_FUNCTIONS_SCRIPT_CODE', {});\n    })();\n  }\n  /**\n   *\n   */\n  generateModulesAndGlobalFunctionsScriptCode() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      return _this22.postAndAwait('GENERATE_MODULES_AND_FUNCTIONS_SCRIPT_CODE', {});\n    })();\n  }\n  /**\n   *\n   */\n  getProgramPreambleScriptCode() {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      return _this23.postAndAwait('GET_PROGRAM_PREAMBLE_SCRIPT_CODE', {});\n    })();\n  }\n  /**\n   *\n   */\n  generateFunctionScriptCode(functionNodeID) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      return _this24.postAndAwait('GET_FUNCTION_SCRIPT_CODE', functionNodeID);\n    })();\n  }\n}\nconst MOUNTING_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.MountingService.';\n/**\n * Provides access to URScript functions\n * Parameters in this case are not aligned with setGravity\n * The input parameters are transformed into parameters for the setGravity URScript function\n * @see ScriptBuilder#setGravity\n */\nclass MountingService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(MOUNTING_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Sets the robot mounting as a rotation and a tilt\n   * @param rotation The robot's rotation at the base\n   * @param tilt The robot's tilt at the base\n   */\n  setMounting(rotation, tilt) {\n    return this.postAndAwait('setMounting', {\n      rotation,\n      tilt\n    });\n  }\n}\nconst FRAMES_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.FrameService.';\n/**\n * Internal utility for overload implementation detail.\n */\nfunction isZUpRotationVectorRadians$1(obj) {\n  return 'zUpRotationVectorRadians' in obj;\n}\n/**\n * Create, Read, Update, Delete functionality for frames\n * Parameters are aligned with URScript functions, see URScript manual for more info.\n */\nclass FramesService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(FRAMES_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Implementation\n   */\n  addFrame(name, pose, refFrame = 'base') {\n    return this.postAndAwait('addFrame', {\n      name,\n      pose: isControllerPose(pose) ? PoseUtils.asPose(pose) : pose,\n      refFrame: isControllerPose(pose) ? pose.referenceFrame : refFrame\n    });\n  }\n  /**\n   * Delete the frame named frame from the world model.\n   * The \"world\", \"base\", and \"tcp\" frames cannot be deleted.\n   * Any frames that are attached to the deleted frame will be attached to the \"world\" frame with new frame offsets set\n   * such that the detached frame does not move in the world.\n   * This command will fail if the frame does not exist.\n   * @see ScriptBuilder#deleteFrame\n   */\n  deleteFrame(name) {\n    return this.postAndAwait('deleteFrame', {\n      name\n    });\n  }\n  /**\n   * Implementation\n   */\n  moveFrame(name, pose, refFrame = 'base') {\n    return this.postAndAwait('moveFrame', {\n      name,\n      pose: isControllerPose(pose) ? PoseUtils.asPose(pose) : pose,\n      refFrame: isControllerPose(pose) ? pose.referenceFrame : refFrame\n    });\n  }\n  /**\n   * Implementation\n   */\n  setFrameOrientation(name, orientation) {\n    return this.postAndAwait('setFrameOrientation', {\n      name,\n      orientation: isZUpRotationVectorRadians$1(orientation) ? orientation.zUpRotationVectorRadians : orientation\n    });\n  }\n  /**\n   * Attaches the child frame to the parent world model object. The relative transform between the parent and child will be set such that\n   * the child does not move in the world when the attachment occurs.\n   * The child cannot be \"world\", \"tcp\", or the same as parent.\n   * This will fail if child or parent is not an existing frame, or this makes the attachments form a closed chain.\n   * @see ScriptBuilder#attachFrame\n   */\n  attachFrame(child, parent) {\n    return this.postAndAwait('attachFrame', {\n      child,\n      parent\n    });\n  }\n  /**\n   * Returns an observable of live frame data.\n   */\n  observeFrames() {\n    return this.postAndObserve('observeFrames');\n  }\n}\nconst OPERATOR_SCREEN_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.OperatorScreenService.';\n/**\n * Service for handling updating of operator screen instances\n */\nclass OperatorScreenService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(OPERATOR_SCREEN_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Update the operator screen instance\n   * @param operatorScreen New operator screen instance data\n   */\n  updateOperatorScreen(operatorScreen) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      return _this25.postAndAwait('updateOperatorScreen', {\n        operatorScreen\n      });\n    })();\n  }\n}\nconst ROBOT_INFO_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.RobotInfoService.';\n/**\n * Provides access to information on the robot\n */\nclass RobotInfoService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(ROBOT_INFO_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Get the robot type\n   */\n  getRobotType() {\n    return this.postAndAwait('getRobotType');\n  }\n  /**\n   * Get the robot serial number\n   */\n  getSerialNumber() {\n    return this.postAndAwait('getSerialNumber');\n  }\n  /**\n   * Checks if the robot is in 3 PE stop state.\n   *\n   * @returns {Observable<boolean>} - An observable that emits `true` if the robot\n   * is in 3 PE stop state, otherwise `false`.\n   */\n  is3PEStop() {\n    return this.postAndObserve('is3PEStop');\n  }\n  /**\n   * Determines whether the robot is currently running.\n   *\n   * @returns {Observable<boolean>} An observable that emits `true` if the robot is running\n   * (`robotMode === RUNNING`), otherwise `false`.\n   */\n  isRobotRunning() {\n    return this.postAndObserve('isRobotRunning');\n  }\n}\nconst FREEDRIVE_STATE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.FreedriveStateService.';\n/**\n * Provides access to freedrive information on the robot\n */\nclass FreedriveService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(FREEDRIVE_STATE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Get the freedrive state\n   *\n   * @returns {Observable<boolean>} An observable that emits `true` if the robot is in freedrive state\n   */\n  isInFreedrive() {\n    return this.postAndObserve('isInFreedrive');\n  }\n}\nconst PROGRAM_TREE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramTreeService.';\n/**\n * Service that handles node insertion and removal of nodes\n */\nclass ProgramTreeService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(PROGRAM_TREE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Update a specific node in the program tree using the given nodes id\n   * @param node Node to be updated\n   */\n  updateSubTreeNode(node) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      return _this26.postAndAwait('updateSubTreeNode', {\n        node: node.node,\n        id: node.id\n      });\n    })();\n  }\n  /**\n   * Update child node\n   * @param node Child node to be updated\n   * @deprecated Use {@link updateSubTreeNode} instead\n   */\n  updateChildNode(node) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      return _this27.postAndAwait('updateChildNode', node);\n    })();\n  }\n  /**\n   * Add node as either child or sibling\n   * @param node node to be added\n   */\n  addNode(node) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      return _this28.postAndAwait('addNode', node);\n    })();\n  }\n  /**\n   * Add a node to the root of a program block, for example the main program or\n   * the before start\n   * @param The node, and other add parameters\n   */\n  addBlockChildNode(node) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      return _this29.postAndAwait('addBlockChildNode', node);\n    })();\n  }\n  /**\n   * Remove child node\n   * @param node Child node to be removed\n   */\n  removeChildNode(node) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      return _this30.postAndAwait('removeChildNode', node);\n    })();\n  }\n  /**\n   * Sets the given node as the active program block\n   * @param nodeID The node to navigate to\n   */\n  setActiveProgramBlock(nodeID) {\n    return this.postAndAwait('setActiveProgramBlock', nodeID);\n  }\n  /**\n   * Sets the given node as the active program block\n   * @param nodeID The node to navigate to\n   */\n  selectProgramNode(nodeID) {\n    return this.postAndAwait('selectProgramNode', nodeID);\n  }\n  /**\n   * Get a readonly version of a given node\n   * @param nodeID The node to get\n   */\n  getProgramNodeById(nodeID) {\n    return this.postAndAwait('getProgramNodeById', nodeID);\n  }\n  /**\n   * Get the tree context from a given program node\n   */\n  getTreeContextFromProgramNodeById(subTreeNodeId) {\n    return this.postAndAwait('getTreeContextFromProgramNodeById', {\n      subTreeNodeId\n    });\n  }\n  /**\n   * Get the subtree context from a given program node.\n   * This returns the same traversals as getTreeContextFromProgramNodeById but will\n   * return a SubtreeNode for ancestor and sibling calls.\n   * For ancestor and sibling calls, where a SubtreeNode is not from the calling URCap,\n   * then the SubtreeNode id will be ''.\n   */\n  getSubtreeContextFromProgramNodeById(subTreeNodeId) {\n    return this.postAndAwait('getTreeContextFromProgramNodeById', {\n      subTreeNodeId\n    });\n  }\n  /**\n   * Get the contributed node instances for the URCap that are currently inserted in the program\n   */\n  getContributedNodeInstancesForURCap() {\n    return this.postAndAwait('getContributedNodeInstancesForURCap');\n  }\n}\nconst SETTINGS_MESSAGE_TYPE_BASE = 'ur.web.message.SettingsService.';\n/**\n * A service for getting settings such as language and units\n */\nclass SettingsService extends MessageInvokerService {\n  /**\n   *\n   */\n  constructor(eventTarget) {\n    super(SETTINGS_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Get the current robot settings as an observable\n   */\n  getRobotSettings() {\n    return this.postAndObserve('getRobotSettings');\n  }\n  /**\n   * Get the current robot settings once\n   */\n  getRobotSettingsOnce() {\n    return this.postAndAwait('getRobotSettingsOnce');\n  }\n}\nconst PROGRAM_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ProgramService.';\n/**\n * Service for handling program related operations\n */\nclass ProgramService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(PROGRAM_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Will get information and metadata of all programs\n   * @returns Promise<Array<ProgramInformation>>\n   */\n  getProgramsList() {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      return _this31.postAndAwait('getProgramsList');\n    })();\n  }\n  /**\n   * Get a program\n   * @param programInformation\n   * @returns Promise<Program>\n   */\n  getProgram(programInformation) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      return _this32.postAndAwait('getProgram', {\n        programInformation\n      });\n    })();\n  }\n  /**\n   * Load program\n   * @param programId The id of the program to load\n   * @see {@link getPrograms} for getting the ids\n   */\n  loadProgram({\n    programId\n  }) {\n    return this.postAndAwait('loadProgram', {\n      programId\n    });\n  }\n  /**\n   * Retrieves the loaded program's information.\n   *\n   * This method sends a request to the backend to retrieve the information of the currently loaded program.\n   *\n   * @returns {Promise<ProgramInformation>} A promise that resolves to the information of the loaded program.\n   *\n   * @example\n   * // Usage example\n   * const programInfo = await this.presenterAPI.programService.getLoadedProgram()\n   * console.log('Loaded Program Information:', programInfo);\n   *\n   */\n  getLoadedProgram() {\n    return this.postAndAwait('getLoadedProgram');\n  }\n}\nconst SMART_SKILL_EXECUTION_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SmartSkillExecutionService.';\n/**\n * Service that handles executing smart skill instances\n */\nclass SmartSkillExecutionService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SMART_SKILL_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Execute the smart skill instance\n   * @param instance Smart skill instance to execute\n   */\n  executeInstance(instance) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      return _this33.postAndAwait('executeInstance', {\n        instance\n      });\n    })();\n  }\n  /**\n   * Stop the smart skill instance\n   * @param instance Smart skill instance to stop\n   */\n  stopInstance(instance) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      return _this34.postAndAwait('stopInstance', {\n        instance\n      });\n    })();\n  }\n  /**\n   * Get active smart skill observable\n   */\n  activeSmartSkill() {\n    return this.postAndObserve('getActiveSmartSkillObservable', {});\n  }\n  /**\n   * Will be false if 3PE is disengaged, robot is powered off or Freedrive is enabled.\n   */\n  executionAllowed() {\n    return this.postAndObserve('getExecutionAllowedObservable', {});\n  }\n  /**\n   * Wait for the active smart skill to stop\n   */\n  waitForActiveSmartSkillToStop(timeoutMs) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      const timeoutPromise = new Promise((_, reject) => {\n        if (timeoutMs !== undefined) {\n          setTimeout(() => reject(new Error('Timeout waiting for active smart skill to stop')), timeoutMs);\n        }\n      });\n      const waitForSkillToStop = new Promise(resolve => {\n        _this35.activeSmartSkill().pipe(filter(skill => skill === undefined), take(1)).subscribe(() => resolve());\n      });\n      return Promise.race([waitForSkillToStop, timeoutPromise]);\n    })();\n  }\n}\nconst SYSTEM_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.SystemService.';\n/**\n * Service that handles system information.\n */\nclass SystemService extends MessageInvokerService {\n  /**\n   * Create a service for the specific worker\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SYSTEM_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Get the software version.\n   * @returns The software version.\n   */\n  getSoftwareVersion() {\n    return this.postAndAwait('getSoftwareVersion');\n  }\n}\nconst MOTION_PROFILES_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.MotionProfilesService.';\n/**\n * Service for getting information of motion profiles\n */\nclass MotionProfilesService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(MOTION_PROFILES_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Returns the data stored on the specified Motion Profiles type\n   * @param type the type of the Motion Profiles to fetch:\n   * - joint\n   * - linear\n   * - process\n   */\n  getMotionProfiles(type) {\n    return this.postAndAwait('getMotionProfiles', {\n      type\n    });\n  }\n}\nconst TEACH_MODE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.TeachModeService.';\n/**\n * Service that handles teach mode for generating program nodes.\n */\nclass TeachModeService extends MessageInvokerService {\n  /**\n   * Creates an instance of TeachModeService.\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(TEACH_MODE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Starts a teach mode session.\n   */\n  startTeachMode() {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      return _this36.postAndAwait('startTeachMode', {});\n    })();\n  }\n  /**\n   * Stops the current teach mode session.\n   */\n  stopTeachMode() {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      return _this37.postAndAwait('stopTeachMode', {});\n    })();\n  }\n  /**\n   * Pauses the current teach mode session.\n   */\n  pauseTeachMode() {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      return _this38.postAndAwait('pauseTeachMode', {});\n    })();\n  }\n  /**\n   * Pauses the current teach mode session.\n   */\n  resumeTeachMode() {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      return _this39.postAndAwait('resumeTeachMode', {});\n    })();\n  }\n  /**\n   * Retrieves the current state of the teach mode session.\n   * @returns An Observable with the current state of the teach mode session.\n   */\n  getTeachModeState() {\n    return this.postAndObserve('getTeachModeState', {});\n  }\n}\nconst APPLICATION_VARIABLES_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ApplicationVariablesService.';\n/**\n * Service for managing application variables.\n */\nclass ApplicationVariablesService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(APPLICATION_VARIABLES_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Retrieves all application variables as an observable.\n   * @experimental\n   * @returns An observable that emits a record of application variables.\n   */\n  applicationVariables() {\n    return this.postAndObserve('applicationVariables');\n  }\n  /**\n   * Sends request to initialize variables in controller and store.\n   * @experimental\n   * @param variableMap - A record mapping variable names to ApplicationVariable objects.\n   */\n  initializeVariables(variables) {\n    return this.postAndAwait('initializeVariables', variables);\n  }\n  /**\n   * Sends request to clean up variables in controller.\n   * @experimental\n   * @param variables - A record mapping variable names to ApplicationVariable objects.\n   */\n  cleanUpControllerVariables() {\n    return this.postAndAwait('cleanUpControllerVariables');\n  }\n  /**\n   * Sends request to set value of an existing variable.\n   * @experimental\n   * @param variable - The ApplicationVariable object to create.\n   */\n  setVariable(variable) {\n    return this.postAndAwait('setVariable', variable);\n  }\n  /**\n   * Sends request to create a new variable.\n   * @experimental\n   * @param variable - The ApplicationVariable object to create.\n   */\n  createVariable(variable) {\n    return this.postAndAwait('createVariable', variable);\n  }\n  /**\n   * Sends request to delete an existing variable.\n   * @experimental\n   * @param variableName - The name of the variable to delete.\n   */\n  deleteVariable(variableName) {\n    return this.postAndAwait('deleteVariable', variableName);\n  }\n}\nconst SCRIPT_FILE_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ScriptFileService.';\n/**\n * Service for getting script files\n */\nclass ScriptFileService extends MessageInvokerService {\n  /**\n   * @constructor\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(SCRIPT_FILE_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Returns the script files that are available. This will not contain the urscript content\n   */\n  getScriptFiles() {\n    return this.postAndAwait('getScriptFiles');\n  }\n  /**\n   * Returns a script file for a given name, including the urscript content\n   * @param name\n   */\n  getScriptFile(name) {\n    return this.postAndAwait('getScriptFile', name);\n  }\n}\nconst EXPRESSION_EDITOR_SERVICE_MESSAGE_TYPE_BASE = 'ur.web.message.ExpressionEditorService.';\n/**\n * Service that handles editing expressions\n */\nclass ExpressionEditorService extends MessageInvokerService {\n  /**\n   * Create a service for the specific eventTarget\n   * @param eventTarget\n   */\n  constructor(eventTarget) {\n    super(EXPRESSION_EDITOR_SERVICE_MESSAGE_TYPE_BASE, eventTarget);\n    this.eventTarget = eventTarget;\n  }\n  /**\n   * Returns content that can be inserted on the expression tab of the tab input\n   * @returns Arrays of the different types of insertables, eg inputs, outputs, built in\n   * functions\n   */\n  getTabInputInsertableModel() {\n    return this.postAndAwait('getTabInputInsertableModel');\n  }\n}\n\n/**\n * Enum for HistoryPolicy\n * @readonly\n * @enum {number}\n */\nvar HistoryPolicy = /*#__PURE__*/function (HistoryPolicy) {\n  HistoryPolicy[HistoryPolicy[\"SYSTEM_DEFAULT\"] = 0] = \"SYSTEM_DEFAULT\";\n  HistoryPolicy[HistoryPolicy[\"KEEP_LAST\"] = 1] = \"KEEP_LAST\";\n  HistoryPolicy[HistoryPolicy[\"KEEP_ALL\"] = 2] = \"KEEP_ALL\";\n  HistoryPolicy[HistoryPolicy[\"UNKNOWN\"] = 3] = \"UNKNOWN\";\n  return HistoryPolicy;\n}(HistoryPolicy || {});\n/**\n * Enum for ReliabilityPolicy\n * @readonly\n * @enum {number}\n */\nvar ReliabilityPolicy = /*#__PURE__*/function (ReliabilityPolicy) {\n  ReliabilityPolicy[ReliabilityPolicy[\"SYSTEM_DEFAULT\"] = 0] = \"SYSTEM_DEFAULT\";\n  ReliabilityPolicy[ReliabilityPolicy[\"RELIABLE\"] = 1] = \"RELIABLE\";\n  ReliabilityPolicy[ReliabilityPolicy[\"BEST_EFFORT\"] = 2] = \"BEST_EFFORT\";\n  ReliabilityPolicy[ReliabilityPolicy[\"UNKNOWN\"] = 3] = \"UNKNOWN\";\n  return ReliabilityPolicy;\n}(ReliabilityPolicy || {});\n/**\n * Enum for DurabilityPolicy\n * @readonly\n * @enum {number}\n */\nvar DurabilityPolicy = /*#__PURE__*/function (DurabilityPolicy) {\n  DurabilityPolicy[DurabilityPolicy[\"SYSTEM_DEFAULT\"] = 0] = \"SYSTEM_DEFAULT\";\n  DurabilityPolicy[DurabilityPolicy[\"TRANSIENT_LOCAL\"] = 1] = \"TRANSIENT_LOCAL\";\n  DurabilityPolicy[DurabilityPolicy[\"VOLATILE\"] = 2] = \"VOLATILE\";\n  DurabilityPolicy[DurabilityPolicy[\"UNKNOWN\"] = 3] = \"UNKNOWN\";\n  return DurabilityPolicy;\n}(DurabilityPolicy || {});\n/**\n * QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.\n * For a subscriber, these are its requirements for its topic's publishers.\n * @readonly\n * @enum {number}\n */\nvar LivelinessPolicy = /*#__PURE__*/function (LivelinessPolicy) {\n  LivelinessPolicy[LivelinessPolicy[\"SYSTEM_DEFAULT\"] = 0] = \"SYSTEM_DEFAULT\";\n  LivelinessPolicy[LivelinessPolicy[\"AUTOMATIC\"] = 1] = \"AUTOMATIC\";\n  LivelinessPolicy[LivelinessPolicy[\"MANUAL_BY_NODE\"] = 2] = \"MANUAL_BY_NODE\";\n  LivelinessPolicy[LivelinessPolicy[\"MANUAL_BY_TOPIC\"] = 3] = \"MANUAL_BY_TOPIC\";\n  LivelinessPolicy[LivelinessPolicy[\"UNKNOWN\"] = 4] = \"UNKNOWN\";\n  return LivelinessPolicy;\n}(LivelinessPolicy || {});\n/**\n * The quality of service profile for ROS2 communication.\n * @dynamic\n */\nlet QoSProfile = /*#__PURE__*/(() => {\n  class QoSProfile {\n    /**\n     * Get HistoryPolicy enum.\n     * @return HistoryPolicy\n     */\n    static {\n      this.HistoryPolicy = HistoryPolicy;\n    }\n    /**\n     * Get ReliabilityPolicy enum.\n     * @return ReliabilityPolicy\n     */\n    static {\n      this.ReliabilityPolicy = ReliabilityPolicy;\n    }\n    /**\n     * Get DurabilityPolicy enum.\n     * @return DurabilityPolicy\n     */\n    static {\n      this.DurabilityPolicy = DurabilityPolicy;\n    }\n    /**\n     * Get LivelinessPolicy enum\n     * @return LivelinessPolicy\n     */\n    static {\n      this.LivelinessPolicy = LivelinessPolicy;\n    }\n    /**\n     * Default duration is duration unspecified\n     */\n    static get DurationUnspecified() {\n      return {\n        seconds: 0,\n        nanoseconds: 0\n      };\n    }\n    /**\n     * Default duration is duration unspecified\n     */\n    static get DurationInfinite() {\n      return {\n        seconds: 9223372036,\n        nanoseconds: 854775807\n      };\n    }\n    /**\n     * Get default profile. Default values are:\n     *     HistoryPolicy = KEEP_LAST,\n     *     depth = 10,\n     *     ReliabilityPolicy = RELIABLE,\n     *     DurabilityPolicy = VOLATILE,\n     *     deadline = QoSProfile.DurationUnspecified,\n     *     lifespan = QoSProfile.DurationUnspecified,\n     *     LivelinessPolicy = SYSTEM_DEFAULT,\n     *     liveliness_lease_duration = QoSProfile.DurationUnspecified,\n     *     avoid_ros_namespace_conventions = false\n     * @return QoSProfile\n     */\n    static get default() {\n      return new QoSProfile(HistoryPolicy.KEEP_LAST, 10, ReliabilityPolicy.RELIABLE, DurabilityPolicy.VOLATILE, QoSProfile.DurationUnspecified, QoSProfile.DurationUnspecified, LivelinessPolicy.SYSTEM_DEFAULT, QoSProfile.DurationUnspecified, false);\n    }\n    /**\n     * Get most compatible QoS profile with Reliability set to BEST_EFFORT. Values are:\n     *     HistoryPolicy = KEEP_LAST,\n     *     depth = 10,\n     *     ReliabilityPolicy = BEST_EFFORT,\n     *     DurabilityPolicy = VOLATILE,\n     *     deadline = QoSProfile.DurationUnspecified,\n     *     lifespan = QoSProfile.DurationUnspecified,\n     *     LivelinessPolicy = SYSTEM_DEFAULT,\n     *     liveliness_lease_duration = QoSProfile.DurationUnspecified,\n     *     avoid_ros_namespace_conventions = false\n     * @return QoSProfile\n     */\n    static get compatible() {\n      return new QoSProfile(HistoryPolicy.KEEP_LAST, 10, ReliabilityPolicy.BEST_EFFORT, DurabilityPolicy.VOLATILE, QoSProfile.DurationUnspecified, QoSProfile.DurationUnspecified, LivelinessPolicy.SYSTEM_DEFAULT, QoSProfile.DurationUnspecified, false);\n    }\n    /**\n     * Create a QosProfile for ROS2 communication.\n     * @param history HistoryPolicy The history value, default value is HistoryPolicy.KEEP_LAST.\n     * @param depth number The depth value, default value is depth=10.\n     * @param reliability ReliabilityPolicy The reliability value, default value is ReliabilityPolicy.RELIABLE.\n     * @param durability DurabilityPolicy The durability value, default value is DurabilityPolicy.VOLATILE.\n     * @param deadline The deadline value, default value is DurationUnspecified.\n     * @param lifespan The lifespan value, default value is DurationUnspecified.\n     * @param liveliness LivelinessPolicy The liveliness value, default value is LivelinessPolicy.SYSTEM_DEFAULT.\n     * @param liveliness_lease_duration The liveliness_lease_duration value, default values is DurationUnspecified.\n     * @param avoid_ros_namespace_conventions The avoid_ros_namespace_conventions value, default value=false.\n     */\n    constructor(history = HistoryPolicy.KEEP_LAST, depth = 10, reliability = ReliabilityPolicy.RELIABLE, durability = DurabilityPolicy.VOLATILE, deadline = QoSProfile.DurationUnspecified, lifespan = QoSProfile.DurationUnspecified, liveliness = LivelinessPolicy.SYSTEM_DEFAULT, liveliness_lease_duration = QoSProfile.DurationUnspecified, avoid_ros_namespace_conventions = false) {\n      this.history = history;\n      this.depth = depth;\n      this.reliability = reliability;\n      this.durability = durability;\n      this.deadline = deadline;\n      this.lifespan = lifespan;\n      this.liveliness = liveliness;\n      this.liveliness_lease_duration = liveliness_lease_duration;\n      this.avoid_ros_namespace_conventions = avoid_ros_namespace_conventions;\n    }\n  }\n  return QoSProfile;\n})();\n/**\n * Check if message is an exception, throw error if exception\n * @param msg message to check\n */\nconst assertNotException = msg => {\n  if (isException(msg)) {\n    throw new Error(msg.exception);\n  }\n};\n/**\n * Check if message is an exception\n * @param msg\n * @private\n * @return boolean true if exception\n */\nfunction isException(msg) {\n  return msg.exception !== undefined && msg.message !== undefined;\n}\n/**\n * The UR TypeScript API for ROS 2\n */\nclass Ros2Client {\n  /**\n   * Get Id for connection\n   * @return Id for connection\n   * @private\n   */\n  getConnectionId() {\n    return Guid.create().toString();\n  }\n  /**\n   * Create Ros2Client ROS2 client for UR ROS2 Web Bridge\n   * @constructor\n   * @param ros2Service Ros2 service for ROS2 communication\n   */\n  constructor(ros2Service) {\n    this.ros2Service = ros2Service;\n  }\n  /**\n   * Get topic path to be used for ROS2 communication, including optional robot namespace and custom namespace.\n   * @param prependRobotNamespace boolean if true then local ROS2 robot namespace will be prepended to topic.\n   * @param topic string to be used for ROS2 communication.\n   * @param namespace optional namespaces to prepend topic.\n   * @return TopicPath extending Promise<string>\n   */\n  getTopicPath(prependRobotNamespace, topic, ...namespace) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this40.getPath(prependRobotNamespace, topic, namespace);\n    })();\n  }\n  /**\n   * Get service path to be used for ROS2 communication, including optional robot namespace and custom namespace.\n   * @param prependRobotNamespace boolean if true then local ROS2 robot namespace will be prepended to service name.\n   * @param serviceName string to be used for ROS2 communication.\n   * @param namespace optional namespaces to prepend service name.\n   * @return ServicePath extending Promise<string>\n   */\n  getServicePath(prependRobotNamespace, serviceName, ...namespace) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this41.getPath(prependRobotNamespace, serviceName, namespace);\n    })();\n  }\n  /**\n   * Get promise path\n   * @param prependRobotNamespace\n   * @param topicOrMessageName\n   * @param namespace\n   * @return Promise<String>\n   * @private\n   */\n  getPath(prependRobotNamespace, topicOrMessageName, namespace) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      let localNamespace = namespace.length > 0 ? namespace.join('/').replace(/^\\/?/, '').replace(/\\/?$/, '') : '';\n      localNamespace = localNamespace.length > 0 ? `/${localNamespace}/` : '';\n      if (prependRobotNamespace) {\n        const ros2Namespace = yield _this42.getRobotNamespace();\n        let rosNamespacePath = ros2Namespace?.length > 0 ? ros2Namespace.replace(/^\\/?/, '/').replace(/\\/?$/, '') : '';\n        rosNamespacePath = rosNamespacePath.length > 0 && localNamespace.length === 0 ? rosNamespacePath + '/' : rosNamespacePath;\n        return rosNamespacePath + localNamespace + topicOrMessageName;\n      }\n      return localNamespace + topicOrMessageName;\n    })();\n  }\n  /**\n   * Get RobotNamespace\n   * @private\n   */\n  getRobotNamespace() {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this43.robotNamespace) {\n        _this43.robotNamespace = yield _this43.ros2Service.getRos2Namespace();\n      }\n      return _this43.robotNamespace;\n    })();\n  }\n  /**\n   * Create a new subscription to a ROS2 topic.\n   * @param messageType The type of ROS messages the subscription will subscribe to.\n   * @param topicPath TopicPath The name of the topic the subscription will subscribe to, may include ros2 namespace.\n   * @param qosProfile optional quality of service profile to apply to the subscription. Default is QoSProfile.default.\n   * @return Observable to subscribe to\n   */\n  createSubscription(messageType, topicPath, qosProfile = QoSProfile.default) {\n    const connectionId = this.getConnectionId();\n    return this.ros2Service.subscribe(connectionId, messageType, topicPath, qosProfile).pipe(tap(assertNotException), map$1(rt => rt.msg));\n  }\n  /**\n   * Create a new subscription for frame transformation\n   * @param targetFrame\n   * @param sourceFrame\n   * @return Observable to subscribe to\n   * @deprecated Use framesService.observeFrames and convertPose instead.\n   */\n  createTransformSubscription(targetFrame, sourceFrame) {\n    const connectionId = this.getConnectionId();\n    return this.ros2Service.subscribeTransform(connectionId, targetFrame, sourceFrame).pipe(tap(assertNotException), switchMap(rt => {\n      if (rt.msg?.error) {\n        return throwError(() => new Error(rt.msg.error));\n      }\n      return of(rt);\n    }), map$1(rt => rt.msg));\n  }\n  /**\n   * Make a ROS2 service call for setting argumentValues on a service, and return an observable of type T.\n   * @param serviceType The type of ROS service to set argumentValues on.\n   * @param servicePath ServicePath The name of the service to set argumentValues on, may include namespace.\n   * @param argumentValues Values to be set.\n   * @param qosProfile optional quality of service profile to apply to the service client. Default is QoSProfile.default.\n   * @param timeout optional float value in seconds, default is 30.0 seconds before timeout.\n   * @return The first message returned from the service call.\n   */\n  callService(_x, _x2, _x3) {\n    var _this44 = this;\n    return _asyncToGenerator(function* (serviceType, servicePath, argumentValues, qosProfile = QoSProfile.default, timeout = 30.0) {\n      const connectionId = _this44.getConnectionId();\n      return yield firstValueFrom(_this44.ros2Service.callService(connectionId, serviceType, servicePath, argumentValues, qosProfile, timeout).pipe(tap(assertNotException), map$1(rt => rt.msg)));\n    }).apply(this, arguments);\n  }\n}\nconst ROS2_MESSAGE_TYPE_BASE = 'ur.web.message.Ros2Service.';\n/**\n * Service for ROS2 communication\n * Uses event based messaging for communication\n */\nclass Ros2EventService extends MessageInvokerService {\n  /**\n   * Create event based messaging implementation of the Ros2ServiceApi for ROS2 communication\n   * @param target Either a Worker to be used as the EventTarget or a standard\n   */\n  constructor(target) {\n    super(ROS2_MESSAGE_TYPE_BASE, target);\n    this.target = target;\n  }\n  /**\n   * Get local ROS2 robot namespace\n   * @return Promise containing local ROS2 robot namespace\n   */\n  getRos2Namespace() {\n    return this.postAndAwait('getRos2Namespace', {});\n  }\n  /**\n   * Subscribe to topicPath with given message type using QoS profile\n   * @param connectionId Id for subscription\n   * @param messageType\n   * @param topic\n   * @param qosProfile optional quality of service profile to apply to the subscription. Default is QoSProfile.default.\n   * @return Observable to subscribe to\n   */\n  subscribe(connectionId, messageType, topic, qosProfile = QoSProfile.default) {\n    return this.postAndObserve('subscribe', {\n      connectionId,\n      messageType,\n      topic,\n      qosProfile\n    });\n  }\n  /**\n   * Subscribe to frame transformation\n   * @param connectionId Id for subscription\n   * @param targetFrame\n   * @param sourceFrame\n   * @param publishRate in milliseconds\n   * @return Observable to subscribe to\n   */\n  subscribeTransform(connectionId, targetFrame, sourceFrame, publishRate = 100) {\n    return this.postAndObserve('subscribeTransform', {\n      connectionId,\n      targetFrame,\n      sourceFrame,\n      publishRate\n    });\n  }\n  /**\n   * Call service to set argumentValues of service type on service name\n   * @param connectionId Id for subscription\n   * @param serviceType\n   * @param serviceName\n   * @param argumentValues\n   * @param qosProfile optional quality of service profile to apply to the service client. Default is QoSProfile.default.\n   * @param timeout optional float value in seconds, default is 30.0 seconds before timeout.\n   * @return Promise with value\n   */\n  callService(connectionId, serviceType, serviceName, argumentValues, qosProfile = QoSProfile.default, timeout = 30.0) {\n    return this.postAndObserve('callService', {\n      connectionId,\n      serviceType,\n      serviceName,\n      argumentValues,\n      qosProfile,\n      timeout\n    });\n  }\n}\n\n/**\n * Provides access to common related API features in both BehaviorWorkers\n * and Presenters\n */\nclass CommonBehaviorAPI {\n  /** Creates a new instance of the CommonAPI based on either a Worker\n   * or an instance of an EventTarget, to allow communication with the\n   * surrounding apis from within the Worker or WebComponent\n   *\n   * @param target Either a Worker to be used as the EventTarget or a standard\n   * EventTarget\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new WorkerCommunicationChannel(target);\n    }\n    this.applicationService = new ApplicationService(communicationChannel);\n    this.logMessageService = new LogMessageService(communicationChannel);\n    this.logPerformanceService = new LogPerformanceService(communicationChannel);\n    this.ros2Client = new Ros2Client(new Ros2EventService(communicationChannel));\n    this.safetyService = new SafetyService(communicationChannel);\n    this.sourceService = new SourceService(communicationChannel);\n    this.robotPositionService = new RobotPositionService(communicationChannel);\n    this.symbolService = new SymbolService(communicationChannel);\n    this.robotInfoService = new RobotInfoService(communicationChannel);\n    this.programTreeService = new ProgramTreeService(communicationChannel);\n    this.settingsService = new SettingsService(communicationChannel);\n    this.systemService = new SystemService(communicationChannel);\n    this.dialogService = new DialogService(communicationChannel);\n    this.expressionEditorService = new ExpressionEditorService(communicationChannel);\n  }\n  /**\n   * Creates a URL string for communicating with backend Container Contributions\n   * A protocol must be prepended to the string, like 'http://' or 'ws://'\n   * @param vendorID Id of Vendor as specified in manifest.yaml file\n   * @param urcapID Id of URCap as specified in manifest.yaml file\n   * @param containerName Name of Container as specified in manifest.yaml file\n   * @param serviceName Name of Service as specified by Ingress name in manifest.yaml file\n   * @return URL string without protocol.\n   */\n  getContainerContributionURL(vendorID, urcapID, containerName, serviceName) {\n    return `${location.host}/${vendorID}/${urcapID}/${containerName}/${serviceName}`;\n  }\n}\n/**\n * Provides access to common related API features in Presenters\n */\nclass CommonPresenterAPI extends CommonBehaviorAPI {\n  /** Creates a new instance of the CommonAPI based on an instance of an EventTarget,\n   * to allow communication with the\n   * surrounding apis from within the Worker or WebComponent\n   *\n   * @param target An EventTarget\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.snackbarService = new SnackbarService(communicationChannel);\n    this.programService = new ProgramService(communicationChannel);\n  }\n}\n\n/**\n * Provides access to Application related API features in ApplicationBehaviors\n */\nclass ApplicationBehaviorAPI extends CommonBehaviorAPI {\n  /** Creates a new instance of the ApplicationBehaviorAPI to allow communication with the\n   * surrounding application from within a WebWorker\n   *\n   * @param target A worker, provided with 'self' when created inside a web worker\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new WorkerCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.toolService = new ToolService(communicationChannel);\n    this.mountingService = new MountingService(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n    this.applicationVariablesService = new ApplicationVariablesService(communicationChannel);\n  }\n}\n/**\n * Provides access to Application related API features in ApplicationPresenters\n */\nclass ApplicationPresenterAPI extends CommonPresenterAPI {\n  /** Creates a new instance of the ApplicationPresenterAPI, to allow communication with the\n   * surrounding application from within a WebComponent\n   *\n   * @param target An EventTarget, provided by PolyScope X\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.applicationNodeService = new ApplicationNodeService(communicationChannel);\n    this.applicationVariablesService = new ApplicationVariablesService(communicationChannel);\n    this.robotMoveService = new RobotMoveService(communicationChannel);\n    this.programExecutionService = new ProgramExecutionService(communicationChannel);\n    this.toolService = new ToolService(communicationChannel);\n    this.mountingService = new MountingService(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n  }\n}\n\n/**\n * Provides access to Program related API features in both BehaviorWorkers\n * and ProgramPresenters\n */\nclass ProgramBehaviorAPI extends CommonBehaviorAPI {\n  /** Creates a new instance of the ProgramBehaviorAPI to allow communication with the\n   * surrounding application from within a WebWorker\n   *\n   * @param target A worker, provided with 'self' when created inside a web worker\n   */\n  constructor(target) {\n    const communicationChannel = createWorkerCommChannel(target);\n    super(communicationChannel);\n    this.builder = new TreeBuilder(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n    this.motionProfilesService = new MotionProfilesService(communicationChannel);\n    this.scriptFileService = new ScriptFileService(communicationChannel);\n  }\n}\n/**\n * ProgramPresenterAPI\n */\nclass ProgramPresenterAPI extends CommonPresenterAPI {\n  /** Creates a new instance of the ProgramPresenterAPI, to allow communication with the\n   * surrounding application from within a WebComponent\n   *\n   * @param target An EventTarget, provided by PolyScope X\n   * @param selectedNodeId the id of the currently selected program node\n   */\n  constructor(target, selectedNodeId) {\n    const communicationChannel = createEventTargetCommChannel(target);\n    super(communicationChannel);\n    this.selectedNodeId = selectedNodeId;\n    this.programNodeService = new ProgramNodeService(communicationChannel, selectedNodeId);\n    this.robotMoveService = new RobotMoveService(communicationChannel);\n    this.validationService = new ValidationService(communicationChannel, selectedNodeId);\n    this.builder = new TreeBuilder(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n    this.motionProfilesService = new MotionProfilesService(communicationChannel);\n    this.scriptFileService = new ScriptFileService(communicationChannel);\n  }\n}\n\n/**\n * Provides access to source related API features in Source Behaviors\n */\nclass SourceBehaviorAPI extends CommonBehaviorAPI {\n  /** Creates a new instance of the SourceBehaviorAPI to allow communication with the\n   * surrounding application from within a WebWorker\n   *\n   * @param target A worker, provided with 'self' when created inside a web worker\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new WorkerCommunicationChannel(target);\n    }\n    super(communicationChannel);\n  }\n}\n/**\n * Provides access to source related API features in Source Presenters\n */\nclass SourcePresenterAPI extends CommonPresenterAPI {\n  /** Creates a new instance of the SourcePresenterAPI, to allow communication with the\n   * surrounding application from within a WebComponent\n   *\n   * @param target An EventTarget, provided by PolyScope X\n   * @param sourceID ID for this source\n   */\n  constructor(target, sourceID) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.sourceID = sourceID;\n    this.signalService = new SignalService(communicationChannel, sourceID);\n    this.sourceNodeService = new SourceNodeService(communicationChannel);\n  }\n}\n\n/**\n * Provides access to Smart Skills related API features in BehaviorWorkers\n */\nclass SmartSkillsBehaviorAPI extends CommonBehaviorAPI {\n  /** Creates a new instance of the SmartSkillsBehaviorAPI to allow communication with the\n   * surrounding application from within a WebWorker\n   *\n   * @param target A worker, provided with 'self' when created inside a web worker\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new WorkerCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.builder = new TreeBuilder(communicationChannel);\n    this.programCode = new ProgramCodeService(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n  }\n}\n/**\n *\n */\nclass SmartSkillsPresenterAPI extends CommonPresenterAPI {\n  /**\n   * Create a new instance of the SmartSkillsPresenterAPI to allow a Presenter to interact with the API and update itself\n   */\n  constructor(target, name) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.smartSkillInstanceService = new SmartSkillInstanceService(communicationChannel);\n    this.robotMoveService = new RobotMoveService(communicationChannel);\n    this.freedriveService = new FreedriveService(communicationChannel);\n  }\n}\n\n/**\n * Checks that the message coming is in a SerializableApplicationContext\n * @param message The message to serialize\n */\nfunction isSerializedApplicationContext(message) {\n  return message && message.type === '$$ApplicationContext';\n}\n/**\n * Creates the serializer for the ApplicationContext. Handles serializing and deserializing of the object.\n * @constructor\n */\nconst ApplicationContextSerializer = () => {\n  return {\n    /**\n     * deserialize the message using a given handler\n     * @param message\n     * @param defaultHandler\n     */\n    deserialize(message, defaultHandler) {\n      if (isSerializedApplicationContext(message)) {\n        // created the application context from the message\n        return {\n          contributions: {\n            contributionList: message.contributions?.contributionList ?? [],\n            /**\n             * Returns a Contribution node base on the param\n             * @param type String specifying the contribution node to fetch\n             */\n            getContribution(type) {\n              return this.contributionList.find(contribution => contribution.parentType === type);\n            }\n          },\n          frames: {\n            framesList: message.frames?.framesList ?? [],\n            /**\n             * Returns a Frame base on the param\n             * @param frameId String specifying the frame to fetch\n             */\n            getFrame(frameId) {\n              return this.framesList.find(frame => frame.name === frameId);\n            }\n          }\n        };\n      } else {\n        return defaultHandler(message);\n      }\n    },\n    /**\n     * serializing the item using a give handler\n     * @param item\n     * @param defaultHandler\n     */\n    serialize(item, defaultHandler) {\n      if (isSerializedApplicationContext(item)) {\n        return {\n          type: '$$ApplicationContext',\n          contributions: {\n            contributionList: item.contributions?.contributionList ?? []\n          },\n          frames: {\n            framesList: item.frames?.framesList ?? []\n          }\n        };\n      } else {\n        return defaultHandler(item);\n      }\n    }\n  };\n};\n\n/**\n * An asynchronous array iterator\n */\nclass AsyncArrayTraverser {\n  /**\n   * @param nodes the array of nodes to iterate\n   */\n  constructor(nodes) {\n    this.pointer = 0;\n    this.values = nodes;\n  }\n  /**\n   * provide the next element for the iterator\n   */\n  next() {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      if (_this45.pointer < _this45.values.length) {\n        const index = _this45.pointer;\n        _this45.pointer++;\n        return {\n          done: false,\n          value: _this45.values[index]\n        };\n      }\n      return {\n        done: true,\n        value: null\n      };\n    })();\n  }\n  /**\n   * returns the asynchronous iterator\n   */\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\n\n/**\n * Checks that the message coming is in a isSerializedInsertionContext\n * @param message\n */\nfunction isSerializedInsertionContext(message) {\n  return message && message.type === '$$InsertionContext';\n}\n/**\n * Creates the serializer for the InsertionContext. Handles serializing and deserializing of the object.\n * @constructor\n */\nconst InsertionContextSerializer = () => {\n  return {\n    /**\n     * Deserializes the message as a new InsertionContext based on the message inputs\n     * @param message Message containing the values to be parsed to the new InsertionContext\n     * @param defaultHandler The object to handle deserializing if not of type InsertionContext\n     */\n    deserialize(message, defaultHandler) {\n      if (isSerializedInsertionContext(message)) {\n        return {\n          traverse: {\n            ancestors: new AsyncArrayTraverser(message.ancestors ? message.ancestors : []),\n            nextSiblings: new AsyncArrayTraverser(message.nextSiblings ? message.nextSiblings : []),\n            previousSiblings: new AsyncArrayTraverser(message.previousSiblings ? message.previousSiblings : [])\n          }\n        };\n      } else {\n        return defaultHandler(message);\n      }\n    },\n    /**\n     * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning\n     * @param item The original item that will be serialized\n     * @param defaultHandler The object to handle serializing if not of type InsertionContext\n     */\n    serialize(item, defaultHandler) {\n      if (isSerializedInsertionContext(item)) {\n        return {\n          type: '$$InsertionContext',\n          ancestors: item.ancestors,\n          previousSiblings: item.previousSiblings,\n          nextSiblings: item.nextSiblings\n        };\n      } else {\n        return defaultHandler(item);\n      }\n    }\n  };\n};\n\n/**\n * Internal utility for overload implementation detail.\n */\nfunction isZUpRotationVectorRadians(pose) {\n  return 'zUpRotationVectorRadians' in pose;\n}\n/**\n * Internal utility for formatting POSE value for URScript.\n */\nfunction formatPoseValueForURScript(value) {\n  return `p[${value}]`;\n}\n/**\n * Internal utility for formatting BOOLEAN value for URScript.\n */\nfunction formatBooleanValueForURScript(value) {\n  const boolValue = typeof value === 'string' ? value.toLowerCase() === 'true' : Boolean(value);\n  return ScriptBuilder.getBooleanAsString(boolValue);\n}\n/**\n * Internal utility for formatting ARRAY value for URScript.\n */\nfunction formatArrayValueForURScript(value) {\n  return `[${value}]`;\n}\n/**\n * Internal utility for formatting STRING value for URScript.\n */\nfunction formatStringValueForURScript(value) {\n  return /^\"(.*)\"$/.test(value) ? value : `\"${value}\"`;\n}\n/**\n * Internal utility for formatting MATRIX value for URScript.\n */\nfunction formatMatrixValueForURScript(value) {\n  if (Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (typeof value === 'string' && value.startsWith('[') && value.endsWith(']')) {\n    return value;\n  }\n  return String(value);\n}\n/**\n *\n * ScriptBuilder provides methods to easily generate well indented UR script programmatically.\n * This class manages indentation automatically as the script is built step by step.\n * But,it does not guarantee perfect formatting as there is a possibility to pass badly formatted expressions, statements or scripts.\n *\n */\nlet ScriptBuilder = /*#__PURE__*/(() => {\n  class ScriptBuilder {\n    static {\n      this.SINGLE_INDENT = '  ';\n    }\n    static {\n      this.SINGLE_INDENT_LEVEL = 1;\n    }\n    /**\n     * Creates a new ScriptBuilder\n     *\n     * @param script If a script is specified, the new ScriptBuilder will be preloaded with that script\n     * @param initialIndent If an indent is specified, the ScriptBuilder will be initialized with that indent\n     */\n    constructor(script = '', initialIndent = 0) {\n      this.type = '$$ScriptBuilder';\n      this.script = '';\n      this.currentIndent = 0;\n      this.addStatements(script);\n      this.currentIndent = initialIndent;\n    }\n    /**\n     * Generate the String representation of a boolean.\n     *\n     * @param b The input boolean\n     * @return The String representation of the input\n     */\n    static getBooleanAsString(b) {\n      return b ? 'True' : 'False';\n    }\n    /**\n     * Return a String representing the URScript for negating an expression.\n     * @param expression The expression to be negated\n     * @return String representation of the negated expression.\n     */\n    /**\n     *\n     * @param expression The expression to be negated\n     */\n    static negate(expression) {\n      return `not (${expression})`;\n    }\n    /**\n     * Return a String representation of the input array.\n     * @param input the input array.\n     * @return String representation of the input array.\n     */\n    static formatArray(input) {\n      let stringElem;\n      let result;\n      result = '[';\n      input.forEach((elem, index) => {\n        if (typeof elem === 'boolean') {\n          stringElem = ScriptBuilder.getBooleanAsString(elem);\n        } else if (typeof elem === 'string') {\n          stringElem = `\"${elem}\"`;\n        } else {\n          stringElem = elem.toString();\n        }\n        result += stringElem;\n        if (index < input.length - 1) {\n          result += ', ';\n        }\n      });\n      return result + ']';\n    }\n    /**\n     * Converts a variable's value to a URScript-compatible literal string based on its declared type.\n     *\n     * Handles proper formatting for POSE, BOOLEAN, ARRAY, and STRING types to ensure valid URScript syntax.\n     * - Strings like \"true\"/\"false\" are parsed to booleans when the variable type is BOOLEAN.\n     * - Arrays passed as comma-separated strings or raw arrays are parsed and validated for homogeneity.\n     * - POSE values are returned as-is within a `p[...]` wrapper, assuming correct formatting.\n     * - Returns an empty string `''` for invalid or mixed-type array inputs, or if the variable type is missing.\n     *\n     * @param variable The URVariable object containing the variable's metadata.\n     * @param value The value to be converted. Typically a string, but may also be a boolean, number, or array.\n     * @returns The value formatted as a URScript-compatible literal string.\n     */\n    static formatVariableToURScriptLiteral(variable, value) {\n      if (!variable || variable.valueType === undefined) {\n        return '';\n      }\n      switch (variable.valueType) {\n        case VariableValueType.POSE:\n          return formatPoseValueForURScript(value);\n        case VariableValueType.BOOLEAN:\n          return formatBooleanValueForURScript(value);\n        case VariableValueType.ARRAY:\n          return formatArrayValueForURScript(value);\n        case VariableValueType.STRING:\n          return formatStringValueForURScript(value);\n        case VariableValueType.MATRIX:\n          return formatMatrixValueForURScript(value);\n        default:\n          return String(value);\n      }\n    }\n    /**\n     * Create a ScriptBuilder preloaded with the incognito program definition.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} before\n     * calling {@link #getScript()}.\n     *\n     * @return new ScriptBuilder.\n     */\n    static CreateInkognitoProgram() {\n      return new ScriptBuilder().defineFunction('inkognito');\n    }\n    /**\n     * Create a ScriptBuilder preloaded with a secondary program definition.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} before\n     * calling {@link #getScript()}.\n     *\n     * @param name The name of the secondary program.\n     * @return new ScriptBuilder.\n     */\n    static CreateSecondaryProgram(name) {\n      const returnValue = new ScriptBuilder();\n      returnValue.addStatements(`sec ${name}():`);\n      returnValue.increaseIndent();\n      return returnValue;\n    }\n    /**\n     * Add a block of statements to the builder.\n     *\n     * @param statements A block of statements as a String.\n     * @return this object.\n     */\n    addStatements(statements) {\n      // Convert indention to a string\n      // If currentIndent is negative, then use blank string\n      let indentString = '';\n      for (let i = 0; i < this.currentIndent; i++) {\n        indentString += ScriptBuilder.SINGLE_INDENT;\n      }\n      statements.split('\\n').filter(statement => statement.length > 0).forEach(statement => {\n        this.script += `${indentString}${statement}\\n`;\n      });\n      return this;\n    }\n    /**\n     * Add raw script code.\n     * As this method takes raw script code that may not be indented and appends it without indenting it,\n     * it may violate the overall indentation.\n     *\n     * @param script The script to be appended\n     * @return this object.\n     */\n    addRaw(script) {\n      this.script += `${script}\\n`;\n      return this;\n    }\n    /**\n     * Add a while statement with a given expression.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.\n     *\n     * @param expression The string representation of an expression.\n     * @return this object.\n     */\n    beginWhile(expression) {\n      this.addStatements(`while (${expression}):`);\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add a while not statement with a given expression.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.\n     *\n     * @param expression The string representation of an expression.\n     * @return this object.\n     */\n    beginWhileNot(expression) {\n      this.addStatements(`while not (${expression}):`);\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add a while statement that loops forever.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.\n     *\n     * @return this object.\n     */\n    beginWhileTrue() {\n      this.beginWhile('True');\n      return this;\n    }\n    /**\n     * Add the end keyword that balances/terminates the declaration of functions, branch and loop statements.\n     *\n     * @return this object.\n     */\n    end() {\n      this.decreaseIndent();\n      this.addStatements('end');\n      return this;\n    }\n    /**\n     * End a block, without an end statement\n     * Used by if and elseif\n     * @return this object.\n     */\n    endBlock() {\n      this.decreaseIndent();\n      return this;\n    }\n    /**\n     * Add a return statement.\n     *\n     * @return this object.\n     */\n    returnMethod() {\n      this.addStatements('return');\n      return this;\n    }\n    /**\n     * Add a statement that declares a global variable and assigns it an initial value.\n     *\n     * @param name  The name of the global variable.\n     * @param value An expression which is the initial value of the global variable.\n     * @return this object.\n     */\n    globalVariable(name, value) {\n      this.addStatements(`global ${name} = ${value}`);\n      return this;\n    }\n    /**\n     * Add a statement that declares a local variable and assigns it an initial value.\n     *\n     * @param name  The name of the local variable.\n     * @param value An expression which is the initial value of the local variable.\n     * @return this object.\n     */\n    localVariable(name, value) {\n      this.addStatements(`local ${name} = ${value}`);\n      return this;\n    }\n    /**\n     * Declares or updates a persistent (shared) variable in URScript with the given name and value.\n     * Shared variables retain their values between program runs and are accessible globally.\n     *\n     * @param name  The name of the persistent variable.\n     * @param value The initial value or expression to assign to the persistent variable.\n     * @returns This ScriptBuilder instance for chaining.\n     */\n    setPersistentVariable(name, value) {\n      this.addStatements(`shared ${name} = ${value}`);\n      return this;\n    }\n    /**\n     * Add a statement that increments a variable with the given name.\n     *\n     * @param name The name of the variable.\n     * @return this object.\n     */\n    incrementVariable(name) {\n      this.addStatements(`${name} = ${name} + 1`);\n      return this;\n    }\n    /**\n     * Add a statement that assigns an expression to a variable.\n     *\n     * @param name       The name of the variable.\n     * @param expression The expression to be assigned to the variable.\n     * @return this object.\n     */\n    assign(name, expression) {\n      this.addStatements(`${name} = ${expression}`);\n      return this;\n    }\n    /**\n     * Add an if statement with a given expression.\n     * This is unbalanced, it has to be balanced by a call to {@link #elseIfCondition(String)} or\n     * {@link #else()} or {@link #end()} at the appropriate time.\n     *\n     * @param expression The expression that the if statement branches on.\n     * @return this object.\n     */\n    ifCondition(expression) {\n      this.addStatements(`if (${expression}):`);\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add an else if statement with a given expression.\n     * This is unbalanced, it has to be balanced by a call to {@link #elseIfCondition(String)} or\n     * {@link #elseIfCondition(Script)} or {@link #else()} or {@link #end()} at the appropriate time.\n     *\n     * @param expression The expression that the else if statement branches on.\n     * @return this object.\n     */\n    elseIfCondition(expression) {\n      this.addStatements(`elif (${expression}):`);\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add an else statement.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.\n     *\n     * @return this object.\n     */\n    else() {\n      this.addStatements('else:');\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add a thread definition with given the threadName.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.\n     *\n     * @param threadName The threadName of the thread.\n     * @return this object.\n     */\n    defineThread(threadName) {\n      this.addStatements(`thread ${threadName}():`);\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add a statement to run a thread with the given name and assign the thread handle to a variable.\n     *\n     * @param threadHandle The variable that gets assigned the thread handle .\n     * @param threadName   The name of the thread to be started.\n     * @return this object.\n     */\n    runThread(threadHandle, threadName) {\n      this.addStatements(`${threadHandle} = run ${threadName}()`);\n      return this;\n    }\n    /**\n     * Add a statement to kill a thread.\n     *\n     * @param threadHandle The thread threadHandle.\n     * @return this object.\n     */\n    killThread(threadHandle) {\n      this.addStatements(`kill ${threadHandle}`);\n      return this;\n    }\n    /**\n     * Add a function definition with the given name and parameters.\n     * This is unbalanced, it has to be balanced by a call to {@link #end()} at the appropriate time.\n     *\n     * @param name   The name of the function.\n     * @param params The parameters of the function.\n     * @return this object.\n     */\n    defineFunction(name, ...params) {\n      this.addStatements(`def ${name}(${params.join(',')}):`);\n      this.increaseIndent();\n      return this;\n    }\n    /**\n     * Add a comment in the script.\n     *\n     * @param text The comment text.\n     * @return this object.\n     */\n    comment(text) {\n      for (const comment of text.split('\\n')) {\n        this.addStatements(`# ${comment}`);\n      }\n      return this;\n    }\n    /**\n     * Implementation\n     */\n    addFrame(name, pose, refFrame = 'base') {\n      if (typeof pose === 'string') {\n        // Pass pose parameter as string expression\n        return this.addStatements(`add_frame(\"${name}\", ${pose}, \"${refFrame}\")`);\n      }\n      const position = isControllerPose(pose) ? pose.objectPosition.zUpPositionMeters : pose.position;\n      const orientation = isControllerPose(pose) ? pose.objectRotation.zUpRotationVectorRadians : pose.orientation;\n      const referenceFrame = isControllerPose(pose) ? pose.referenceFrame : refFrame;\n      return this.addStatements(`add_frame(\"${name}\", p[${position[0]}, ${position[1]}, ${position[2]}, ${orientation[0]}, ${orientation[1]}, ${orientation[2]}], \"${referenceFrame}\")`);\n    }\n    /**\n     * Delete the frame named frame from the world model.\n     * The \"world\", \"base\", and \"tcp\" frames cannot be deleted.\n     * Any frames that are attached to the deleted frame will be attached to the \"world\" frame with new frame offsets set\n     * such that the detached frame does not move in the world.\n     * This command will fail if the frame does not exist.\n     * @param name name of the frame to be deleted\n     */\n    deleteFrame(name) {\n      return this.addStatements(`delete_frame(\"${name}\")`);\n    }\n    /**\n     * Implementation\n     */\n    moveFrame(name, pose, refFrame = 'base') {\n      const position = isControllerPose(pose) ? pose.objectPosition.zUpPositionMeters : pose.position;\n      const orientation = isControllerPose(pose) ? pose.objectRotation.zUpRotationVectorRadians : pose.orientation;\n      const referenceFrame = isControllerPose(pose) ? pose.referenceFrame : refFrame;\n      return this.addStatements(`move_frame(\"${name}\", p[${position[0]}, ${position[1]}, ${position[2]}, ${orientation[0]}, ${orientation[1]}, ${orientation[2]}], \"${referenceFrame}\")`);\n    }\n    /**\n     * Attaches the child frame to the parent world model object. The relative transform between the parent and child will be set such that\n     * the child does not move in the world when the attachment occurs.\n     * The child cannot be \"world\", \"tcp\", or the same as parent.\n     * This will fail if child or parent is not an existing frame, or this makes the attachments form a closed chain.\n     * @param child name of the frame to be attached.  The name must not be \"world\" or \"tcp\".\n     * @param parent name of the object that the child frame will be attached to.\n     */\n    attachFrame(child, parent) {\n      return this.addStatements(`attach_frame(\"${child}\", \"${parent}\")`);\n    }\n    /**\n     * Implementation\n     */\n    setFrameOrientation(name, orientation) {\n      const baseFrameNameString = `\"${name}\"`;\n      const poseOrientation = isZUpRotationVectorRadians(orientation) ? orientation.zUpRotationVectorRadians : orientation;\n      return this.addStatements([`local existingBaseParent = get_frame_parent(${baseFrameNameString})`, `local basePose = get_pose(${baseFrameNameString}, existingBaseParent)`, `basePose[3] = ${poseOrientation[0]}`, `basePose[4] = ${poseOrientation[1]}`, `basePose[5] = ${poseOrientation[2]}`, `move_frame(${baseFrameNameString}, basePose, existingBaseParent)`].join('\\n'));\n    }\n    /**\n     * Add a popup with the given parameters.\n     *\n     * @param message    The popup message.\n     * @param title      The popup title.\n     * @param level      The popup level.\n     * @param isBlocking true if its a blocking popup and false otherwise.\n     * @return this object.\n     */\n    popup(message, title, level, isBlocking) {\n      let popupScript;\n      switch (level) {\n        case PopupLevel.ERROR:\n          popupScript = `popup(\"${message}\", \"${title}\", False, True, blocking=${ScriptBuilder.getBooleanAsString(isBlocking)})`;\n          break;\n        case PopupLevel.WARNING:\n          popupScript = `popup(\"${message}\", \"${title}\", True, False, blocking=${ScriptBuilder.getBooleanAsString(isBlocking)})`;\n          break;\n        case PopupLevel.INFO:\n          popupScript = `popup(\"${message}\", \"${title}\", False, False, blocking=${ScriptBuilder.getBooleanAsString(isBlocking)})`;\n          break;\n      }\n      this.addStatements(popupScript);\n      return this;\n    }\n    /**\n     * Request a value with the given parameters.\n     *\n     * @param variableName  The variable name to assign the value to\n     * @param message       The request message.\n     * @param valueType     The type: integer, float, boolean, or string\n     * @return this object.\n     */\n    requestValue(variableName, message, valueType) {\n      if (variableName && message && valueType !== null) {\n        const func = `request_${valueType.toLowerCase()}_from_primary_client(\"${message}\")`;\n        this.globalVariable(variableName, func);\n      }\n      return this;\n    }\n    /**\n     * Add a halt statement.\n     *\n     * @return this object.\n     */\n    halt() {\n      this.addStatements('halt');\n      return this;\n    }\n    /**\n     * @deprecated Use {@link break}\n     * @description Insert a break statement.\n     * @return this object.\n     */\n    insertBreak() {\n      return this.break();\n    }\n    /**\n     * @description Insert a break statement.\n     * @return this object.\n     */\n    break() {\n      this.addStatements('break');\n      return this;\n    }\n    /**\n     * Add a sync command that uses up the remaining \"physical\" time a thread has in the current frame.\n     *\n     * @return this object.\n     */\n    sync() {\n      this.addStatements('sync()');\n      return this;\n    }\n    /**\n     * Add a sleep command.\n     *\n     * @param seconds The amount of time in seconds.\n     * @return this object.\n     */\n    sleep(seconds) {\n      this.addStatements(`sleep(${seconds})`);\n      return this;\n    }\n    /**\n     * Add a stopl command. It decelerates tool speed to zero.\n     *\n     * @param toolAcceleration The tool acceleration in <i>m/</i><i>s</i><sup>2</sup>.\n     * @return this object.\n     */\n    stopl(toolAcceleration) {\n      this.addStatements(`stopl(${toolAcceleration})`);\n      return this;\n    }\n    /**\n     * Add a stopj command. It decelerates joint speeds to zero.\n     *\n     * @param jointAcceleration The joint acceleration in <i>rad/</i><i>s</i><sup>2</sup>.\n     * @return this object.\n     */\n    stopj(jointAcceleration) {\n      this.addStatements(`stopj(${jointAcceleration})`);\n      return this;\n    }\n    /**\n     * Add a call to the function that will accelerate linearly in Cartesian space and continue with constant tool\n     * speed.\n     *\n     * @param xd                    array of tool speeds in m/s (spatial vector).\n     * @param cartesianAcceleration tool position acceleration <i>m/</i><i>s</i><sup>2</sup>.\n     * @param time                  time in seconds before the function returns.\n     * @param refFrameName          name of reference frame\n     * @return this object.\n     */\n    speedl(xd, cartesianAcceleration, time, refFrameName) {\n      if (refFrameName) {\n        this.addStatements(`speedl(struct(vel=${ScriptBuilder.formatArray(xd)}, frame=\"${refFrameName}\"), ${cartesianAcceleration}, ${time})`);\n      } else {\n        this.addStatements(`speedl(${ScriptBuilder.formatArray(xd)}, ${cartesianAcceleration}, ${time})`);\n      }\n      return this;\n    }\n    /**\n     * Add a call to the function that will accelerate linearly in joint space and continue with constant joint\n     * speed.\n     *\n     * @param qd                array of joint speeds in rad/s.\n     * @param jointAcceleration joint acceleration in <i>rad/</i><i>s</i><sup>2</sup> (of leading axis)\n     * @param time              time in seconds before the function returns.\n     * @return this object.\n     */\n    speedj(qd, jointAcceleration, time) {\n      this.addStatements(`speedj(${ScriptBuilder.formatArray(qd)}, ${jointAcceleration}, ${time})`);\n      return this;\n    }\n    /**\n     * Add a call to the function that will Move to position (linear in joint-space).\n     * @param q joint positions (q can also be specified as a pose, then\n     * inverse kinematics is used to calculate the corresponding\n     * joint positions) as a string or number array.\n     * @param acc joint acceleration of leading axis in <i>rad/</i><i>s</i><sup>2</sup> as a string or number.\n     * @param speed joint speed of leading axis in rad/s as a string or number (optional).\n     * @param time time in seconds as a string or number (optional).\n     * @param blendRadius blend radius in m as a string or number (optional).\n     * @return this object.\n     */\n    movej(q, acc, speed, time, blendRadius) {\n      if (typeof q !== 'string' && !(q instanceof String)) {\n        q = ScriptBuilder.formatArray(q);\n      }\n      const args = [`${q}`];\n      if (acc) {\n        args.push(`a=${acc}`);\n      }\n      if (speed) {\n        args.push(`v=${speed}`);\n      }\n      if (time) {\n        args.push(`t=${time}`);\n      }\n      if (blendRadius) {\n        args.push(`r=${blendRadius}`);\n      }\n      this.addStatements(`movej(${args.join(', ')})`);\n      return this;\n    }\n    /**\n     * Add a call to the function that will Move to position (linear in tool-space).\n     * @param pose target pose (pose can also be specified as joint\n     * positions, then forward kinematics is used to\n     * calculate the corresponding pose) as a string.\n     * @param acc tool acceleration <i>m/</i><i>s</i><sup>2</sup> as a string or number.\n     * @param speed tool speed in m/s as a string or number (optional).\n     * @param time time in seconds as a string or number (optional).\n     * @param blendRadius blend radius in m as a string or number (optional).\n     * @return this object.\n     */\n    movel(pose, acc, speed, time, blendRadius) {\n      const args = [pose];\n      if (acc) {\n        args.push(`a=${acc}`);\n      }\n      if (speed) {\n        args.push(`v=${speed}`);\n      }\n      if (time) {\n        args.push(`t=${time}`);\n      }\n      if (blendRadius) {\n        args.push(`r=${blendRadius}`);\n      }\n      this.addStatements(`movel(${args.join(', ')})`);\n      return this;\n    }\n    /**\n     * Blend circular (in tool-space) and move linear (in tool-space) to position. Accelerates to and moves\n     * with constant tool speed v.\n     * @param q joint positions (q can also be specified as a pose, then\n     * inverse kinematics is used to calculate the corresponding\n     * joint positions) as a string or number array.\n     * @param acc joint acceleration of leading axis in <i>rad/</i><i>s</i><sup>2</sup> as a string or number.\n     * @param speed joint speed of leading axis in rad/s as a string or number (optional).\n     * @param blendRadius blend radius in m as a string or number (optional).\n     * @return this object.\n     */\n    movep(q, acc, speed, blendRadius) {\n      if (typeof q !== 'string' && !(q instanceof String)) {\n        q = ScriptBuilder.formatArray(q);\n      }\n      const args = [`${q}`];\n      if (acc) {\n        args.push(`a=${acc}`);\n      }\n      if (speed) {\n        args.push(`v=${speed}`);\n      }\n      if (blendRadius) {\n        args.push(`r=${blendRadius}`);\n      }\n      this.addStatements(`movep(${args.join(', ')})`);\n      return this;\n    }\n    /**\n     * TCP moves on the circular arc segment from current pose, through pose_via to pose_to.\n     * Accelerates to and moves with constant tool speed v. Use the mode parameter to define the\n     * orientation interpolation.\n     * @param pose_via path point (note: only position is used). Pose_via can also be specified as joint\n     * positions, then forward kinematics is used to calculate the corresponding pose as a string or number array.\n     * @param pose_to target pose (note: only position is used in Fixed orientation mode). Pose_to can also\n     * be specified as joint positions, then forward kinematics is used to calculate the corresponding\n     * pose as a string or number array.\n     * @param acc tool acceleration <i>rad/</i><i>s</i><sup>2</sup> as a string or number (optional).\n     * @param speed tool speed in m/s as a string or number (optional).\n     * @param blendRadius blend radius (of target pose) in m as a string or number (optional).\n     * @param mode mode of circular arc move as a string or number (optional).\n     * 0: Unconstrained mode. Interpolate orientation from current pose to target pose (pose_to)\n     * 1: Fixed mode. Keep orientation constant relative to the tangent of the circular arc (starting\n     * from current pose)\n     * @return this object.\n     */\n    movec(pose_via, pose_to, acc, speed, blendRadius, mode) {\n      if (typeof pose_via !== 'string') {\n        pose_via = ScriptBuilder.formatArray(pose_via);\n      }\n      if (typeof pose_to !== 'string') {\n        pose_to = ScriptBuilder.formatArray(pose_to);\n      }\n      const args = [`${pose_via}`, `${pose_to}`];\n      if (acc) {\n        args.push(`a=${acc}`);\n      }\n      if (speed) {\n        args.push(`v=${speed}`);\n      }\n      if (blendRadius) {\n        args.push(`r=${blendRadius}`);\n      }\n      if (mode) {\n        args.push(`mode=${mode}`);\n      }\n      this.addStatements(`movec(${args.join(', ')})`);\n      return this;\n    }\n    /**\n     * Add a call to the function that will Move to position (linear in joint-space), using OptiMove\n     * @param q joint positions (q can also be specified as a pose, then\n     * inverse kinematics is used to calculate the corresponding\n     * joint positions) as a string or number array.\n     * @param acc Joint acceleration as a fraction of what the joints are able to perform - a (0.0, 1.0] (optional).\n     * @param speed Joint speed as a fraction of how fast the joints can move during the motion - v (0.0, 1.0] (optional).\n     * @param blendRadius blend radius in m as a string or number (optional).\n     * @return this object.\n     */\n    optimovej(q, acc, speed, blendRadius) {\n      if (typeof q !== 'string' && !(q instanceof String)) {\n        q = ScriptBuilder.formatArray(q);\n      }\n      const args = [`${q}`];\n      if (acc) {\n        args.push(`a=${acc}`);\n      }\n      if (speed) {\n        args.push(`v=${speed}`);\n      }\n      if (blendRadius) {\n        args.push(`r=${blendRadius}`);\n      }\n      this.addStatements(`optimovej(${args.join(', ')})`);\n      return this;\n    }\n    /**\n     * Add a call to the function that will Move to position (linear in tool-space), using OptiMove\n     * @param pose target pose (pose can also be specified as joint\n     * positions, then forward kinematics is used to\n     * calculate the corresponding pose) as a string.\n     * @param acc tool acceleration <i>m/</i><i>s</i><sup>2</sup> as a string or number.\n     * @param speed tool speed in m/s as a string or number (optional).\n     * @param blendRadius blend radius in m as a string or number (optional).\n     * @return this object.\n     */\n    optimovel(pose, acc, speed, blendRadius) {\n      const args = [pose];\n      if (acc) {\n        args.push(`a=${acc}`);\n      }\n      if (speed) {\n        args.push(`v=${speed}`);\n      }\n      if (blendRadius) {\n        args.push(`r=${blendRadius}`);\n      }\n      this.addStatements(`optimovel(${args.join(', ')})`);\n      return this;\n    }\n    /**\n     * @deprecated use {@link setTargetPayload}\n     * @description Add a call to the function that sets the mass.\n     * @param mass mass in kilograms as a Script.\n     * @return this object.\n     */\n    setPayloadMass(mass) {\n      this.addStatements(`set_payload_mass(${mass})`);\n      return this;\n    }\n    /**\n     * @deprecated use {@link setTargetPayload}\n     * @description Add a call to the function that sets the mass and CoG.\n     * @param mass mass in kilograms as a Script.\n     * @param cx CoG x offset in meters\n     * @param cy CoG y offset in meters\n     * @param cz CoG z offset in meters\n     * @param inertia The payload inertia matrix in kg*m^2, elements lxx,lyy\n     * lzz, lxy, lxz, lyz\n     * @return this object.\n     */\n    setPayloadMassAndCoG(mass, cx, cy, cz, inertia) {\n      return this.setTargetPayload(mass, cx, cy, cz, inertia);\n    }\n    /**\n     * @description Add a call to the function that sets the mass and CoG.\n     * @param mass mass in kilograms as a Script.\n     * @param cx CoG x offset in meters\n     * @param cy CoG y offset in meters\n     * @param cz CoG z offset in meters\n     * @param inertia The payload inertia matrix in kg*m^2, elements lxx,lyy\n     * lzz, lxy, lxz, lyz\n     * @return this object.\n     */\n    setTargetPayload(mass, cx, cy, cz, inertia) {\n      if (inertia) {\n        this.addStatements(`set_target_payload(${mass}, [${cx}, ${cy}, ${cz}], [${inertia[0]}, ${inertia[1]}, ${inertia[2]}, ${inertia[3]}, ${inertia[4]}, ${inertia[5]}])`);\n      } else {\n        this.addStatements(`set_target_payload(${mass}, [${cx}, ${cy}, ${cz}])`);\n      }\n      return this;\n    }\n    /**\n     * Set the direction of the acceleration experienced by the robot.\n     *\n     * @param x x m/s^2\n     * @param y y m/s^2\n     * @param z z m/s^2\n     */\n    setGravity(x, y, z) {\n      return this.addStatements(`set_gravity([${x},${y},${z}])`);\n    }\n    /**\n     * @description Add a call function which specifies the desired TCP\n     * @param x x length\n     * @param y y length\n     * @param z z length\n     * @param rx rx angle\n     * @param ry ry angle\n     * @param rz rz angle\n     * @param name Name of the TCP\n     */\n    setTcp(x, y, z, rx, ry, rz, name) {\n      this.addStatements(`set_tcp(p[${x}, ${y}, ${z}, ${rx}, ${ry}, ${rz}]${name ? ', \"' + name + '\"' : ''})`);\n      return this;\n    }\n    /**\n     * Append the content of another script builder to\n     * this script builder\n     *\n     * @param scriptBuilder\n     */\n    append(scriptBuilder) {\n      if (scriptBuilder.getIndention() < 0) {\n        this.increaseIndent(scriptBuilder.getIndention());\n        this.addStatements(scriptBuilder.getScript());\n      } else {\n        this.addStatements(scriptBuilder.getScript());\n        this.increaseIndent(scriptBuilder.getIndention());\n      }\n      return this;\n    }\n    /**\n     * The terminal operation that generates the as string containing the UR Script.\n     *\n     * @return the string that contains the UR Script.\n     */\n    getScript() {\n      // @ts-ignore trimEnd is not part of the es2015 lib, even though it exists\n      return this.script.trimEnd();\n    }\n    /**\n     * Get the current indention level of this ScriptBuilder.\n     *\n     * @return the indention level as a number.\n     */\n    getIndention() {\n      return this.currentIndent;\n    }\n    /**\n     * Increase the indent.\n     */\n    increaseIndent(level = ScriptBuilder.SINGLE_INDENT_LEVEL) {\n      this.currentIndent += level;\n    }\n    /**\n     * Decrease the indent.\n     */\n    decreaseIndent(level = ScriptBuilder.SINGLE_INDENT_LEVEL) {\n      this.currentIndent -= level;\n    }\n  }\n  return ScriptBuilder;\n})();\n/**\n * Creates the serializer for the ScriptBuilder. Handles serializing and deserializing of the object.\n * @constructor\n */\nconst ScriptBuilderSerializer = () => {\n  return {\n    /**\n     * Deserializes the message as a new ScriptBuilder based on the message inputs\n     * @param message Message containing the values to be parsed to the new ScriptBuilder\n     * @param defaultHandler The object to handle deserializing if not of type ScriptBuilder\n     */\n    deserialize(message, defaultHandler) {\n      if (message && message.type === '$$ScriptBuilder') {\n        const script = message.script;\n        const currentIndent = message.currentIndent;\n        return new ScriptBuilder(script, currentIndent);\n      }\n      return defaultHandler(message);\n    },\n    /**\n     * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning\n     * @param item The original item that will be serialized\n     * @param defaultHandler The object to handle serializing if not of type ScriptBuilder\n     */\n    serialize(item, defaultHandler) {\n      if (item && item.constructor && item.constructor.name === 'ScriptBuilder') {\n        return {\n          type: '$$ScriptBuilder',\n          ...item\n        };\n      }\n      return defaultHandler(item);\n    }\n  };\n};\n\n/**\n * Checks that the message coming is in a isSerializedScriptContext\n * @param message\n */\nfunction isSerializedScriptContext(message) {\n  return message && message.type === '$$ScriptContext';\n}\n/**\n * Creates the serializer for the ScriptContext. Handles serializing and deserializing of the object.\n * @constructor\n */\nconst ScriptContextSerializer = () => {\n  return {\n    /**\n     * Deserializes the message as a new ScriptContext based on the message inputs\n     * @param message Message containing the values to be parsed to the new ScriptContext\n     * @param defaultHandler The object to handle deserializing if not of type ScriptContext\n     */\n    deserialize(message, defaultHandler) {\n      if (isSerializedScriptContext(message)) {\n        return {\n          traverse: {\n            ancestors: new AsyncArrayTraverser(message.ancestors ? message.ancestors : []),\n            children: new AsyncArrayTraverser(message.children ? message.children : []),\n            depthFirst: new AsyncArrayTraverser(message.depthFirst ? message.depthFirst : []),\n            nextSiblings: new AsyncArrayTraverser(message.nextSiblings ? message.nextSiblings : []),\n            previousSiblings: new AsyncArrayTraverser(message.previousSiblings ? message.previousSiblings : [])\n          }\n        };\n      } else {\n        return defaultHandler(message);\n      }\n    },\n    /**\n     * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning\n     * @param item The original item that will be serialized\n     * @param defaultHandler The object to handle serializing if not of type ScriptContext\n     */\n    serialize(item, defaultHandler) {\n      if (isSerializedScriptContext(item)) {\n        return {\n          type: '$$ScriptContext',\n          ancestors: item.ancestors,\n          children: item.children,\n          depthFirst: item.depthFirst,\n          previousSiblings: item.previousSiblings,\n          nextSiblings: item.nextSiblings\n        };\n      } else {\n        return defaultHandler(item);\n      }\n    }\n  };\n};\n\n/**\n * Checks that the message coming is in a isSerializedValidationContext\n * @param message\n */\nfunction isSerializedValidationContext(message) {\n  return message && message.type === '$$ValidationContext';\n}\n/**\n * Creates the serializer for the ValidationContext. Handles serializing and deserializing of the object.\n * @constructor\n */\nconst ValidationContextSerializer = () => {\n  return {\n    /**\n     * Deserializes the message as a new ValidationContext based on the message inputs\n     * @param message Message containing the values to be parsed to the new ValidationContext\n     * @param defaultHandler The object to handle deserializing if not of type ValidationContext\n     */\n    deserialize(message, defaultHandler) {\n      if (isSerializedValidationContext(message)) {\n        return {\n          traverse: {\n            ancestors: new AsyncArrayTraverser(message.ancestors ? message.ancestors : []),\n            children: new AsyncArrayTraverser(message.children ? message.children : []),\n            depthFirst: new AsyncArrayTraverser(message.depthFirst ? message.depthFirst : []),\n            nextSiblings: new AsyncArrayTraverser(message.nextSiblings ? message.nextSiblings : []),\n            previousSiblings: new AsyncArrayTraverser(message.previousSiblings ? message.previousSiblings : [])\n          }\n        };\n      } else {\n        return defaultHandler(message);\n      }\n    },\n    /**\n     * Serializes the object and inserts a type to be used when deserializing to proper identifying the object when returning\n     * @param item The original item that will be serialized\n     * @param defaultHandler The object to handle serializing if not of type ValidationContext\n     */\n    serialize(item, defaultHandler) {\n      if (isSerializedValidationContext(item)) {\n        return {\n          type: '$$ValidationContext',\n          ancestors: item.ancestors,\n          children: item.children,\n          depthFirst: item.depthFirst,\n          previousSiblings: item.previousSiblings,\n          nextSiblings: item.nextSiblings\n        };\n      } else {\n        return defaultHandler(item);\n      }\n    }\n  };\n};\n\n/**\n * Setup registration of serializers to be used when sending/receiving object across worker boundaries\n */\nfunction registerSerializers() {\n  registerSerializer(ScriptContextSerializer());\n  registerSerializer(ValidationContextSerializer());\n  registerSerializer(InsertionContextSerializer());\n  registerSerializer(ScriptBuilderSerializer());\n  registerSerializer(ApplicationContextSerializer());\n}\n\n/**\n * Common handler for behaviors\n */\nconst behaviorHandler = behaviors => {\n  registerSerializers();\n  expose(behaviors);\n};\n/**\n * Registers a Program behavior object allowing the programming area to\n * call the behavior methods.\n *\n * @param behaviors The ProgramBehaviors object to register\n */\nconst registerProgramBehavior = behaviorHandler;\n/**\n * Registers an Application behavior object allowing the application area to\n * call the behavior methods.\n *\n * @param behaviors The ApplicationBehaviors object to register\n */\nconst registerApplicationBehavior = behaviorHandler;\n/**\n * Registers a Source behavior object allowing various entities to call source\n * behavior methods\n *\n * @param behaviors The SourceBehaviors object to register\n */\nconst registerSourceBehavior = behaviorHandler;\n/**\n * Registers a Smart skill behavior object allowing each smart skill to call its execution methods\n * behavior methods\n *\n * @param behaviors The SmartSkillsBehaviors object to register\n */\nconst registerSmartSkillBehavior = behaviorHandler;\n/**\n * Registers a Operator Screen behavior object allowing each operator screen to call its\n * behavior methods\n *\n * @param behaviors The OperatorScreenBehaviors object to register\n */\nconst registerOperatorScreenBehavior = behaviorHandler;\n/**\n * Registers a System Info behavior object allowing each system info screen to call its\n * behavior methods\n *\n * @param behaviors The SystemInfoBehaviors object to register\n */\nconst registerSystemInfoBehavior = behaviorHandler;\n/**\n * Registers a Sidebar behavior object allowing each sidebar to call its\n * behavior methods\n *\n * @param behaviors The SidebarBehaviors object to register\n */\nconst registerSidebarBehavior = behaviorHandler;\nconst VALIDATION_OK = {\n  isValid: true\n};\nconst VALIDATION_INVALID = {\n  isValid: false\n};\n\n/**\n * API for operator screen presenter components\n */\nclass OperatorScreenPresenterAPI extends CommonPresenterAPI {\n  /** Creates a new instance of the OperatorScreenPresenterAPI, to allow communication with the\n   * surrounding application from within a WebComponent\n   *\n   * @param target An EventTarget, provided by PolyScope X\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.builder = new TreeBuilder(communicationChannel);\n    this.robotMoveService = new RobotMoveService(communicationChannel);\n    this.programExecutionService = new ProgramExecutionService(communicationChannel);\n    this.toolService = new ToolService(communicationChannel);\n    this.mountingService = new MountingService(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n    this.operatorScreenService = new OperatorScreenService(communicationChannel);\n    this.motionProfilesService = new MotionProfilesService(communicationChannel);\n    this.scriptFileService = new ScriptFileService(communicationChannel);\n  }\n}\n/**\n * Provides access to Operator Screen related API features in BehaviorWorkers\n */\nclass OperatorScreenBehaviorAPI extends CommonBehaviorAPI {\n  /** Creates a new instance of the OperatorScreenBehaviorAPI to allow communication with the\n   * surrounding application from within a WebWorker\n   *\n   * @param target A worker, provided with 'self' when created inside a web worker\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new WorkerCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.builder = new TreeBuilder(communicationChannel);\n    this.toolService = new ToolService(communicationChannel);\n    this.mountingService = new MountingService(communicationChannel);\n    this.framesService = new FramesService(communicationChannel);\n    this.motionProfilesService = new MotionProfilesService(communicationChannel);\n    this.scriptFileService = new ScriptFileService(communicationChannel);\n  }\n}\n\n/**\n * WebComponentDialogAPI\n */\nclass WebComponentDialogAPI extends CommonPresenterAPI {\n  /** Creates a new instance of the WebComponentDialogAPI, to allow communication with the\n   * surrounding application from within a WebComponent\n   *\n   * @param target An EventTarget, provided by PolyScope X\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.robotMoveService = new RobotMoveService(communicationChannel);\n  }\n}\n\n/**\n * Provides access to system info related API features in System Info Presenters\n */\nclass SystemInfoPresenterAPI extends CommonPresenterAPI {\n  /** Creates a new instance of the SystemInfoPresenterAPI, to allow communication with the\n   * surrounding application from within a WebComponent\n   *\n   * @param target An EventTarget, provided by PolyScope X\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n  }\n}\n\n/**\n * Provides access to Sidebar related API features in BehaviorWorkers\n */\nclass SidebarBehaviorAPI extends CommonBehaviorAPI {\n  /**\n   * Creates a new instance of the SidebarBehaviorAPI to allow communication with the\n   * surrounding application from within a WebWorker\n   *\n   * @param target A worker, provided with 'self' when created inside a web worker\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new WorkerCommunicationChannel(target);\n    }\n    super(communicationChannel);\n  }\n}\n/**\n * Provides access to Sidebar related API features in Presenters\n */\nclass SidebarPresenterAPI extends CommonPresenterAPI {\n  /**\n   * Create a new instance of the SidebarPresenterAPI to allow a Presenter to interact with the API and update itself\n   */\n  constructor(target) {\n    let communicationChannel;\n    if (isCommunicationChannel(target)) {\n      communicationChannel = target;\n    } else {\n      communicationChannel = new EventTargetCommunicationChannel(target);\n    }\n    super(communicationChannel);\n    this.smartSkillInstanceService = new SmartSkillInstanceService(communicationChannel);\n    this.smartSkillExecutionService = new SmartSkillExecutionService(communicationChannel);\n    this.teachModeService = new TeachModeService(communicationChannel);\n    this.applicationVariablesService = new ApplicationVariablesService(communicationChannel);\n  }\n}\n\n/**\n * Model to be used in collaboration with tabInputComponent.\n */\nclass TabInputModel {\n  /**\n   * Initialize the object.\n   */\n  constructor(entity, selectedType, value) {\n    this.entity = entity;\n    this.selectedType = selectedType;\n    this.value = value;\n  }\n  /**\n   * Validates the model\n   * @param model to validate\n   */\n  static isValid(model) {\n    return _asyncToGenerator(function* () {\n      if (model.selectedType === SelectedInput.VARIABLE) {\n        const api = new ProgramBehaviorAPI(self);\n        const isSuppressed = yield api.symbolService.isSuppressed(model.value);\n        const isRegisteredVariableName = yield api.symbolService.isRegisteredVariableName(model.value);\n        if (!isRegisteredVariableName || isSuppressed) {\n          return false;\n        }\n      }\n      return true;\n    })();\n  }\n  /**\n   * Checks if tabInputModel has an entity and a selectedType\n   * @param value to be interrogated\n   */\n  static isTabInputModel(value) {\n    return value.entity !== undefined && value.selectedType !== undefined;\n  }\n  /**\n   * Returns TabInputValue from TabInputModel which is the input for the TabInput component\n   */\n  static getTabInputValue(model) {\n    return {\n      selectedType: model.selectedType,\n      value: model.value\n    };\n  }\n  /**\n   * Sets TabInputValue on TabInputModel which is the input for the TabInput component\n   * @param model to update the TabInputValue\n   * @param value the inserted value for the model.\n   */\n  static setTabInputValue(model, value) {\n    model.selectedType = value.selectedType;\n    model.value = value.value;\n  }\n}\n\n/**\n * Describes a relative insertion point\n */\nvar InsertionEnum = /*#__PURE__*/function (InsertionEnum) {\n  InsertionEnum[\"BEFORE\"] = \"before\";\n  InsertionEnum[\"AFTER\"] = \"after\";\n  InsertionEnum[\"INTO_FIRST\"] = \"intoFirst\";\n  InsertionEnum[\"INTO_LAST\"] = \"intoLast\";\n  return InsertionEnum;\n}(InsertionEnum || {});\n/**\n *\n */\nvar BlockEnum = /*#__PURE__*/function (BlockEnum) {\n  BlockEnum[\"MAIN_PROGRAM\"] = \"mainProgram\";\n  BlockEnum[\"BEFORE_START\"] = \"beforeStart\";\n  return BlockEnum;\n}(BlockEnum || {});\nconst AngleUnits = ['rad', 'deg'];\nconst CurrentUnits = ['A', 'mA'];\nconst AccelerationUnits = ['m/s^2', 'mm/s^2'];\nconst AngularAccelerationUnits = ['rad/s^2', 'deg/s^2'];\nconst AngularSpeedUnits = ['rad/s', 'deg/s'];\nconst ForceUnits = ['N'];\nconst LengthUnits = ['m', 'mm'];\nconst MassUnits = ['g', 'kg'];\nconst SpeedUnits = ['m/s', 'mm/s'];\nconst TimeUnits = ['s', 'ms'];\nconst MomentInertiaUnits = ['kg*m^2'];\nconst MomentumUnits = ['kgm/s'];\nconst TemperatureUnits = ['C'];\nconst VoltageUnits = ['V', 'mV'];\nconst AllUnitStrings = new Set([...MassUnits, ...SpeedUnits, ...LengthUnits, ...AngleUnits, ...VoltageUnits, ...CurrentUnits, ...AngularSpeedUnits, ...AccelerationUnits, ...AngularAccelerationUnits, ...TimeUnits, ...ForceUnits, ...MomentumUnits, ...MomentInertiaUnits, ...TemperatureUnits]);\n\n/**\n * Map object containing all the ValueObject strings, mapped to their Unit Library unit\n */\nconst ValueObjectMap = {\n  g,\n  kg,\n  kgM,\n  'kgm/s': kgMPerSec,\n  'deg/s': degPerSec,\n  'deg/s^2': degPerSecSq,\n  'm/s': mPerSec,\n  'm/s^2': mPerSecSq,\n  'mm/s': mmPerSec,\n  'mm/s^2': mmPerSecSq,\n  'rad/s': radPerSec,\n  'rad/s^2': radPerSecSq,\n  A,\n  N,\n  V,\n  deg,\n  m,\n  mA,\n  mV,\n  mm,\n  ms,\n  rad,\n  s,\n  W,\n  'kg*m^2': kgMSq,\n  degreesCelsius\n};\n\n/**\n * Converts one value object to another one with a different compatible unit\n * @example\n * ```ts\n *  const value = { value: 1, unit: m/s };\n *  const toUnit = mm/s;\n *  const convertedValue = convertValue(value, toUnit);\n *  console.log(convertedValue); // outputs { value: 1000, unit: mm/s };\n * ```\n * @throws Error if the value object and the provided unit are incompatible\n * @param value The value object to be converted\n * @param toUnit The unit to convert into, must be compatible with the value object's unit\n * @returns a new value object that contains the converted value\n * @see valueRawConverter\n */\nfunction convertValue(value, toUnit) {\n  if (!Object.keys(ValueObjectMap).includes(value.unit)) {\n    throw new Error(`Unknown unit in value ${value.unit}`);\n  }\n  if (!Object.keys(ValueObjectMap).includes(toUnit)) {\n    throw new Error(`Unknown target unit ${toUnit}`);\n  }\n  const from = ValueObjectMap[value.unit];\n  const to = ValueObjectMap[toUnit];\n  if (from.quantity.quantity !== to.quantity.quantity) {\n    throw new Error('Cannot convert mismatched units');\n  }\n  const originalValue = new FixedPointNumber(value.value, from);\n  const newValue = converter(originalValue, to);\n  return {\n    value: newValue.getValue(),\n    unit: toUnit\n  };\n}\n/**\n * Get the raw numeric value of a value object converted into another compatible unit as a string\n * <p>The returned value is formatted using {@link FixedPointNumber#getDisplayValue} and is without any unit symbols or label</p>\n * @example\n * ```ts\n *  const value = { value: 1, unit: \"m/s\" };\n *  const toUnit = \"mm/s\";\n *  const convertedValue = valueRawConverter(value, toUnit);\n *  console.log(convertedValue); // outputs \"1000\"\n * ```\n * @throws Error if the value object and the provided unit are incompatible\n * @param value The value object to be converted\n * @param to The unit to convert into, must be compatible with the value object's unit\n * @returns The raw numeric value of the converted value object as a formatted string\n * @see convertValue\n */\nfunction valueRawConverter(value, to) {\n  const convertedValue = convertValue(value, to.label);\n  return `${new FixedPointNumber(Number(convertedValue.value), to).getDisplayValue()}`;\n}\n/**\n * Transform the value object into a formatted string converting it to the specified unit with the unit's symbol appended\n * <p>The returned value is formatted using {@link FixedPointNumber#getDisplayValue} and is without any unit symbols or label</p>\n * @example\n * ```ts\n *  const value = { value: 1, unit: \"m/s\" };\n *  const toUnit = \"mm/s\";\n *  const convertedValue = valueConverter(value, toUnit);\n *  console.log(convertedValue); // outputs \"1000 mm/s\"\n * ```\n * @throws Error if the value object and the provided unit are incompatible\n * @param value The value object to be formatted\n * @param to The unit to convert into, must be compatible with the value object's unit\n * @returns The formatted value with the unit's symbol appended\n */\nfunction valueConverter(value, to) {\n  const convertedValue = convertValue(value, to.label);\n  return `${new FixedPointNumber(Number(convertedValue.value), to).getDisplayValue()} ${to.symbol}`;\n}\n\n/**\n * Presets available for Digital In signals\n */\nvar DigitalInPreset = /*#__PURE__*/function (DigitalInPreset) {\n  DigitalInPreset[DigitalInPreset[\"NONE\"] = 0] = \"NONE\";\n  DigitalInPreset[DigitalInPreset[\"START\"] = 1] = \"START\";\n  DigitalInPreset[DigitalInPreset[\"STOP\"] = 2] = \"STOP\";\n  DigitalInPreset[DigitalInPreset[\"PAUSE\"] = 3] = \"PAUSE\";\n  return DigitalInPreset;\n}(DigitalInPreset || {});\n/**\n * Enumeration for possible signal directions\n */\nvar SignalDirectionEnum = /*#__PURE__*/function (SignalDirectionEnum) {\n  SignalDirectionEnum[\"IN\"] = \"IN\";\n  SignalDirectionEnum[\"OUT\"] = \"OUT\";\n  return SignalDirectionEnum;\n}(SignalDirectionEnum || {});\n/**\n * Enumeration for possible signal value types\n */\nvar SignalValueTypeEnum = /*#__PURE__*/function (SignalValueTypeEnum) {\n  SignalValueTypeEnum[\"BOOLEAN\"] = \"BOOLEAN\";\n  SignalValueTypeEnum[\"FLOAT\"] = \"FLOAT\";\n  SignalValueTypeEnum[\"REGISTER\"] = \"REGISTER\";\n  SignalValueTypeEnum[\"CUSTOM\"] = \"CUSTOM\";\n  return SignalValueTypeEnum;\n}(SignalValueTypeEnum || {});\n/**\n * Enum with all possible analog domain values\n */\nvar SignalAnalogDomainValueEnum = /*#__PURE__*/function (SignalAnalogDomainValueEnum) {\n  SignalAnalogDomainValueEnum[\"CURRENT\"] = \"CURRENT\";\n  SignalAnalogDomainValueEnum[\"VOLTAGE\"] = \"VOLTAGE\";\n  return SignalAnalogDomainValueEnum;\n}(SignalAnalogDomainValueEnum || {});\n/*\n * Public API Surface of contribution-api\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { APPLICATION_NODE_SERVICE_MESSAGE_TYPE_BASE, APPLICATION_SERVICE_MESSAGE_TYPE_BASE, APPLICATION_VARIABLES_SERVICE_MESSAGE_TYPE_BASE, AccelerationUnits, ActionEnum, AllUnitStrings, AngleUnits, AngularAccelerationUnits, AngularSpeedUnits, ApplicationBehaviorAPI, ApplicationNodeService, ApplicationNodeType, ApplicationPresenterAPI, ApplicationService, ApplicationVariablesService, AsyncArrayTraverser, BlockEnum, CenterOfGravityAxes, CommunicationChannel, CurrentUnits, DIALOG_SERVICE_MESSAGE_TYPE_BASE, DialogService, DigitalInPreset, DirectionalPositionAxes, DurabilityPolicy, EXPRESSION_EDITOR_SERVICE_MESSAGE_TYPE_BASE, EventTargetCommunicationChannel, ExpressionEditorService, FRAMES_SERVICE_MESSAGE_TYPE_BASE, FREEDRIVE_STATE_SERVICE_MESSAGE_TYPE_BASE, ForceUnits, FrameNodeAction, FramesService, FreedriveService, HistoryPolicy, InertiaMatrixKeys, InsertionEnum, LOG_MESSAGE_SERVICE_MESSAGE_TYPE_BASE, LOG_PERFORMANCE_SERVICE_MESSAGE_TYPE_BASE, LengthUnits, LivelinessPolicy, LogMessageService, LogPerformanceService, MOTION_PROFILES_SERVICE_MESSAGE_TYPE_BASE, MOUNTING_SERVICE_MESSAGE_TYPE_BASE, MassUnits, MessageInvokerService, MomentInertiaUnits, MomentumUnits, MotionProfileMoveType, MotionProfilesService, MountingService, MovementType, NodeType, OPERATOR_SCREEN_SERVICE_MESSAGE_TYPE_BASE, OperatorInputType, OperatorScreenBehaviorAPI, OperatorScreenPresenterAPI, OperatorScreenService, OrientationAxes, OrientationMode, PROGRAM_CODE_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_NODE_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_SERVICE_MESSAGE_TYPE_BASE, PROGRAM_TREE_SERVICE_MESSAGE_TYPE_BASE, PopupLevel, PoseAxes, PoseUtils, PositionAxes, ProgramBehaviorAPI, ProgramCodeService, ProgramExecutionService, ProgramNodeService, ProgramPresenterAPI, ProgramService, ProgramTreeService, QoSProfile, ROBOT_INFO_SERVICE_MESSAGE_TYPE_BASE, ROBOT_MOVE_SERVICE_MESSAGE_TYPE_BASE, ROBOT_POSITION_SERVICE_MESSAGE_TYPE_BASE, ReliabilityPolicy, RobotInfoService, RobotMoveService, RobotPositionService, Ros2Client, Ros2EventService, SAFETY_SERVICE_MESSAGE_TYPE_BASE, SCRIPT_FILE_SERVICE_MESSAGE_TYPE_BASE, SETTINGS_MESSAGE_TYPE_BASE, SMART_SKILL_EXECUTION_SERVICE_MESSAGE_TYPE_BASE, SMART_SKILL_INSTANCE_SERVICE_MESSAGE_TYPE_BASE, SNACKBAR_SERVICE_MESSAGE_TYPE_BASE, SOURCE_MESSAGE_TYPE_BASE, SOURCE_NODE_SERVICE_MESSAGE_TYPE_BASE, SYMBOL_SERVICE_MESSAGE_TYPE_BASE, SYSTEM_SERVICE_MESSAGE_TYPE_BASE, SafetyService, ScriptBuilder, ScriptFileService, SettingsService, SidebarBehaviorAPI, SidebarPresenterAPI, SignalAnalogDomainValueEnum, SignalDirectionEnum, SignalService, SignalValueTypeEnum, SmartSkillExecutionService, SmartSkillInstanceService, SmartSkillType, SmartSkillsBehaviorAPI, SmartSkillsPresenterAPI, SnackbarService, SourceBehaviorAPI, SourceNodeService, SourcePresenterAPI, SourceService, SpeedUnits, SymbolService, SystemInfoPresenterAPI, SystemService, TEACH_MODE_SERVICE_MESSAGE_TYPE_BASE, TOOL_SERVICE_MESSAGE_TYPE_BASE, TREE_BUILDER_MESSAGE_TYPE_BASE, TabInputModel, TeachModeService, TeachModeState, TemperatureUnits, ThreadAction, TimeUnits, ToolService, TreeBuilder, UNSUBSCRIBE_MESSAGE_TYPE, UREventTarget, URFunction, URLogicProgram, URModule, URSymbol, URSymbolType, URVariable, UntilConditionType, VALIDATION_INVALID, VALIDATION_OK, VALIDATION_SERVICE_MESSAGE_TYPE_BASE, ValidationService, ValueObjectMap, VariableValueType, VoltageUnits, WaypointType, WebComponentDialogAPI, WorkerCommunicationChannel, controllerPose, convertPose, convertValue, createEventTargetCommChannel, createWorkerCommChannel, floatOperators, frameArraysAreSignificantlySimilar, getDirectionalVector, isCommunicationChannel, isControllerPose, isFunction, isJointPositions, isLogicProgram, isModule, isReferenceItem, isURSymbol, isValueItem, isVariable, isWaypoint, isWorkerScope, iskinematicPosition, operatorInverseMap, posesAreSignificantlySimilar, registerApplicationBehavior, registerOperatorScreenBehavior, registerOperators, registerProgramBehavior, registerSerializers, registerSidebarBehavior, registerSmartSkillBehavior, registerSourceBehavior, registerSystemInfoBehavior, threeJsPose, traversePoses, valueConverter, valueRawConverter, yUpEulerRotationRadians, yUpPositionMeters, yUpQuaternion, zUpEulerRotationRadians, zUpPositionMeters, zUpRotationVectorRadians };\n//# sourceMappingURL=universal-robots-contribution-api.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}