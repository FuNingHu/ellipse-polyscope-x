{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pool = exports.Thread = exports.PoolEventType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst ponyfills_1 = require(\"../ponyfills\");\nconst implementation_1 = require(\"./implementation\");\nconst pool_types_1 = require(\"./pool-types\");\nObject.defineProperty(exports, \"PoolEventType\", {\n  enumerable: true,\n  get: function () {\n    return pool_types_1.PoolEventType;\n  }\n});\nconst thread_1 = require(\"./thread\");\nObject.defineProperty(exports, \"Thread\", {\n  enumerable: true,\n  get: function () {\n    return thread_1.Thread;\n  }\n});\nlet nextPoolID = 1;\nfunction createArray(size) {\n  const array = [];\n  for (let index = 0; index < size; index++) {\n    array.push(index);\n  }\n  return array;\n}\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction flatMap(array, mapper) {\n  return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\nfunction slugify(text) {\n  return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n  return createArray(count).map(() => ({\n    init: spawnWorker(),\n    runningTasks: []\n  }));\n}\nclass WorkerPool {\n  constructor(spawnWorker, optionsOrSize) {\n    this.eventSubject = new observable_fns_1.Subject();\n    this.initErrors = [];\n    this.isClosing = false;\n    this.nextTaskID = 1;\n    this.taskQueue = [];\n    const options = typeof optionsOrSize === \"number\" ? {\n      size: optionsOrSize\n    } : optionsOrSize || {};\n    const {\n      size = implementation_1.defaultPoolSize\n    } = options;\n    this.debug = debug_1.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n    this.options = options;\n    this.workers = spawnWorkers(spawnWorker, size);\n    this.eventObservable = observable_fns_1.multicast(observable_fns_1.Observable.from(this.eventSubject));\n    Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n      type: pool_types_1.PoolEventType.initialized,\n      size: this.workers.length\n    }), error => {\n      this.debug(\"Error while initializing pool worker:\", error);\n      this.eventSubject.error(error);\n      this.initErrors.push(error);\n    });\n  }\n  findIdlingWorker() {\n    const {\n      concurrency = 1\n    } = this.options;\n    return this.workers.find(worker => worker.runningTasks.length < concurrency);\n  }\n  runPoolTask(worker, task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const workerID = this.workers.indexOf(worker) + 1;\n      this.debug(`Running task #${task.id} on worker #${workerID}...`);\n      this.eventSubject.next({\n        type: pool_types_1.PoolEventType.taskStart,\n        taskID: task.id,\n        workerID\n      });\n      try {\n        const returnValue = yield task.run(yield worker.init);\n        this.debug(`Task #${task.id} completed successfully`);\n        this.eventSubject.next({\n          type: pool_types_1.PoolEventType.taskCompleted,\n          returnValue,\n          taskID: task.id,\n          workerID\n        });\n      } catch (error) {\n        this.debug(`Task #${task.id} failed`);\n        this.eventSubject.next({\n          type: pool_types_1.PoolEventType.taskFailed,\n          taskID: task.id,\n          error,\n          workerID\n        });\n      }\n    });\n  }\n  run(worker, task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n        const removeTaskFromWorkersRunningTasks = () => {\n          worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n        };\n        // Defer task execution by one tick to give handlers time to subscribe\n        yield delay(0);\n        try {\n          yield this.runPoolTask(worker, task);\n        } finally {\n          removeTaskFromWorkersRunningTasks();\n          if (!this.isClosing) {\n            this.scheduleWork();\n          }\n        }\n      }))();\n      worker.runningTasks.push(runPromise);\n    });\n  }\n  scheduleWork() {\n    this.debug(`Attempt de-queueing a task in order to run it...`);\n    const availableWorker = this.findIdlingWorker();\n    if (!availableWorker) return;\n    const nextTask = this.taskQueue.shift();\n    if (!nextTask) {\n      this.debug(`Task queue is empty`);\n      this.eventSubject.next({\n        type: pool_types_1.PoolEventType.taskQueueDrained\n      });\n      return;\n    }\n    this.run(availableWorker, nextTask);\n  }\n  taskCompletion(taskID) {\n    return new Promise((resolve, reject) => {\n      const eventSubscription = this.events().subscribe(event => {\n        if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {\n          eventSubscription.unsubscribe();\n          resolve(event.returnValue);\n        } else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {\n          eventSubscription.unsubscribe();\n          reject(event.error);\n        } else if (event.type === pool_types_1.PoolEventType.terminated) {\n          eventSubscription.unsubscribe();\n          reject(Error(\"Pool has been terminated before task was run.\"));\n        }\n      });\n    });\n  }\n  settled(allowResolvingImmediately = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n      const taskFailures = [];\n      const failureSubscription = this.eventObservable.subscribe(event => {\n        if (event.type === pool_types_1.PoolEventType.taskFailed) {\n          taskFailures.push(event.error);\n        }\n      });\n      if (this.initErrors.length > 0) {\n        return Promise.reject(this.initErrors[0]);\n      }\n      if (allowResolvingImmediately && this.taskQueue.length === 0) {\n        yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n        return taskFailures;\n      }\n      yield new Promise((resolve, reject) => {\n        const subscription = this.eventObservable.subscribe({\n          next(event) {\n            if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n              subscription.unsubscribe();\n              resolve(void 0);\n            }\n          },\n          error: reject // make a pool-wide error reject the completed() result promise\n        });\n      });\n      yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n      failureSubscription.unsubscribe();\n      return taskFailures;\n    });\n  }\n  completed(allowResolvingImmediately = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const settlementPromise = this.settled(allowResolvingImmediately);\n      const earlyExitPromise = new Promise((resolve, reject) => {\n        const subscription = this.eventObservable.subscribe({\n          next(event) {\n            if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n              subscription.unsubscribe();\n              resolve(settlementPromise);\n            } else if (event.type === pool_types_1.PoolEventType.taskFailed) {\n              subscription.unsubscribe();\n              reject(event.error);\n            }\n          },\n          error: reject // make a pool-wide error reject the completed() result promise\n        });\n      });\n      const errors = yield Promise.race([settlementPromise, earlyExitPromise]);\n      if (errors.length > 0) {\n        throw errors[0];\n      }\n    });\n  }\n  events() {\n    return this.eventObservable;\n  }\n  queue(taskFunction) {\n    const {\n      maxQueuedJobs = Infinity\n    } = this.options;\n    if (this.isClosing) {\n      throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n    }\n    if (this.initErrors.length > 0) {\n      throw this.initErrors[0];\n    }\n    const taskID = this.nextTaskID++;\n    const taskCompletion = this.taskCompletion(taskID);\n    taskCompletion.catch(error => {\n      // Prevent unhandled rejections here as we assume the user will use\n      // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n      this.debug(`Task #${taskID} errored:`, error);\n    });\n    const task = {\n      id: taskID,\n      run: taskFunction,\n      cancel: () => {\n        if (this.taskQueue.indexOf(task) === -1) return;\n        this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n        this.eventSubject.next({\n          type: pool_types_1.PoolEventType.taskCanceled,\n          taskID: task.id\n        });\n      },\n      then: taskCompletion.then.bind(taskCompletion)\n    };\n    if (this.taskQueue.length >= maxQueuedJobs) {\n      throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" + \"This usually happens for one of two reasons: We are either at peak \" + \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n    }\n    this.debug(`Queueing task #${task.id}...`);\n    this.taskQueue.push(task);\n    this.eventSubject.next({\n      type: pool_types_1.PoolEventType.taskQueued,\n      taskID: task.id\n    });\n    this.scheduleWork();\n    return task;\n  }\n  terminate(force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isClosing = true;\n      if (!force) {\n        yield this.completed(true);\n      }\n      this.eventSubject.next({\n        type: pool_types_1.PoolEventType.terminated,\n        remainingQueue: [...this.taskQueue]\n      });\n      this.eventSubject.complete();\n      yield Promise.all(this.workers.map(worker => __awaiter(this, void 0, void 0, function* () {\n        return thread_1.Thread.terminate(yield worker.init);\n      })));\n    });\n  }\n}\nWorkerPool.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n  // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n  // If the Pool is a class or not is an implementation detail that should not concern the user.\n  return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexports.Pool = PoolConstructor;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}