{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spawn = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst common_1 = require(\"../common\");\nconst promise_1 = require(\"../promise\");\nconst symbols_1 = require(\"../symbols\");\nconst master_1 = require(\"../types/master\");\nconst invocation_proxy_1 = require(\"./invocation-proxy\");\nconst debugMessages = debug_1.default(\"threads:master:messages\");\nconst debugSpawn = debug_1.default(\"threads:master:spawn\");\nconst debugThreadUtils = debug_1.default(\"threads:master:thread-utils\");\nconst isInitMessage = data => data && data.type === \"init\";\nconst isUncaughtErrorMessage = data => data && data.type === \"uncaughtError\";\nconst initMessageTimeout = typeof process !== \"undefined\" && process.env.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10) : 10000;\nfunction withTimeout(promise, timeoutInMs, errorMessage) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let timeoutHandle;\n    const timeout = new Promise((resolve, reject) => {\n      timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);\n    });\n    const result = yield Promise.race([promise, timeout]);\n    clearTimeout(timeoutHandle);\n    return result;\n  });\n}\nfunction receiveInitMessage(worker) {\n  return new Promise((resolve, reject) => {\n    const messageHandler = event => {\n      debugMessages(\"Message from worker before finishing initialization:\", event.data);\n      if (isInitMessage(event.data)) {\n        worker.removeEventListener(\"message\", messageHandler);\n        resolve(event.data);\n      } else if (isUncaughtErrorMessage(event.data)) {\n        worker.removeEventListener(\"message\", messageHandler);\n        reject(common_1.deserialize(event.data.error));\n      }\n    };\n    worker.addEventListener(\"message\", messageHandler);\n  });\n}\nfunction createEventObservable(worker, workerTermination) {\n  return new observable_fns_1.Observable(observer => {\n    const messageHandler = messageEvent => {\n      const workerEvent = {\n        type: master_1.WorkerEventType.message,\n        data: messageEvent.data\n      };\n      observer.next(workerEvent);\n    };\n    const rejectionHandler = errorEvent => {\n      debugThreadUtils(\"Unhandled promise rejection event in thread:\", errorEvent);\n      const workerEvent = {\n        type: master_1.WorkerEventType.internalError,\n        error: Error(errorEvent.reason)\n      };\n      observer.next(workerEvent);\n    };\n    worker.addEventListener(\"message\", messageHandler);\n    worker.addEventListener(\"unhandledrejection\", rejectionHandler);\n    workerTermination.then(() => {\n      const terminationEvent = {\n        type: master_1.WorkerEventType.termination\n      };\n      worker.removeEventListener(\"message\", messageHandler);\n      worker.removeEventListener(\"unhandledrejection\", rejectionHandler);\n      observer.next(terminationEvent);\n      observer.complete();\n    });\n  });\n}\nfunction createTerminator(worker) {\n  const [termination, resolver] = promise_1.createPromiseWithResolver();\n  const terminate = () => __awaiter(this, void 0, void 0, function* () {\n    debugThreadUtils(\"Terminating worker\");\n    // Newer versions of worker_threads workers return a promise\n    yield worker.terminate();\n    resolver();\n  });\n  return {\n    terminate,\n    termination\n  };\n}\nfunction setPrivateThreadProps(raw, worker, workerEvents, terminate) {\n  const workerErrors = workerEvents.filter(event => event.type === master_1.WorkerEventType.internalError).map(errorEvent => errorEvent.error);\n  // tslint:disable-next-line prefer-object-spread\n  return Object.assign(raw, {\n    [symbols_1.$errors]: workerErrors,\n    [symbols_1.$events]: workerEvents,\n    [symbols_1.$terminate]: terminate,\n    [symbols_1.$worker]: worker\n  });\n}\n/**\n * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin\n * abstraction layer to provide the transparent API and verifies that\n * the worker has initialized successfully.\n *\n * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.\n * @param [options]\n * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.\n */\nfunction spawn(worker, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    debugSpawn(\"Initializing new thread\");\n    const timeout = options && options.timeout ? options.timeout : initMessageTimeout;\n    const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);\n    const exposed = initMessage.exposed;\n    const {\n      termination,\n      terminate\n    } = createTerminator(worker);\n    const events = createEventObservable(worker, termination);\n    if (exposed.type === \"function\") {\n      const proxy = invocation_proxy_1.createProxyFunction(worker);\n      return setPrivateThreadProps(proxy, worker, events, terminate);\n    } else if (exposed.type === \"module\") {\n      const proxy = invocation_proxy_1.createProxyModule(worker, exposed.methods);\n      return setPrivateThreadProps(proxy, worker, events, terminate);\n    } else {\n      const type = exposed.type;\n      throw Error(`Worker init message states unexpected type of expose(): ${type}`);\n    }\n  });\n}\nexports.spawn = spawn;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}