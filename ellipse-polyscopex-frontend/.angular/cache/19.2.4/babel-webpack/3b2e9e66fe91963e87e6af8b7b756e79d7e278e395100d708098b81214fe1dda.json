{"ast":null,"code":"import { Md5 } from './md5';\n// Hashes any blob\nexport class Md5FileHasher {\n  constructor(_callback,\n  // Callback to return the result\n  _async = true,\n  // Async version is not always available in a web worker\n  _partSize = 1048576) {\n    this._callback = _callback;\n    this._async = _async;\n    this._partSize = _partSize;\n    this._configureReader();\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   */\n  hash(blob) {\n    const self = this;\n    self._blob = blob;\n    // self._length = Math.ceil(blob.size / self._partSize);\n    self._part = 0;\n    self._md5 = new Md5();\n    self._processPart();\n  }\n  _fail() {\n    this._callback({\n      success: false,\n      result: 'data read failed'\n    });\n  }\n  _hashData(e) {\n    let self = this;\n    self._md5.appendByteArray(new Uint8Array(e.target.result));\n    if (self._part * self._partSize >= self._blob.size) {\n      self._callback({\n        success: true,\n        result: self._md5.end()\n      });\n    } else {\n      self._processPart();\n    }\n  }\n  _processPart() {\n    const self = this;\n    let endbyte = 0;\n    let current_part;\n    self._part += 1;\n    if (self._blob.size > self._partSize) {\n      // If blob bigger then part_size we will slice it up\n      endbyte = self._part * self._partSize;\n      if (endbyte > self._blob.size) {\n        endbyte = self._blob.size;\n      }\n      current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n    } else {\n      current_part = self._blob;\n    }\n    if (self._async) {\n      self._reader.readAsArrayBuffer(current_part);\n    } else {\n      setTimeout(() => {\n        try {\n          self._hashData({\n            target: {\n              result: self._reader.readAsArrayBuffer(current_part)\n            }\n          });\n        } catch (e) {\n          self._fail();\n        }\n      }, 0);\n    }\n  }\n  _configureReader() {\n    const self = this;\n    if (self._async) {\n      self._reader = new FileReader();\n      self._reader.onload = self._hashData.bind(self);\n      self._reader.onerror = self._fail.bind(self);\n      self._reader.onabort = self._fail.bind(self);\n    } else {\n      self._reader = new FileReaderSync();\n    }\n  }\n}\n//# sourceMappingURL=md5_file_hasher.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}