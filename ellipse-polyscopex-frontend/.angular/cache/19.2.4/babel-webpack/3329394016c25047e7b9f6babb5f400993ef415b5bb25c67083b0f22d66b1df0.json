{"ast":null,"code":"\"use strict\";\n\n/*\n * This source file contains the code for proxying calls in the master thread to calls in the workers\n * by `.postMessage()`-ing.\n *\n * Keep in mind that this code can make or break the program's performance! Need to optimize moreâ€¦\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createProxyModule = exports.createProxyFunction = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst common_1 = require(\"../common\");\nconst observable_promise_1 = require(\"../observable-promise\");\nconst transferable_1 = require(\"../transferable\");\nconst messages_1 = require(\"../types/messages\");\nconst debugMessages = debug_1.default(\"threads:master:messages\");\nlet nextJobUID = 1;\nconst dedupe = array => Array.from(new Set(array));\nconst isJobErrorMessage = data => data && data.type === messages_1.WorkerMessageType.error;\nconst isJobResultMessage = data => data && data.type === messages_1.WorkerMessageType.result;\nconst isJobStartMessage = data => data && data.type === messages_1.WorkerMessageType.running;\nfunction createObservableForJob(worker, jobUID) {\n  return new observable_fns_1.Observable(observer => {\n    let asyncType;\n    const messageHandler = event => {\n      debugMessages(\"Message from worker:\", event.data);\n      if (!event.data || event.data.uid !== jobUID) return;\n      if (isJobStartMessage(event.data)) {\n        asyncType = event.data.resultType;\n      } else if (isJobResultMessage(event.data)) {\n        if (asyncType === \"promise\") {\n          if (typeof event.data.payload !== \"undefined\") {\n            observer.next(common_1.deserialize(event.data.payload));\n          }\n          observer.complete();\n          worker.removeEventListener(\"message\", messageHandler);\n        } else {\n          if (event.data.payload) {\n            observer.next(common_1.deserialize(event.data.payload));\n          }\n          if (event.data.complete) {\n            observer.complete();\n            worker.removeEventListener(\"message\", messageHandler);\n          }\n        }\n      } else if (isJobErrorMessage(event.data)) {\n        const error = common_1.deserialize(event.data.error);\n        if (asyncType === \"promise\" || !asyncType) {\n          observer.error(error);\n        } else {\n          observer.error(error);\n        }\n        worker.removeEventListener(\"message\", messageHandler);\n      }\n    };\n    worker.addEventListener(\"message\", messageHandler);\n    return () => {\n      if (asyncType === \"observable\" || !asyncType) {\n        const cancelMessage = {\n          type: messages_1.MasterMessageType.cancel,\n          uid: jobUID\n        };\n        worker.postMessage(cancelMessage);\n      }\n      worker.removeEventListener(\"message\", messageHandler);\n    };\n  });\n}\nfunction prepareArguments(rawArgs) {\n  if (rawArgs.length === 0) {\n    // Exit early if possible\n    return {\n      args: [],\n      transferables: []\n    };\n  }\n  const args = [];\n  const transferables = [];\n  for (const arg of rawArgs) {\n    if (transferable_1.isTransferDescriptor(arg)) {\n      args.push(common_1.serialize(arg.send));\n      transferables.push(...arg.transferables);\n    } else {\n      args.push(common_1.serialize(arg));\n    }\n  }\n  return {\n    args,\n    transferables: transferables.length === 0 ? transferables : dedupe(transferables)\n  };\n}\nfunction createProxyFunction(worker, method) {\n  return (...rawArgs) => {\n    const uid = nextJobUID++;\n    const {\n      args,\n      transferables\n    } = prepareArguments(rawArgs);\n    const runMessage = {\n      type: messages_1.MasterMessageType.run,\n      uid,\n      method,\n      args\n    };\n    debugMessages(\"Sending command to run function to worker:\", runMessage);\n    try {\n      worker.postMessage(runMessage, transferables);\n    } catch (error) {\n      return observable_promise_1.ObservablePromise.from(Promise.reject(error));\n    }\n    return observable_promise_1.ObservablePromise.from(observable_fns_1.multicast(createObservableForJob(worker, uid)));\n  };\n}\nexports.createProxyFunction = createProxyFunction;\nfunction createProxyModule(worker, methodNames) {\n  const proxy = {};\n  for (const methodName of methodNames) {\n    proxy[methodName] = createProxyFunction(worker, methodName);\n  }\n  return proxy;\n}\nexports.createProxyModule = createProxyModule;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}