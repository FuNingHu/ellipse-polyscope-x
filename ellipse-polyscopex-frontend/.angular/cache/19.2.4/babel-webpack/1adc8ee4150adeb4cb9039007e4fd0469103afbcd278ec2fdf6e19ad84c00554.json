{"ast":null,"code":"import Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nclass MulticastSubject extends Observable {\n  constructor() {\n    super(observer => {\n      this._observers.add(observer);\n      return () => this._observers.delete(observer);\n    });\n    this._observers = new Set();\n  }\n  next(value) {\n    for (const observer of this._observers) {\n      observer.next(value);\n    }\n  }\n  error(error) {\n    for (const observer of this._observers) {\n      observer.error(error);\n    }\n  }\n  complete() {\n    for (const observer of this._observers) {\n      observer.complete();\n    }\n  }\n}\nexport default MulticastSubject;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}