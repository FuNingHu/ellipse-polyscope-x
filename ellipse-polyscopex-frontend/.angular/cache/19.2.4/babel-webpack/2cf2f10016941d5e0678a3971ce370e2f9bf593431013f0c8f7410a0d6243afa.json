{"ast":null,"code":"/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n  const value = obj[key];\n  if (value == null) {\n    return undefined;\n  }\n  if (typeof value !== \"function\") {\n    throw new TypeError(value + \" is not a function\");\n  }\n  return value;\n}\nfunction getSpecies(obj) {\n  let ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n  if (hostReportError.log) {\n    hostReportError.log(error);\n  } else {\n    setTimeout(() => {\n      throw error;\n    }, 0);\n  }\n}\nfunction enqueue(fn) {\n  Promise.resolve().then(() => {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\nfunction cleanupSubscription(subscription) {\n  const cleanup = subscription._cleanup;\n  if (cleanup === undefined) {\n    return;\n  }\n  subscription._cleanup = undefined;\n  if (!cleanup) {\n    return;\n  }\n  try {\n    if (typeof cleanup === \"function\") {\n      cleanup();\n    } else {\n      const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n  const queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = \"ready\";\n  for (const item of queue) {\n    notifySubscription(subscription, item.type, item.value);\n    if (subscription._state === \"closed\") {\n      break;\n    }\n  }\n}\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = \"running\";\n  const observer = subscription._observer;\n  try {\n    const m = observer ? getMethod(observer, type) : undefined;\n    switch (type) {\n      case \"next\":\n        if (m) m.call(observer, value);\n        break;\n      case \"error\":\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case \"complete\":\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n  if (subscription._state === \"closed\") {\n    cleanupSubscription(subscription);\n  } else if (subscription._state === \"running\") {\n    subscription._state = \"ready\";\n  }\n}\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === \"closed\") {\n    return;\n  }\n  if (subscription._state === \"buffering\") {\n    subscription._queue = subscription._queue || [];\n    subscription._queue.push({\n      type,\n      value\n    });\n    return;\n  }\n  if (subscription._state !== \"ready\") {\n    subscription._state = \"buffering\";\n    subscription._queue = [{\n      type,\n      value\n    }];\n    enqueue(() => flushSubscription(subscription));\n    return;\n  }\n  notifySubscription(subscription, type, value);\n}\nexport class Subscription {\n  constructor(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = \"initializing\";\n    const subscriptionObserver = new SubscriptionObserver(this);\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n    if (this._state === \"initializing\") {\n      this._state = \"ready\";\n    }\n  }\n  get closed() {\n    return this._state === \"closed\";\n  }\n  unsubscribe() {\n    if (this._state !== \"closed\") {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  }\n}\nexport class SubscriptionObserver {\n  constructor(subscription) {\n    this._subscription = subscription;\n  }\n  get closed() {\n    return this._subscription._state === \"closed\";\n  }\n  next(value) {\n    onNotify(this._subscription, \"next\", value);\n  }\n  error(value) {\n    onNotify(this._subscription, \"error\", value);\n  }\n  complete() {\n    onNotify(this._subscription, \"complete\");\n  }\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport class Observable {\n  constructor(subscriber) {\n    if (!(this instanceof Observable)) {\n      throw new TypeError(\"Observable cannot be called as a function\");\n    }\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Observable initializer must be a function\");\n    }\n    this._subscriber = subscriber;\n  }\n  subscribe(nextOrObserver, onError, onComplete) {\n    if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n      nextOrObserver = {\n        next: nextOrObserver,\n        error: onError,\n        complete: onComplete\n      };\n    }\n    return new Subscription(nextOrObserver, this._subscriber);\n  }\n  pipe(first, ...mappers) {\n    // tslint:disable-next-line no-this-assignment\n    let intermediate = this;\n    for (const mapper of [first, ...mappers]) {\n      intermediate = mapper(intermediate);\n    }\n    return intermediate;\n  }\n  tap(nextOrObserver, onError, onComplete) {\n    const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null ? {\n      next: nextOrObserver,\n      error: onError,\n      complete: onComplete\n    } : nextOrObserver;\n    return new Observable(observer => {\n      return this.subscribe({\n        next(value) {\n          tapObserver.next && tapObserver.next(value);\n          observer.next(value);\n        },\n        error(error) {\n          tapObserver.error && tapObserver.error(error);\n          observer.error(error);\n        },\n        complete() {\n          tapObserver.complete && tapObserver.complete();\n          observer.complete();\n        },\n        start(subscription) {\n          tapObserver.start && tapObserver.start(subscription);\n        }\n      });\n    });\n  }\n  forEach(fn) {\n    return new Promise((resolve, reject) => {\n      if (typeof fn !== \"function\") {\n        reject(new TypeError(fn + \" is not a function\"));\n        return;\n      }\n      function done() {\n        subscription.unsubscribe();\n        resolve(undefined);\n      }\n      const subscription = this.subscribe({\n        next(value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error(error) {\n          reject(error);\n        },\n        complete() {\n          resolve(undefined);\n        }\n      });\n    });\n  }\n  map(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n    const C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        let propagatedValue = value;\n        try {\n          propagatedValue = fn(value);\n        } catch (e) {\n          return observer.error(e);\n        }\n        observer.next(propagatedValue);\n      },\n      error(e) {\n        observer.error(e);\n      },\n      complete() {\n        observer.complete();\n      }\n    }));\n  }\n  filter(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n    const C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          if (!fn(value)) return;\n        } catch (e) {\n          return observer.error(e);\n        }\n        observer.next(value);\n      },\n      error(e) {\n        observer.error(e);\n      },\n      complete() {\n        observer.complete();\n      }\n    }));\n  }\n  reduce(fn, seed) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n    const C = getSpecies(this);\n    const hasSeed = arguments.length > 1;\n    let hasValue = false;\n    let acc = seed;\n    return new C(observer => this.subscribe({\n      next(value) {\n        const first = !hasValue;\n        hasValue = true;\n        if (!first || hasSeed) {\n          try {\n            acc = fn(acc, value);\n          } catch (e) {\n            return observer.error(e);\n          }\n        } else {\n          acc = value;\n        }\n      },\n      error(e) {\n        observer.error(e);\n      },\n      complete() {\n        if (!hasValue && !hasSeed) {\n          return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n        }\n        observer.next(acc);\n        observer.complete();\n      }\n    }));\n  }\n  concat(...sources) {\n    const C = getSpecies(this);\n    return new C(observer => {\n      let subscription;\n      let index = 0;\n      function startNext(next) {\n        subscription = next.subscribe({\n          next(v) {\n            observer.next(v);\n          },\n          error(e) {\n            observer.error(e);\n          },\n          complete() {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n        });\n      }\n      startNext(this);\n      return () => {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  }\n  flatMap(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n    const C = getSpecies(this);\n    return new C(observer => {\n      const subscriptions = [];\n      const outer = this.subscribe({\n        next(value) {\n          let normalizedValue;\n          if (fn) {\n            try {\n              normalizedValue = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            normalizedValue = value;\n          }\n          const inner = C.from(normalizedValue).subscribe({\n            next(innerValue) {\n              observer.next(innerValue);\n            },\n            error(e) {\n              observer.error(e);\n            },\n            complete() {\n              const i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n          });\n          subscriptions.push(inner);\n        },\n        error(e) {\n          observer.error(e);\n        },\n        complete() {\n          completeIfDone();\n        }\n      });\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) {\n          observer.complete();\n        }\n      }\n      return () => {\n        subscriptions.forEach(s => s.unsubscribe());\n        outer.unsubscribe();\n      };\n    });\n  }\n  [(Symbol.observable, SymbolObservable)]() {\n    return this;\n  }\n  static from(x) {\n    const C = typeof this === \"function\" ? this : Observable;\n    if (x == null) {\n      throw new TypeError(x + \" is not an object\");\n    }\n    const observableMethod = getMethod(x, SymbolObservable);\n    if (observableMethod) {\n      const observable = observableMethod.call(x);\n      if (Object(observable) !== observable) {\n        throw new TypeError(observable + \" is not an object\");\n      }\n      if (isObservable(observable) && observable.constructor === C) {\n        return observable;\n      }\n      return new C(observer => observable.subscribe(observer));\n    }\n    if (hasSymbol(\"iterator\")) {\n      const iteratorMethod = getMethod(x, SymbolIterator);\n      if (iteratorMethod) {\n        return new C(observer => {\n          enqueue(() => {\n            if (observer.closed) return;\n            for (const item of iteratorMethod.call(x)) {\n              observer.next(item);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n    }\n    if (Array.isArray(x)) {\n      return new C(observer => {\n        enqueue(() => {\n          if (observer.closed) return;\n          for (const item of x) {\n            observer.next(item);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n    throw new TypeError(x + \" is not observable\");\n  }\n  static of(...items) {\n    const C = typeof this === \"function\" ? this : Observable;\n    return new C(observer => {\n      enqueue(() => {\n        if (observer.closed) return;\n        for (const item of items) {\n          observer.next(item);\n          if (observer.closed) return;\n        }\n        observer.complete();\n      });\n    });\n  }\n  static get [SymbolSpecies]() {\n    return this;\n  }\n}\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol(\"extensions\"), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError\n    },\n    configurable: true\n  });\n}\nexport default Observable;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}